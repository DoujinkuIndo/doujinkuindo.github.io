---
layout: post
title: Object oriented
---

## 객체지향 프로그래밍을 위한 노력

> 객체지향 프로그래밍을, 각각의 객체들의 역할이 무엇인지 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것 으로 이해했습니다.
> 
> 따라서, 객체는 서로 책임을 주고 받기 위해 메시지(메서드)를 사용하고, 누구에게 책임을 할당하고, 어떻게 메시지를 구성해야 하는가를 중요하게 생각해야 한다고 이해했습니다.

<details><summary>추상화하기</summary>
<div markdown="1">

[Abstraction](https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Control_abstraction)

객체 지향 프로그래밍에서는 **추상화**라는 단어를 여러 군데 붙일 수 있습니다. 여기서 말하는 추상화는 추상 클래스나 추상 클래스가 갖는 추상 메서드를 의미하기보다는 클래스를 설계하는 것 자체를 의미합니다. **즉, "공통의" 속성이나 기능을 묶어 이름을 붙이는 것입니다.**

* **추상화의 본질은 주어진 컨텍스트와 관련된 정보를 보존하고 해당 컨텍스트와 관련이 없는 정보를 잊어버리는 것입니다.**

**객체가 현실 세계에서의 존재하는 것들을 나타내기 위해서는 추상화(abstraction)라는 과정을 거칩니다.** 컴퓨터 상에서 현실 세계를 100% 나타낼 수 없기 때문에, 적절하게 컴퓨터에서 처리할 수 있도록 바꿀 필요가 있습니다.예를 들어서 핸드폰의 경우 '전화를 한다', '문자를 보낸다'와 같은 것들은 **핸드폰이 하는 것**이므로 함수로 추상화시킬 수 있고, 핸드폰의 상태를 나타내는 것들, 예를 들어서 자기 자신의 전화 번호나 배터리 잔량 같은 것은 변수로 추상화 시킬 수 있습니다.

객체 지향 프로그래밍 이론에서 추상화는 작업을 수행하고 상태를 보고하고 변경하며 시스템의 다른 객체와 "통신"할 수 있는 추상적인 "행위자"를 나타내는 객체를 정의하는 기능을 포함합니다. **캡슐화**라는 용어 는 상태 세부 정보 를 숨기는 것을 의미 하지만 이전 프로그래밍 언어에서 데이터 유형 의 개념을 확장하여 동작 을 데이터와 가장 강력하게 연관시키고 다양한 데이터 유형이 상호 작용하는 방식을 표준화하는 것이 추상화의 시작입니다. 추상화가 정의된 작업으로 진행되어 다른 유형의 객체를 대체할 수 있게 하는 것을 다형성 이라고 합니다. 유형이나 클래스 내부에서 반대 방향으로 진행될 때 복잡한 관계 집합을 단순화하도록 구조화하는 것을 위임 또는 상속 이라고 합니다.

<details><summary>코드 예시</summary>
<div markdown="1">

```cpp
class Phone
{
public:
    bool Message(Phone* Target);
    bool Call(Phone* Target);
private:
    PhoneNumberStruct Number;
};
```

</div></details>

<center><div markdown="1">

![Object](https://qph.cf2.quoracdn.net/main-qimg-8876cd691a71ad2aa914bd4519df93d3)

</div></center>

이와 같이 어떠한 객체는 자신만의 정보를 나타내는 변수들과, 이를 가지고 어떠한 작업을 하는 함수들로 둘러싸고 있습니다.

</div></details>

<details><summary>상속이란</summary>
<div markdown="1">

**미닫이 문은 문인 경우처럼 is-a의 경우 상속했습니다.** 하지만, 여닫이 문과 미닫이 문의 동작은 서로 다르므로 **다형성을 구현하기 위해서 가상 함수를 이용했습니다.**

자식 클래스가 부모 클래스를 대체할 때 자식클래스에서 오류가 발생하면 문제를 찾기 어려운 것으로 이해했습니다. 따라서 **자식 클래스는 부모의 책임을 그대로 이어가며 확장만 수행하도록 노력하고 있습니다.**

</div></details>

<details><summary>의존이란</summary>
<div markdown="1">

또한 매우 구체적인 그리고 개발하면서 계속 **변하는 액터에 의존하는 것 보다는, 잘 바뀌지 않는 인터페이스를 의존하도록 했습니다.** 손의 경우 1인칭 양손이 있을 수 있고, 캐릭터 스켈레탈 메시와 손이 협력해야 하는 경우가 있을 수 있습니다. 이때 인터페이스를 이용했습니다.

</div></details>

[역할, 책임, 협력](https://incheol-jung.gitbook.io/docs/study/object/2020-03-10-object-chap3)

객체 지향 패러다임의 관점에서 핵심은 3가지로 표현할 수 있다고 합니다.

1. **협력(collaboration)**은 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용 입니다.
2. **책임(responsibility)**은 객체가 협력에 참여하기 위해서 수행하는 로직입니다.
3. **역활(role)**은 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행합니다.

* 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추면, 변경하기 어렵고 유연하지 못한 코드를 만드는 원인이 됩니다.
* 저는 책임을 전가하고, 경유 하도록 한다음, 파기될 예정임을 알려, 힘들게 수정하기도 합니다. 그래도 책임 전가가 많아, 경고문으로 도배된 상황 보다는 최소한의 경고문만 있는 것이 좋습니다.

**책임을 부여할 때, 하나의 클래스가 가능한 하나의 책임만 가지게 하도록 했습니다.** 예를 들어 캐릭터와 그 부속품 메시, 캐릭터 등이 있을 경우, 캐릭터는 부품들을 조립한 월드상에 존재하는 액터로, 실제 물건을 잡는 것은 손이, 그리고 렌더링 되는 것은 메시가 책임지도록 했습니다.

**여러 종류의 객체가 참여할 경우, 역할 인터페이스를 주었습니다.** 모든 액터가 하나의 액터 클래스로부터 구현되지는 않기 때문에, 예를 들어 불탈수 있다는 역할을 주어 폭탄 액터가 폭팔 했을 때, 조건이 충족되는 액터들이 불타라하는 메시지를 전달하도록 했습니다.

이때 인터페이스가 너무 많은 역할을 한다면 사용하지 않을 구현을 하게 되므로 **인터페이스는 하나의 역할만 하도록 노력하고 있습니다.**

<details><summary>협력이란</summary>
<div markdown="1">

**자율적인 객체**란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체입니다. 자율성을 보장하기 위해서는 **필요한 정보**와 **정보에 기반한 행동**을 같은 객체안에 모아놓아야 합니다.

자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있습니다.결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것입니다.

**협력이 설계를 위한 문맥을 결정합니다.** 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 합니다. 그 객체가 어떤 협력에 참여하고 있어야 합니다. 그리고 객체가 협력에 참여할 수 있기 위해서는 협력에 필요한 **적절한 행동**을 보유하고 있어야 합니다.

</div></details>

<details><summary>책임이란</summary>
<div markdown="1">

책임이란 객체에 의해 정의되는 응집도가 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장입니다. 즉, 객체의 책임은 객체가 **'무엇을 알고 있는가'**와 **'무엇을 할 수 있는가'**로 구성됩니다.

아는 것은
1. 사적인 정보에 관해 아는 것
2. 관련된 객체에 관해 아는 것
3. 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것이

하는 것은
1. 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
2. 다른 객체의 행동을 시작시키는 것
3. 다른 객체의 활동을 제어하고 조절하는 것

책임의 관점에서 '아는 것'과 '하는 것'이 밀접하게 연관되어 있습니다. 따라서 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정합니다.

**책임의 할당**

자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것입니다. 이를 책임 할당을 위한 INFORMATION EXPERT 패턴이라고 부릅니다.

객체들 역시 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청합니다. 요청에 응답하기 위해 필요한 이 행동이 객체가 수행할 책임으로 이어지는 것 입니다.

협력을 설계하면서 객체의 책임을 식벼해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션의 목록입니다.

물론 모든 책임 할당 과정이 이렇게 단순한 것은 아닙니다. 어떤 경우에는 응집도와 결합도의 과점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있습니다.

**책임 주도 설계**

어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정합니다. 이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임 주도 설계(Responsibility-Driven Design, RDD)라고 부릅니다.

**책임 주도 설계의 과정은 다음과 같습니다.**
* 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악합니다.
* 시스템 책임을 더 작은 책임으로 분할합니다.
* 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당합니다.
* 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾습니다.
* 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 합니다.

구현이 아닌 책임에 집중하는 것이 중요한 이유는, 유연하고 견고한 객체지향 시스템을 위해 가장 중요한 재료가 바로 책임이기 때문입니다.

**메시지가 객체를 결정합니다.**

메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있습니다.
* 객체가 최소한의 인터페이스를 가질 수 있게 합니다.
* 객체는 충분히 추상적인 인터페이스를 가질 수 있게 됩니다.

**행동이 상태를 결정합니다.**
객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동입니다.

**초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정합니다.** 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해합니다. 객체의 내부 구현에 초점을 맞춘 설계 방법을 데이터-주도 설계(Data-Driven Design)이라고 부릅니다.

</div></details>

## 객체지향 장단점
캐릭터가 물건을 잡을 때, 캐릭터의 손이 쥔다라는 메시지를 받는 것처럼 사람의 관점에서 이해하고 파악하기 쉽습니다. 손과 관련해, 쥐다, 펴다 등의 코드가 모여있기 때문에 강한 응집력을 가집니다. 손 Component는 캐릭터가 아닌, 기계 더미에 붙여 재사용 할 수 있습니다. 다만 이를 위해서, 객체 간의 정보 교환으로 인해 함수 호출에 따른 많은 오버헤드가 있습니다.