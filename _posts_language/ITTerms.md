---
layout: post
title: IT terms
---

## IT 용어
### 레거시 시스템(Legacy System)
[레거시 시스템](https://ko.wikipedia.org/wiki/%EB%A0%88%EA%B1%B0%EC%8B%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C)

레거시 시스템(legacy system)은 낡은 기술이나 방법론, 컴퓨터 시스템, 소프트웨어 등을 말한다. 이는 현대까지도 남아 쓰이는 기술을 부르는 말일 수도 있지만, 더 이상 쓰이지 않더라도 현대의 기술에 영향을 주는 경우도 포함한다.

예를 들어 미국 항공우주국의 스페이스 셔틀은 처음 만들어졌을 때의 기술을 쓴 부품을 계속 써왔다. 안정성 등의 조건을 충족시키면서 부품을 새로 개발하는 것은 너무 비용이 많이 들었기 때문에, 대부분의 부품을 1970년대 기술로 계속 만들어 써온 것이다.

많은 소프트웨어 개발자들이 레거시 시스템을 사용하는 것에 잠재적 문제가 있다고 생각한다. 예를 들어 오래된 하드웨어를 위해 설계된 소프트웨어의 경우, 새로운 하드웨어에서 실행되도록 하기 위해서 에뮬레이션이나 하위 호환성을 구현해줘야 할 수 있다.

### 검사(Verification)
'소프트웨어가 기획서의 요구 사항에 맞게 올바르게 만들어졌는가?'를 확인하는 것

문서와 파일을 검사하는 명세 기반의 확인 방법이다.
개발 단계의 시작 부분에서 부과된 조건을 만족하는지를 확인해 소프트웨어를 평가하는 과정이다.(CMMI-SW v1.1)

### 검증(Validation)
'소프트웨어가 실제 의도한 용도를 충족할 수 있는가?'를 확인하는 것

사용자의 관점에서 확인으로 코드 실행을 수반한다
개발과정 중,또는 끝에 소프트웨어를 평가하는 과정이다.(CMMI-SW v1.1)

### API(Application Programming Interface)

API는 프로그램의 기능을 다른 프로그램이 쓸 수 있게 하는 것이 목적입니다.

* private API는 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행합니다. 따라서 제 3자에게 노출되지 않습니다.
* public API는 모두에게 공개됩니다. 누구나 제한 없이 API를 사용할 수 있는 게 특징입니다.
* partner API는 기업이 데이터 공유에 동의하는 특정인들만 사용할 수 있습니다. 비즈니스 관계에서 사용되는 편이며, 종종 파트너 회사 간에 소프트웨어를 통합하기 위해서 사용됩니다.

### SDK(Software Development Kit)

`Software Development Kit`의 약자로, 프로그래머들을 위해서 제공하는 개발 도구들인데, 예를들면 IOS 응용프로그램을 개발하려면 IOS SDK를 이용해야합니다.

SDK안에는 IDE(통합개발환경)을 포함하는데, 이에는 여러 API, 디버깅, 문서 등 여러 도구가 들어있습니다.


### ISA(Industry Standard Architecture)
[ISA](http://www.ktword.co.kr/word/abbr_view.php?m_temp1=732)

초기 PC인 IBM PC의 XT 및 AT에서 사용하던, 8비트 또는 16비트 버스 구조 방식

* 버스폭  : 16 비트 단위
* 최대전송속도 : 8 MB/s

* 버스(Bus)란 2 이상의 관련된 시호선들을 모아놓은 것으로 공통 기능을 수행하는 배선 그룹을 말합니다. 회로도 상에서는 보통 굵은 선으로 표시합니다.

! [Bus](http://www.ktword.co.kr/img_data/1249_1.JPG)

* 컴퓨터 버스 구조는 다음과 같습니다.
    - 시스템 버스는 CPU와 노스브리지(north bridge) 칩셋 간의 데이터 통로 입니다. 주로, 컴퓨터 CPU 보드 즉, 인쇄회로기판(PCB)상의 전기적 신호입니다.
    - I/O 버스는 CPU보드와 사우스브리지 칩셋(South bridge, I/O 컨트롤러)을 통한 외부 입출력 장치 간의 버스입니다.

### 프레임워크
자주쓰는 기능을 모아둔 것을 프레임워크라고 합니다. 예로 C#의 타이머등을 들 수 있습니다.

### 도메인, 비즈니스의 의미
도메인 로직, 비즈니스 로직이라는 말은 거의 동의어처럼 쓰입니다.

여기서 도메인이나 비즈니스라는 단어는 우리가 자주 쓰는 맥락과는 조금 다릅니다. 소프트웨어 공학에서 도메인, 비즈니스라는 말은, '소프트웨어가 풀고자하는 현실 세상의 문제'를 가르킵니다.

은행 앱이라면, 금융 및 은행 업무가 도메인입니다. 은행 앱이 해결하고자 하는 문제가 금융업무를 스마트폰에서 처리할 수 있게 해주는 것 이기 때문입니다. 틱톡 같은 SNS라면 동영상 촬영, 감상, 댓글 및 공유일 것 입니다.

조금 더 이해를 돕자면, 반대로 공학/기술적인 문제에 속하는 것들은 대게 '도메인'과는 구별됩니다. 수많은 은행 사용자 데이터를 어떻게 효율적으로 저장할 것인가? 어떻게 고화질 동영상을 빠르게 로딩할 것인가? 같은 것들입니다.

* 소프트웨어는 다 현실 문제를 해결하는 것이 아닙니다. 특정 문제 영역에 대한 솔루션을 제공하는 코드 외에도 많은 코드를 써야합니다. 그 코드를 가능하게 만들고, 입력과 출력을 처리하기 위한 로직들입니다. 대표적으로 데이터베이스에 연결하고, 백엔드 서버와 통신하고, 사용자와 인터랙션하는 코드들이 필요합니다. 이런 것들은 도메인 로직과 구분지어 어플리케이션 서비스 로직이라고 부릅니다.

기준을 세워서 도메인 로직과 아닌 것을 나누는 이유는 명확한 관심사의 분리를 위해서입니다.

도메인 로직과 어플리케이션 서비스 로직은 어떤 앱이든 역활이 구분되고, 변경의 이유도 다르기 때문입니다.

도메인 로직과 아닌 것을 잘 나누고 결합도를 낮추면, 개발자가 로직을 이해하기 쉬워집니다. DB나 UI같은 기술적인 구현 사항에 신경 쓰지 않고, 도메인 로직을 이해할 수 있습니다.

비즈니스 정책이 바뀔 때 소프트웨어를 변경하고 기능을 추가하는 것이 편해집니다.

이런 이유로 클린 아키텍처에서는 도메인 로직을 앱의 코어로 두고, 다른 계층에 의존하지 않도록  설게합니다. 다른 계층들은 도메인 로직에게 입력을 전달하고, 변화를 외부로 전달하는 역활을 하도록 명확하게 분리합니다.

### CI/CD
[CI/CD](https://artist-developer.tistory.com/24), [CI/CD란 무엇인가](https://jud00.tistory.com/entry/CICD%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)

CI/CD는 애플리케이션 개발 단계부터 배포 때까지의 모든 단계를 자동화를 통해서 좀 더 효율적이고 빠르게 사용자에게 빈번히 배포할 수 있는 것을 말합니다.

CI/CD의 개념만을 두고 보자면 자동화와 직접적으로 관련이 있지는 않습니다. 하지만 그럼에도 자동화라는 키워드는 CI/CD라는 단어에 거의 항상 따라붙습니다.

* CI/CD는 DevOps 엔지니어의 핵심 업무라고 불리기도 합니다.

### MVP sketch (Minimum Viable Produc)

MVP릴리스에 중점을 둔다는 것은 개발자가 잠재적으로 길고(아마도) 불필요한 작업을 피할 수 있음을 의미합니다. 대신 작업 버전을 반복하고 피드백에 응답하여 제품 요구 사항에 대한 가정에 도전하고 검증합니다.

## 기본 용어
[부동 소수점 연산. 단정밀도와 배정밀도의 차이](https://gigglehd.com/gg/hard/5427559)

### 고정 소수점
#### 부동소수점
부동소수점(浮動小數點, floating point) 또는 떠돌이 소수점 방식은 실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수(假數)와 소수점의 위치를 풀이하는 지수(指數)로 나누어 표현한다.

컴퓨터에서는 고정 소수점 방식보다 넓은 범위의 수를 나타낼 수 있어 과학기술 계산에 많이 이용되지만, 근삿값으로 표현되며 고정 소수점 방식보다 연산 속도가 느리기 때문에 별도의 전용 연산 장치를 두는 경우가 많다. 고정 소수점과 달리 정수 부분과 소수 부분의 자릿수가 일정하지 않으나, 유효 숫자의 자릿수는 정해져 있다.

* 부동소수점 활용에 관련해서 찾아볼 필요가 있습니다.

**어떻게 계산하는가?**
예를 들어, 십진수 21.8125를 정규화된 이진수로 나타낸다고 해보자. 소수점 위의 (21.)10=(10101)2이고, 소수점 아래 (0.8125)10=(1101)2이다. 즉 (21.8125)10=(10101.1101)2이며, 이를 정규화하면 0.101011101×25이다. 지수의 5를 이진법으로 바꾸면 101이다. 따라서, 32비트 정규화된 부동소수점수로 나타낸다면 맨 앞 비트의 부호는 0(양)이고, 지수부 부호는 0(양)이며, 지수부 나머지 6개 비트는 000101, 가수부는 101011101000…이 된다. 이것을 결합하면 (0000001011010111010000000000000000)2가 된다.

### 부동 소수점 연산. 단정밀도와 배정밀도의 차이
#### 계산식의 자리수를 억제, 부동 소수점
컴퓨터는 숫자를 연산할 때 정수 연산과 소수 연산의 2가지로 나눠 구현합니다. 이건 '처리해야 하는 숫자의 자리수'가 매번 다르기 때문입니다. 

#### 왜 부동소수점을 쓰는가?
정수는 보통 10자리 정도면 충분합니다. 대규모 기업의 회계 처리라면 10자리로도 부족하지만 그런 경우는 많지 않겠지요. 그러나 소수는 필요한 자리수가 매번 다릅니다. 옐르 들어 백만원이라면 7자리인데 여기에 할푼리가 붙으면 9자리 10자리가 됩니다. 

이 경우 정수 8자리에 소수 2자리 정도면 되지만, 어떤 경우에는 정수는 2자리면 족한데 소수가 5자리 필요한 경우도 있습니다. 이들 모두를 맞추려면 13자리 가지고선 부족하며 더 많은 자리수가 필요하게 됩니다.

이렇게 만들면 항상 다 쓰지도 않는 자리수 때문에 너무 많은 공간을 할애하게 되니, 소수를 다룰 때는 부동 소수점이라는 방식을 쓰게 됐습니다. 예를 들어 123456.789라는 숫자를 다룰 경우 이렇게 데이터를 저장합니다.
 
## 부동소수점 표현 방식

|분류|값|설명|
|---|---|---|
|**123456.789의 표시 방식**|||
|기존의 방식(고정 소수점 방식)   | 123456.789	         |정수 부분 6자리 + 소수 3자리   |
|부동 소수점 방식	            | 1.23456789 × 10 5	    |가수 부분 9자리 + 지수 1자리   |
|**12345678.9의 경우**|||
|고정 소수점 방식	            |12345678.9	            |정수 부분 8자리 + 소수 1자리   |
|부동 소수점 방식	            |1.23456789 × 10 8	    |가수 부분 9자리 + 지수 1자리   |
|**1.23456789의 경우**|||
|고정 소수점 방식	            |1.23456789	            |정수 부분 1자리 + 소수 8자리   |
|부동 소수점 방식	            |1.23456789 × 10 0	    |가수 부분 9자리 + 지수 1자리   |
 

고정 소수점 방식으로는 1.23456789 ~ 12345678.9까지의 모든 숫자를 처리하기 위해 정수 부분 8 자리 + 소수 8 자리가 필요합니다. 하지만 부동 소수점 방식에선 가수 부분(1.23456789를 저장하는 곳)이 9자리, 지수(10의 제곱을 저장하는 자리) 1자리니까 총 10자리입니다.

다루는 값의 범위가 엄격하게 정해져 있고, 이게 변하지 않는다면 고정 소수점 방식이 나쁘지 않습니다. 오히려 편하지요. 하지만 **어떤 값이 나올지 예상하지 못하는 경우가 많으며, 이 경우에는 부동 소수점이 더 작은 공간을 차지합니다.**

#### 숫자 표현은 반정밀도에서 8배정밀도까지
#### 기본이 되는 단 정밀도 부동 소수점 연산, 2진수를 10진수로 변환하면 오차가 생겨남
#### 정확도 향상의 댓가는 느린 연산 속도
단정밀도와 배정밀도를 비교하면 배정밀도가 2~4배 정도 느려집니다. 이건 처리해야 할 데이터의 양이 배로 늘어마면서, 덧셈은 2배, 곱셈은 4배가 느려졌기 때문입니다. 구체적으로 얼마가 느려지는지는 구현 방법에 따라 다릅니다. 예전의 x86처럼 64비트 연산에 32비트 연산기를 사용할 경우엔 64비트 곱셉이 32비트 곱셈을 4번 수행하고 여기에 32비트를 더해야 하니까 5배 이상 느려지기도 했습니다. 

**그래서 정확도는 적당한 수준이면 되니 빠른 연산이 필요한 경우에는 배정밀도가 맞지 않습니다. 이를 극단적으로 추구한 것이 3D그래픽과 Z 버퍼**, 머신 러닝에 쓰이는 CNN(Convolutional Neural Network)의 처리입니다.