---
layout: post
title: Operating system
---

## Operating system

운영체제(OS, operating System)는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스입니다. 한정된 메모리나 시스템 자원을 효율적으로 분배합니다.

* 참고로 운영체제와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것을 펌웨어(firmware)라고 합니다.

**운영체제의 역할은 크게 네 가지가 있습니다.**

1. CPU 스케줄링과 프로세스 관리, CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리합니다.
2. 메모리 관리, 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리합니다.
3. 디스크 파일 관리, 디스크 파일을 어떠한 방법으로 보관할지 관리합니다.
4. I/O 디바이스 관리, I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.

<details><summary>운영체제의 구조</summary>
<div markdown="1">

유저 프로그램이 맨 위에 있고 그 다음으로 GUI, 시스템콜, 커널, 드라이버가 있으며 가장 밑에 하드웨어가 있는 구조입니다.

* GUI, 시스템콜, 커널, 드라이버 부분이 바로 운영체제를 지칭합니다.
* 참고로 GUI가 없고 CUI만 있는 리눅스 서버도 있습니다.

<br>

<center><div markdown="1">

![운영체제의 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS3U2H%2FbtqHxbOhB2V%2FWeQANBQKfm6F58xkWsJZy0%2Fimg.png)

</div></center>

<br>

* GUI는 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태입니다. 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 해줍니다.
* 드라이버는 하드웨어를 제어하기 위한 소프트웨어입니다.
* CUI는 그래픽이 아닌 명령어로 처리하는 인터페이스 입니다.

</div></details>

<details><summary>커널</summary>
<div markdown="1">

컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행됩니다. 한편 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 합니다. 마찬가지로 운영체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야 합니다. 

하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할 것 입니다. 따라서 **운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 됩니다. 이 떄 메모리에 상주하는 운영체제의 부분을 커널이라고 합니다.** 또 이것을 좁은 의미의 운영체제라고 합니다.

즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻합니다. 이에 반에 넓은 의미의 운영체제는 커널뿐 아니라 각종 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념입니다.

</div></details>

<details><summary>시스템 콜</summary>
<div markdown="1">

**시스템콜이란 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 씁니다.** 유저 프로그램이 I/O 요청으로 트랩(trap)을 발동하면 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행됩니다.

예를 들어 I/O 요청인 fs.readFile()이라는 파일 시스템의 파일을 읽는 함수가 발동했다고 해봅시다.

<br>
<center><div markdown="1">

![운영체제](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJXwNG%2Fbtqw787Kgfe%2FvmrkitiEEjDI8G9w2mFzUk%2Fimg.png)

</div></center>
<br>

이때 유저 모드에서 파일을 읽지않고 커널 모드로 들어가 파일을 읽고 다시 유저 모드로 돌아가 그 뒤에 있는 유저 프로그램의 로직을 수행합니다. 이 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단 할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있습니다.

* I/O요청이란 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일
* 드라이버는 하드웨어를 제어하기 위한 소프트웨어

프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때 시스템콜이라는 인터페이스와 커널을 거쳐 운영체제에 전달됩니다.

이 시스템콜은 하나의 추상화 계층입니다. 그렇기 때문에 이를 통해 네트워크 통신이나 데이터베이스와 같은 낮은 단계의 영역 처리에 대한 부분을 많이 신경 쓰지 않고 프로그램을 구현할 수 있는 장점이 있습니다.

**modebit**

시스테콜이 작동될 때 modebit을 참고해서 유저 모드와 커널 모드를 구분합니다. modebit은 1또는 0의 값을 가지는 플래그 변수입니다. 카메라, 키보드 등 I/O 디바이스는 운영체제를 통해서만 작동해야 합니다. 

카메라를 켜는 프로그램이 있다고 해봅시다. 만약 유저 모드를 기반으로 카메라가 켜진다면, 사용자가 의도하지 않았는데 공격자가 카메라를 갑자기 켤 수 있는 등 나쁜 짓을 하기가 쉽습니다.

물론 커널 모드를 거쳐 운영체제를 통해 작동한다고 해도 100% 막을 수는 없지만 운영체제를 통해 작동하게 해야 막기가 쉽습니다. 이를 위한 장치가 바로 modebit입니다. modebit의 0은 커널 모드, 1은 유저 모드라고 설정되며, 유저 모드일 경우에는 시스템콜을 못하게 막아서 한정된 일만 가능하게 합니다.

앞의 그림처럼 유저 프로그램이 카메라를 이용하려고 할 때 시스템콜을 호출하고 modebit을 1에서 0으로 바꾸면 커널 모드로 변경한 후 카메라 자원을 이용한 로직을 수행합니다. 그 이후에 modebit을 0에서 1로 바꿔서 유저 모드로 변경하고 이후 로직을 수행합니다.

* 유저 모드는 유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하는 모드입니다.
* 커널 모드는 모든 컴퓨터 자원에 접근할 수 있는 모드입니다.
* 커널은 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역활을 합니다.

**시스템콜은 왜 필요할까?**

우리가 일반적으로 사용하는 프로그램은 `응용 프로그램`입니다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 때문에, 커널(kernel)의 도움을 반드시 받아야 합니다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행할 수 없습니다. 반드시 Kernel에 관련된 것은 커널모드로 전환한 후에야, 해당 작업을 수행할 권한이 생깁니다. 커널 모드를 통한 이러한 작업은 반드시 시스템콜을 통해 수행하도록 설계되어 있습니다. 아래 그림(1.13)을 살펴보면 이해가 빠를 것입니다.

그렇다면 권한은 왜 필요한 것일까? 의문이 생길 수 있습니다. 그 이유는 해커가 피해를 입히기 위해 악의적으로 시스템콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문입니다. 따라서 이러한 명령어들은 특별하게 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 유저 모드에서 시스템 콜을 호출할 경우에는 운영체제에서 불법적인 접근이라 여기고 trap을 발생시킵니다.

</div></details>


## 커널

<details><summary>커널 주소 공간의 내용</summary>
<div markdown="1">

**Code 영역**

* 시스템 콜, 인터럽트 처리 코드
* CPU, 메모리 등 자원 관리를 위한 코드
* 편리한 인터페이스 제공을 위한 코드

**Data 영역**

* PCB(Process Controll Block)은 현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조
* CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장

**Stack 영역**

* 각 Process(프로세스)의 커널 스택을 저장
    - 프로세스는 함수 호출시 자신의 복귀 조스를 저장하지만, 커널은 커널 내의 주소가 됩니다.
    - 각각의 프로세스마다 별도의 스택을 두어 관리합니다.

</div></details>

<details><summary>커널은 힙 메모리가 없는건가요?</summary>
<div markdown="1">

먼저 커널이 무엇인지 정확하게 짚고 넘어가야 합니다. 커널(kernel)은 Linux 운영 체제(OS)의 주요 구성 요소이며 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스입니다. 그리고 두 가지 관리 리소스에서 최대한 효과적으로 통신합니다

`커널 == 운영체제`가 아니라, 커널은 운영체제의 주요 구성 요소입니다. 리눅스로 예를 들어 설명하면, 커널은 메모리 관리, 프로세스 관리, 하드웨어와 프로세스 사이에서 인터프리터 역활을 수행하거나 시스템의 호출이나 보안등의 기능을 수행합니다 즉, 리눅스에서 (다른 OS는 다를 수 있습니다.) 커널은 하나의 프로세스가 아니라 컴퓨터 하드웨어와 프로세스를 잇는 인터페이스로 보아야 합니다.

커널은 힙메모리를 사용하지 않습니다. 커널은 운영체제(리눅스)에서 동 메모리 할당을 위해 필요한 기능들을 커널이 제공합니다. 운영체제는 커널에서 제공하는 기능을 사용해서 메모리 풀(memory pool)을 관리합니다.

</div></details>

## 시스템 호출(System Call)

시스템콜이란 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 씁니다.


<details><summary>시스템 콜의 예시</summary>
<div markdown="1">

```
cp in.txt out.txt
```

일반적으로 윈도우 운영체제라면 마우스가, 리눅스라면 키보드가 사용자로부터 입력을 받는데 이때 I/O 시스템콜을 사용합니다. 위와 같은 문장을 입력을 받아서 'cp'프로그램을 실행시키면 먼저 'in.txt'파일이 현재 디렉터리에서 접근할 수 있는 파일인지를 검사하기 위해 시스템 콜을 호출합니다.

만약 파일이 존재하지 않는다면 애러를 발생시켜야 하고, 프로그램을 종료하는데 이때 시스템콜이 사용됩니다.

만약 파일이 존재한다면, 복사한 파일을 저장하기 위해 'output.txt'파일명이 있는지 검사합니다. 그리고 이 때도 마찬가지로 이 파일 명이 존재하는지 존재하지 않는지 검사하기 위해 시스템 콜을 통해 확인합니다.

그리고 만약 파일 명이 이미 존재한다면, 덮어 씌워야 할지 아니면, 이어서 붙여야 하는지 User에게 물어볼 수 있습니다. 만약 저장하고자 하는 파일 이름이 겹치지 않다면, 파일을 저장해야 하는데 이 때도 시스템 콜을 이용합니다.

<br>
<center><div markdown="1">

![시스템콜](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAPjla%2Fbtqw7Qe9Ppa%2FFhpxhmnirEN1k63R6Qr3nk%2Fimg.png)

</div></center>
<br>

텍스트를 복사하는 간단한 프로그램임에도 불구하고, 상당히 많은 시스템 콜이 발생함을 알 수 있습니다.

</div></details>

<details><summary>시스템 콜의 종류</summary>
<div markdown="1">

아래는 UNIT의 시스템콜의 종류입니다.

* 프로세스 컨트롤
    * 프로세스 생성 및 종료
    * 메모리에 로드, 실행
    * 프로세스 속성 값 확인, 지정
    * wait 이벤트, signal 이벤트
    * 메모리 할당

* 파일 메니지먼트
    * 파일 생성, 파일 삭제
    * 열기, 닫기
    * 읽기, 쓰기, Reposition
    * 파일 속성 값 확인, 지정

* 디바이스 매니지먼트
    * 디바이스 요청 및 해제
    * 읽기, 쓰기, Reposition
    * 디바이스 속성 확인, 지정
    * 비 물리적인 디바이스 해제 및 장착

* 정보 관리
    * 시간 확인, 시간 지정
    * 시스템 데이터 확인, 지정
    * 프로세스, 파일, 디바이스 속성 가져오기
    * 프로세스, 파일, 디바이스 속성 설정하기

* 커뮤니케이션
    * 커뮤니케이션 연결 생성 및 삭제
    * 메시지 송신, 수신
    * 상태 정보 전달
    * remote 디바이스 해제 및 장착

* 보안
    * Permission 흭득
    * Permission 설정

</div></details>

## CPU 구조

CPU(Central Processing Unit)는 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치를 말하며, 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행합니다.

운영체제의 커널이 프로그램을 메모리에 올려 프로세스로 만들면 일꾼인 CPU가 이를 처리합니다.

* CPU는 명령어를 해석, 연산, 그 결과를 저장하는 등의 수행을 하는 유닛을 말합니다.

![CPU 이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F380Mt%2Fbtq49R5Ol13%2FE6ue4DRtUgJYJJuykkSSPK%2Fimg.png)

* 제어장치(CU, Control Unit)는 프로세스 조작을 지시하는 CPU의 한 부품입니다. 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.
* 레지스터는 CPU안에 있는 매우 빠른 임시기억장치를 가리킵니다. CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠릅니다. CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달합니다.
* 산술논리연산장치(ALU, Arithmetic Logic Unit)는 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로입니다.

<details><summary>코어란?</summary>
<div markdown="1">

코어는 CPU 역활을 수행하는 블록이며 블록이란 것으 물리적인 단위를 뜻합니다. 한 개의 CPU 칩 안에 한개의 코어를 가지는 것을 일반적으로 알고 있는 싱글코어라 불리며, 한 개의 CPU 칩 안에 복수개의 코어를 가지는 것을 멀티코어라 하며 코어 개수에 따라 접두사(prefix)가 달라집니다.

</div></details>

<details><summary>코어의 요소</summary>
<div markdown="1">

**제어 장치(CU, Control Unit)**

제어 장치는 메모리에서 명령을 가져와 명령어 해독과 해독된 명령어 실행을 지시하는 핵심 장치입니다.

제어장치(CU, Control Unit)는 프로세스 조작을 지시하는 CPU의 한 부품입니다. 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.

**연산 장치(산술논리연산장치, ALU, Arithmethic Login Unit)**

제어 장치의 지시를 받아 산술, 논리, 비트 연산등의 실제 연산을 수행하는 장치입니다.

산술논리연산장치(ALU, Arithmetic Logic Unit)는 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 베타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로입니다.

**기억장치 (Register)**

제어, 연산 장치 등에서 사용하는 임시 기억 장치의 역활을 수행한다. 종류는 다음과 같습니다.

레지스터는 CPU안에 있는 매우 빠른 임시기억장치를 가리킵니다. CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠릅니다. CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달합니다.

* PC(Program Counter)는 다음 인출(Fetch)될 명령어의 주소를 가지고 있는 레지스터입니다.
* AC(Accumulator)는 연산 결과 데이터를 일시적으로 저장하는 레지스터입니다.
* IR(Instruction Register)는 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터입니다.
* SR(Status Register)는 현재 CPU의 상태를 가지고 있는 레지스터입니다.
* MAR(Memory Address Register)는 PC에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터입니다.
* MBR(Memory Buffer Register)는 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터입니다.

</div></details>

<details><summary>인터럽트</summary>
<div markdown="1">

인터럽트는 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말합니다. 키보드, 마우스 등 IO디바이스로 인한 인터럽트, 0으로 숫자를 나누는 산술 연산에서의 인터럽트, 프로세스 오류 등으로 발생합니다.

인터럽트가 발생되면 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행됩니다.

인터럽트 간에는 우선순위가 있고 우선순위에 따라 실행되며 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트 두 가지로 나뉩니다.

* 인터럽트 핸들러 함수
    - 인터럽트가 발생했을 때 이를 핸들링하기 위한 함수, 커널 내부의 IRQ를 통해 호출되며 request_irq()를 통해 인터럽트 핸들러 함수를 등록할 수 있습니다.

**하드웨어 인터럽트**

하드웨어 인터럽트는 키보드를 연결한다거나 마우스를 연결하는 일 등의 IO디바이스에서 발생하는 인터럽트를 말합니다.

이때 인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행합니다.

**소프트웨어 인터럽트**

소프트웨어 인터럽트는 트랩(trap)이라고도 합니다. 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동합니다.

</div></details>

<details><summary>캐시 메모리란?</summary>
<div markdown="1">

코어 내 레지스터는 메인 메모리(RAM)에서 데이터를 읽어 올 수 있지만 메인 메모리는 레지스터 보다 상대적으로 속도가 느리기 때문에 병목현상이 발생할 수 있습니다. 이 속도 차이를 극복하기 위해 사용되는 것이 캐시 메모리입니다.

캐시 메모리 또한 종류가 나뉘는데 L1 Cache는 코어 간 독립적으로 가지며 코어 내 레지스터로 부터 읽히고 쓰이는데 사용됩니다. 그리고 L2 Cache는 L1 Cache간 공유되어 읽히고 쓰이는데 사용됩니다. L3 Cache역시 L2 Cache들로부터 읽히고 쓰이는데 사용됩니다.

* 코어내 레지스터와 메인 메모리간 속도 차이를 극복하고자 중간에 캐시 메모리를 두는 것 입니다.

![코어와 메인 메모리의 중간 메모리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmlFSV%2Fbtq44O3jOiZ%2F4f1Arc048UHdYBjQhJnvQ0%2Fimg.png)

</div></details>

<details><summary>DMA 컨트롤러</summary>
<div markdown="1">

DMA 컨트롤러는 I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치를 뜻합니다. CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며 CPU의 일을 부담하는 보조 일꾼이라고 보면 됩니다. 또한, 하나의 작업을 CPU와 DMA컨트롤러가 동시에 하는 것을 방지합니다.

</div></details>

<details><summary>메모리</summary>
<div markdown="1">

메모리(memory)는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치를 말하며, 보통 RAM(Random Access Memory)을 일컬어 메모리라고도 합니다. CPU는 계산을 담당하고, 메모리는 기억을 담당합니다.

> 공장에 비유하자면 CPU는 일꾼이고, 메모리는 작업장이며, 작업장으 크기가 곧 메모리의 크기입니다. 작업장이 클수록 창고에서 물건을 많이 가져다놓고 많은 일을 할 수 있듯이 메모리가 크면 클수록 많은 일을 동시에 할 수 있습니다.

</div></details>

<details><summary>타이머</summary>
<div markdown="1">

타이머(timer)는 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역활을 합니다. 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재합니다.

</div></details>

<details><summary>디바이스 컨트롤러</summary>
<div markdown="1">

디바이스 컨트롤러(device controller)는 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU를 말합니다.

</div></details>

<details><summary>클럭 (Clock)</summary>
<div markdown="1">

클럭이라는 수치는 CPU 내부에서 일정한 주파수를 가지는 신호로, 이 신호에 동기화되어 CPU의 모든 명령어가 동작하게 됩니다. 클럭 수가 2.0GHZ라면 초당 20억 번의 명령어를 처리할 수 있다는 의미입니다.

</div></details>

## 메모리 (memory)

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있습니다.

<center><div markdown="1">

![Computer Memory Hiearachy](https://velog.velcdn.com/images/yu-jin-song/post/76e33966-4b59-4f77-9887-f2f332ec072b/pngwing.com.png)

</div></center>

* 레지스터는 CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적습니다.
* 캐시는 L1, L2캐스를 지칭합니다. 휘발성, 속도 빠름, 기억 용량이 적습니다. 참고로 L3 캐시도 있습니다.
* 주기억장치는 RAM을 가리킵니다. 휘발성, 속도 보통, 기억 용량이 보통입니다.
* 보조기억장치는 HDD, SDD를 일컬으며 휘발성, 속도 낮음, 기억 용량이 많습니다.

램(RAM)은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달하는 역활을 합니다. 계층 위로 올라갈수록 가격은 비싸지는데 용량은 작아지고 속도는 빨라지는 특징이 있습니다.

<details><summary>캐시</summary>
<div markdown="1">

캐시(cache)는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말합니다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있습니다.

실제로 메모리와 CPU사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결합니다. 이렇게 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 합니다. 예를 들어 캐시 메모리와 보조기억장치 사이에 있는 주기억장치를 보조기억장치의 캐싱계층이라고 할 수 있습니다.

**지역성의 원리**

자주 사용하는 데이터에 대한 근거가 되는 것은 지역성입니다. 지역성은 시간 지역성(temporal locality)과 공간 지역성(spatial locality)로 나눠집니다.

**시간 지역성**

시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성을 말합니다.

**공간 지역성**

공간 지역성은 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말합니다.

</div></details>

<details><summary>캐시히트와 캐시미스</summary>
<div markdown="1">

캐시에서 원하는 데이터를 찾았다면 캐시히트라고 하며, 해당 데이터가 캐시에 업다면 주 메모리로 가서 데이터를 찾아오는 것을 캐시미스라고 합니다.

캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 됩니다. 캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠릅니다. 반면에 캐시미스가 발생되면 메모리에서 가져오게 되는데, 이는 시스템 버스를 기반으로 작동하기 때문에 느립니다.

**캐시매핑**

캐시매핑이란 캐시가 히트되기 위해 매핑하는 방법을 말하며 CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때는 기반으로 설명합니다. 레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역활을 잘 해주려면 이 매핑을 어떻게 하느냐가 중요합니다.

|이름|설명|
|:-:|---|
|직접 매핑(directed mapping)|메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20... 이런 식으로 매핑하는 것을 말합니다. 처리가 빠르지만 충돌 발생이 잦습니다.|
|연관 매핑(associative mapping)|순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑합니다. 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느립니다.|
|집합 연관 매핑(set associative mapping)|직접 매핑과 연관 매핑을 합쳐 놓은 것입니다. 순서는 일치시키만 집합을 둬서 저장하며 블록화되어 있기 때문에 검색은 좀 더 효율적입니다. 예를 들어 메모리가 1~100이 있고 캐시가 1~10이 있다면 캐시 1~50의 데이터를 무작위로 저장하는 것을 말합니다.|


</div></details>

<details><summary>메모리 관리</summary>
<div markdown="1">

운영체제의 대표적인 할 일 중 하나가 메모리 관리입니다. 컴퓨터 내의 한정된 메모리를 극한으로 활용해야 하는 것입니다.

가상 메모리(virtual memory)는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말합니다.

이때 가상적으로 주어진 주소를 가상 주소(logical address)라고 하며, 실제 메모리상에 있는 주소를 실제 주소(physical address)라고 합니다. 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요 없이 프로그램으 구축할 수 있게 됩니다.

* TLB는 메모리와 CPU사이에 있는 주소 변환을 위한 캐시입니다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층입니다.

</div></details>

<details><summary>스와핑</summary>
<div markdown="1">

만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생합니다. 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것을 스와핑(swapping)이라고 합니다.

</div></details>

<details><summary>페이지 폴트</summary>
<div markdown="1">

페이지 폴트(page fault)란 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생합니다. 이때 운영체제는 다음 과정으로 해당 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 거서럼 츠로그램이 작동하게 해줍니다.

페이지 폴트와 그로 인한 스와핑은 다음 과정으로 이루어집니다.

1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체젱 알립니다.
2. 운영체제는 CPU의 동작을 멈춥니다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾습니다. 물리 메모리에도 없다면 스와핑이 발동됩니다.
4. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화합니다.
5. 중단되었던 CPU를 다시 시작합니다.

* 페이지(page)는 가상 메모리를 사용하는 최소 크기 단위입니다.
* 프레임(frame)은 실제 메모리를 사용하는 최소 크기 단위입니다.

</div></details>

<details><summary>스레싱</summary>
<div markdown="1">

스레싱(thrashing)은 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능저하를 초래합니다.

스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나느 것입니다. 페이지 폴트가 일어나면 CPU 이용률이 낮아집니다.

</div></details>

<details><summary>작업 세트(working set)</summary>
<div markdown="1">

작업 세트(working set)는 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것입니다. 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있습니다.

</div></details>

<details><summary>PFF(Page Fault Frequency)</summary>
<div markdown="1">

PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법입니다. 만약 상한선에 도달한다면 페이지를 늘리고 하한선에 도달한다면 페이지를 줄이는 것입니다.

</div></details>