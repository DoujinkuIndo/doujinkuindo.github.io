---
layout: post
title: Data struct
---

## 자료구조

![자료구조](https://velog.velcdn.com/images%2Fmar_f%2Fpost%2F5a1591f9-b2a6-4ee9-a710-f18ef102a891%2Fimage-20210117185326497.png)

![자료구자](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FefLNM6%2FbtrgVOqM1ww%2Fq9Y1KFRs7y81CHkXtK1vy1%2Fimg.jpg)

## 자료구조 List(리스트)

순열(Sequence)이라고도 불리며, 순서를 가지고 일렬로 나열한 원소들의 모임으로 정의합니다. 순서가 있다는 점에서 집합과는 구별되며, 갈림길 없이 일렬로 나열되어 처음과 끝이 각각 하나씩만 있다는 점에서 그래프와도 구별됩니다.

* 리스트는 가장 빈번하게 사용되는 자료구조 중 하나입니다. 다량의 데이터를 다루는데 가장 단순한 방법이기 때문입니다.
* 기보적인 자료구조이다 보니 프로그래밍 언어들에 내장되어 있는 경우가 많습니다.

자료구조 List는 구현 방법에 따라 순차(Sequential) 자료구조와 연결(Linked)자료구조입니다.

<details><summary>순차 리스트</summary>
<div markdown="1">

**순차 자료구조**는 구현할 자료들을 논리적인 순서대로 메모리에 연속하여 저장하는 자료구조입니다. 데이터가 컴퓨터 메모리에 저장될 때, 저장 시작 위치부터 빈자리 없이 순서대로 저장된다는 뜻입니다. 자료의 논리적인 순서와 물리적인 순서가 일치하는 구현 방식이라고 할 수 있습니다.

![순차 자료구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8GlEl%2FbtquuJp5dJr%2FaN5jFc2e4DMBkKuxjelzvK%2Fimg.png)

리스트의 각 원소에 순서대로 번호를 붙일 수도 있으며, 이 번호를 사용해서 임의의 원소를 찾을 수 있는 연산을 추가할 수 있습니다. 때문에 배열을 리스트의 일종으로 볼 수도 있습니다.

</div></details>

<details><summary>연결 리스트</summary>
<div markdown="1">

**연결 자료구조**는 메모리에 저장된 물리적 위치나 순서와 상관없이, 링크에 의해 논리적인 순서를 표현하는 자료구조입니다. 연속적인 메모리에 저장되는 방식이 아니라 노드라는 각각의 독립된 공간을 사용해 데이터를 담습니다.

노드는 실제 데이터가 저장되는 공간인 데이터 필드와 다음 노드의 주소 값을 가진 링크 필드로 이루어져 있습니다.

![연결 자료구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fl0VVL%2FbtquxsmG8P6%2Fnxm8KVIBfzq4LttQHf2CvK%2Fimg.png)

</div></details>

<details><summary>순차 리스트 vs 연결 리스트</summary>
<div markdown="1">

순차 리스트와 연결 리스트의 차이점은 **데이터를 삽입, 삭제 그리고 탐색하는 과정에서 뚜렷한 차이**를 보입니다.

|행동|순차 리스트|연결 리스트|
|:-:|---|---|
|삽입|순차 리스트는 데이터를 삽입하거나 삭제하고 나면, 연속적인 물리적 위치를 유지하기 위해 원소를 옮기는 추가 작업을 해야합니다. <br> 따라서 삽입이나 삭제 연산이 많다면 그만큼 시간이 듭니다.|연결 리스트는 특정 노드를 삽입하거나 삭제할 때 노드의 링크 필드(다음 노드 주소)만 수정하면 되므로 순차 리스트에 비해 연산 속도가 빠른 것 입니다.|
|탐색|순차 리스트는 배열로 구현하기 때문에 인덱스를 통해 원소를 탐색할 수 있습니다.|연결 리스트는 이전 노드를 통해서만 다음 노드를 참조할 수 있다는 특성 때문에 리스트의 처음부터 다음 노드들을 탐색해야 합니다.| 

**리스트의 삭제 비교**

![순차 리스트 삭제 과정](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbt74ET%2FbtquxtzaHoM%2FpKvHb5t9yjfLvCTwLui6X0%2Fimg.png)

순차 리스트는 데이터를 삽입하거나 삭제하고 나면, 연속적인 물리적 위치를 유지하기 위해 원소를 옮기는 추가 작업을 해야 합니다.

따라서 삽입이나 삭제 연산이 많다면 그만큼 시간이 듭니다.

![연결 리스트 삭제 과정](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtgjK2%2FbtquwnzGio1%2FlkhBaPupRpXiYx4lO6e0c1%2Fimg.png)

연결 리스트는 특정 노드를 삽입하거나 삭제할 때 노드의 링크 필드만 수정하면 되므로 순차 리스트에 비해 연산 속도가 빠릅니다.

두 그림을 비교해 보면 순차 리스트는 데이터의 삭제 작업이 이루어진 뒤 원래 데이터가 담겨있던 주소에 변화가 생겼지만, 연결 리스트는 주소가 변경된 노드가 없습니다.

연결 리스트가 추가, 삭제에서 더 효율적입니다.

**리스트의 탐색 비교**

순차 리스트는 배열로 구현하기 때문에 인덱스를 통해 원소를 탐색할 수 있습니다..

<details><summary>배열</summary>
<div markdown="1">

배열은 다수의 데이터를 그룹핑해서 효율적으로 관리할 수 있는 자료구조입니다. 

배열의 가장 큰 특징은 인덱스가 있다는 것입니다. 만약 인덱스를 알고 있다면 인덱스를 이용해서 데이터를 가져올 수 있습니다.

인덱스를 이용한 데이터의 조회는 매우 빠르게 처리됩니다. 하지만 인덱스를 이용해서 데이터를 가져오려면 데이터에 대한 인덱스의 값이 고정되어야 합니다. 

자연스럽게 어떤 엘리먼트가 삭제되면 삭제된 상태를 빈 공간으로 남겨둬야 합니다. 이것은 메모리의 낭비를 초래합니다. 

또한 배열에 데이터가 있는지 없는지를 체크하는 로직이 필요하다는 의미이기도 합니다.

</div></details>

연결 리스트는 이전 노드를 통해서만 다음 노드를 참조할 수 있다는 특성이 있습니다.

</div></details>

<details><summary>보통 리스트가 가지고 있는 연산</summary>
<div markdown="1">

* 빈 리스트를 만드는 연산 (Constructor; 생성자)
* 리스트가 비어있는지 확인하는 연산
* 리스트의 앞에 원소를 삽입하는 연산
* 리스트의 뒤에 원소를 삽입하는 연산
* 리스트의 제일 첫 원소를 알아보는 연산
* 리스트의 첫 원소를 제외한 나머지 리스트를 알아보는 연산

</div></details>

## 연결 리스트

연결 리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조입니다. 삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸립니다.

<center><div markdown="1">

![이중 연결 리스트](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fba3zRZ%2Fbtq2Mz8CDoL%2FwNmI6SzXTZhPko7X7zBALK%2Fimg.png)

</div></center>

앞의 그림처럼 prev 포인터와 next 포인터로 앞과 뒤의 노드를 연결시킨 것이 연결 리스트이며, 연결 리스트는 싱글 연결 리스트, 이중 연결 리스트, 원형 이중 연결 리스트가 있습니다. 참고로 맨 앞에 있는 노드를 헤드(head)라고 합니다.

* 싱글 연결 리스트는 next 포인터만 가집니다.
* 이중 연결 리스트는 next 포인터와 prev 포인터를 가집니다.
* 원형 이중 연결 리스트는 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말합니다.

## 배열(array)

배열(array)는 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합입니다. 또한, 중복을 허용하고 순서가 있습니다.

여기서 설명하는 배열은 '정적 배열'을 기반으로 설명합니다. 탐색에 O(1)이 되어 랜덤 접근(random access)이 가능합니다.

삽입과 삭제에는 O(n)이 걸립니다. 따라서 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것은 배열로 하는 것이 좋습니다.

배열은 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용합니다.

<details><summary>랜덤 접근과 순차적 접근</summary>
<div markdown="1">

직접 접근이라고 하는 랜덤 접근은 동일한 시간에 배열과 같은 수차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다. 이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대입니다.

</div></details>

<details><summary>배열과 연결 리스트 비교</summary>
<div markdown="1">

배열은 상자를 순서대로 나열한 데이터 구조이며 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있습니다.

연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다는 점이 다릅니다.

유추할 수 있듯이 탐색은 배열이 빠르고 연결 리스트는 느립니다. 배열의 경우 그저 상자위에 있는 요소를 탐색하면 되는 반면에, 연결 리스트는 상자를 열어야 하고 주어진 선을 기반으로 순차적으로 열어야 합니다.

하지만 데이터 추가 및 삭제는 연결 리스트가 더 빠르고 배열은 느립니다. 배열은 모든 상자를 앞으로 옮겨야 추가가 가능하지만, 연결 리스트는 선을 바꿔서 연결해주기만 하면 됩니다.

</div></details>

## 벡터(vector)

벡터(vector)는 동적으로 요소를 할당할 수 있는 동적 배열입니다. 컴파일 시점에 개수를 모른다면 벡터를 써야 합니다. 또한 중복을 허용하고 순서가 있고 랜덤 접근이 가능합니다. 탐색과 맨 뒤의 요소를 삭제하거나 삽입하는데 O(1)이 걸리며, 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는데 O(n)의 시간이 걸립니다.

<center><div markdown="1">

![벡터의 크기증가](https://modoocode.com/img/2124A44B595A137D239739.webp)

</div></center>

참고로 뒤에서부터 삽입하는 push_back()의 경우 O(1)의 시간이 걸리는데, 벡터의 크기가 증가되는 시간 복잡도가 amoritized 복잡도, 즉 상수 시간 복잡도 O(1)과 유사한 시간 복잡도를 가지기 때문입니다.

push_back()을 한다고 해서 매번 크기가 증가하는 것이 아니라 2의 제곱승 +1 마다 크기를 2배로 늘리는 것을 알 수 있습니다.

## 자료구조 맵(Map)

맵(map)은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조입니다.

* 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬됩니다.

<details><summary>Map 자료구조는 왜 이용하는가?</summary>
<div markdown="1">

List형태의 자료구조들은 순서대로 값을 차곡차곡 집어넣는 일련의 하나의 줄과 같은 형태입니다. 반면 Map 형태의 자료구조는 각각의 Key와 매칭 되는 Value들이 존재합니다. 즉 순서보다는 정의된 이름(Key)와 상응하는 데이터들을 묶기 위한 자료 구조로서 효과적입니다.

</div></details>

<details><summary>Map 자료구조의 대표적인 종류</summary>
<div markdown="1">

Map의 개념을 이용하여 사용하는 대표적인 자료구조는 크게 3가지 정도 있습니다.

* HashMap
    * Key와 Value의 쌍으로만 구성이 될 뿐 자료구조 안에 묶인 쌍들에 대한 순서는 보장할 수 없습니다.
    * 즉, 사용자는 키와 값이 구성되는 위치를 결정 하거나 알 수 없습니다.
* TreeMap
    * Key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조입니다.
    * Key값을 통한 탐색 뿐 아니라 Key값의 정렬을 통한 탐색 등을 하기에 용의합니다.
* LinkedHashMap
    * 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조입니다.
    * 배열, 리스트처럼 인덱싱 접근을 하기에 용의합니다.

</div></details>