---
title: 2019-01-24 2.14 Android组件、模块化与架构
permalink: /android/architecture/
last_modified_at: 2019-01-24T09:45:06-05:00
tags:
  - 架构 Android组件 Android模块化
categories:
  - 架构
---

### 2.14.1 MVC & MVP & MVVM
1. MVC
  - Controller - 转发请求, 处理请求, 控制View & Model, Android上对应`Activity`, 处理数据、业务和UI
  - View - 展示 & 交互, Android上对应XML布局文件
  - Model - 程序功能（算法等）、数据（数据库相关）, Android上对应实体模型(数据获取、存储、数据状态变化)
  - 优点
    - 简化程序修改和扩展
    - 提高复用
    - 重用行高
  - 缺点
    - 定义/规范不明确
    - iOS Controller 类容易过大, 容易混淆View和Controller

![MVC架构](http://vencial.com/assets/images/MVC架构图.png)

2. MVP
  - Presenter - 事件处理, 检索Model数据, 与View沟通, Model & View桥梁, Android上对应对应View和Model间的交互和业务逻辑
  - View - 展示, Passive View, Android上对应`Activity`和XML, 负责绘制和用户交互
  - Model - 业务逻辑 & 数据模型, Android上对应实体模型
  - 优点
    - 简化程序修改和扩展
    - 提高复用
    - View & Model 完全分离, View更加松散
    - 容易单元测试, 因为和View的交互以接口形式
  - 缺点
    - Presenter容易臃肿

![MVP架构](http://vencial.com/assets/images/MVP架构图.png)

3. MVVM
  - ViewModel 显示数据 & 处理用户交互, Android上对应完成View和Model间的交互, 负责业务逻辑
  - View - 展示, Android上对应`Activity`和XML
  - Model - 存储内容, Android上对应实体模型
  - Binder - 声明性数据和命令绑定

![MVVM架构](http://vencial.com/assets/images/MVVM架构图.png)  

### 2.14.2 设计原则

| 原则 | 基本概念 | 解决问题 | 基本实现 |
| -- | -- | -- | -- |
| 开闭原则(OCP) | 对扩展开放, 对修改关闭| 实现热拔插, 解耦 |接口抽象|
| 里氏替换原则(LSP) | 子类是父类的具体抽象, 抽象可代表父类（Is-A））, 子类可以扩展父类的功能, 但不能改变父类原有的功能 | 解释抽象化的原则 | 继承, 抽象 |
| 依赖倒转原则(DIP) | 面向接口编程, 不面向实现编程 | 易于扩展 | 接口编程时类型使用基类, 而不使用具体实现的子类 |
| 单一职责原则(SRP) | 一个类应该有且仅有一个引起它变化的原因, 否则类应该拆分 | 降低类复杂度, 提高类可读性, 提高系统可维护性, 变更引起的风险降低 | 拆分类 |
| 接口隔离原则(ISP) | 使用多个隔离接口, 使用单个接口要好 | 降低耦合 | 封装接口的时候, 尽量用不同接口解决不同问题, 尽量不要合用一个接口 |
| 迪米特法则(LoD) | 一个对象对其它对象保持最少的了解 | 降低耦合 | 写一个系统架构, 或模块的时候, 尽量少的对外依赖 |
| 合成复用原则(CRP) | 优先使用合成/聚合, 而非继承 | 可以通过引入抽象类更加灵活, 相互耦合变小, 更加简单 | 尽量将已有对象纳入到新对象中, 成为新对象的一部分, 而不使用继承的方式进行复用, 如`ClassLoader`中双亲委派架构 |


### 2.14.3 设计模式

- 创建型模式 (Singleton, Prototype, FactoryMethod, AbstractFactory, Builder)
  1. 工厂模式
  2. 单例模式(饿汉、懒汉等)

```java
// 懒汉/懒加载..
// 性能高（无锁）, 线程安全, JVM ClassLoader保证安全的模型
public class Sample {
  private static class LazyHolder {
    private static final Sample INSTANCE = new Sample();
  }

  public static Sample getInstance() {
    return LazyHolder.INSTANCE;
  }
}
```

  3. 建造者模式

  `构建复杂/混合类型对象`

  4. 原型模式(适用于)
  提供拷贝方法

  浅拷贝
  `Object#clone`只拷贝基本数据类型

  深拷贝

    1. 实现`Serializable`序列化
    2. `Object#clone`逐个变量深拷贝

- 结构型模式 (Proxy, Adapter, Bridge, Decorator, Facade, FlyWeight, Composite)
  5. 适配器模式
  解决两个接口/类不兼容问题

  - 类适配器(对象适配器)
  `class A`和`class B`接口"不兼容", 使用`Adapter`可以访问A类和B类的方法

  ![Adapter类图](http://vencial.com/assets/images/Adapter类图.png)  

  - 接口适配器

  解决不想实现所有接口...

  ![interface_Adapter类图](http://vencial.com/assets/images/interface_Adapter类图.png)  

  6. 装饰模式

  需要在`class A`的`doA`增加功能..参考`InputStream`的设计, 缺点是一直叠加功能, 使用很恶心..

  ```java
  A a = new A();
  Decorator decorator = new Decorator(a);
  decorator.doA();

  ```

  ![装饰模式类图](http://vencial.com/assets/images/装饰模式类图.png)  

  7.代理模式(中介作用和保护目标对象, 代理对象可以扩展目标对象, 降低系统耦合度)

  对`AImpl(RealSubject)`进行访问权限控制...

  ![Proxy模式类图](http://vencial.com/assets/images/Proxy模式类图.png)  

  8. 外观(Facade)模式

  优点降低耦合度, 缺点是不符合开不原则, 修改麻烦

  ![外观模式类图](http://vencial.com/assets/images/外观模式类图.png)  

  9. 桥接模式

  ![桥接模式类图](http://vencial.com/assets/images/桥接模式类图.png)  

  10. 享元模式

  实现内存共享, 减少内存的使用..

  ![享元模式类图](http://vencial.com/assets/images/享元模式类图.png)

  11. 组合模式

  图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
  ![组合模式类图, 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif)

- 行为模式 (Template Method, Strategy, Command, Chain of Responsibility, State, Observer, Mediator, Iterator, Visitor, Memento, Interpreter)

  12. 策略模式

  灵活替换不同策略, 即实现（算法）; 满足开闭原则

  ![策略者模式类图](http://vencial.com/assets/images/策略者模式类图.png)

  13. 观察者模式

  订阅对象操作/状态, 发生变化时, 可以收到通知.

  图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
  ![观察者模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161A6221S.gif)

  14. 模板方法模式

  定义: 定义算法/操作的骨架; 满足开闭原则
  优点: 1). 封装不变部分, 扩展可变部分; 2). 提供公共部分代码, 便于代码复用; 3). 部分方法由子类实现, 子类可扩展增加相应功能, 符合开闭原则

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![模板方法模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q116095405308.gif)

  15. 命令模式

  定义: 请求封装为一个对象, 使发出请求的责任和执行请求的责任分割开; 满足开闭原则
  优点: 1). 降低系统的耦合度; 2). 增加命令或删除命令非常方便

  图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
  ![命令模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q11611335E44.gif)

  16. 职责链模式

    定义: 避免请求发送者与多个请求处理者耦合, 将所有请求的处理者连成链, 并传递; 满足开闭原则, 单一职责原则
    优点: 1). 降低对象的耦合度; 2). 增强系统的可扩展性; 3). 增强了给对象指派职责的灵活性; 4). 职责链简化对象之间的连接; 5). 责任分担

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![职责链模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q116135Z11C.gif)

  17. 状态模式

    定义: 对有状态的对象, 把复杂的"判断逻辑"提取到不同的状态对象中, 允许状态对象在其内部状态发生变化时改变其行为; 满足单一职责原则
    优点: 1). 状态模式将与特定状态相关的行为局部化到一个状态, 将不同状态的行为分割开, 满足"单一职责原则"; 2). 减少对象间的依赖; 3). 有利于程序的扩展

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![状态模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q11615412U55.gif)

  18. 中介者模式

    定义: 定义一个中介对象来封装一系列对象之间的交互, 使原有对象之间的耦合松散, 迪米特法则的典型应用
    优点: 1). 降低对象之间的耦合度, 使对象易于独立被复用; 2). 将对象间的一对多关联转变为一对一的关联, 提高系统的灵活性

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![中介者模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161I532V0.gif)

  19. 迭代器模式

    定义: 提供一个对象来顺序访问聚合对象中的一系列数据, 而不暴露聚合对象的内部表示; 满足单一职责原则和开闭原则
    优点: 1). 访问聚合对象的内容无需暴露它的内部细节; 2). 遍历任务交由迭代器完成, 简化聚合类; 3). 它支持以不同方式遍历一个集合; 4). 增加新的聚合类和迭代器类比较方便; 5). 封装性良好

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![迭代器模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161PU9528.gif)

  20. 访问者模式

    定义: 将作用于某个数据结构中的各个元素的操作分离出来封装成独立的类, 使其在不改变数据结构的前提下可以添加作用于这些元素的新操作, 为数据结构中的每个元素提供多种访问方式
    优点: 1). 扩展性好; 2). 复用性好; 3). 灵活性好

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![访问者模式 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181119/3-1Q11910135Y25.gif)

  21. 备忘录模式

    定义: 在不破坏封装性的情况下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 以便以后当需要时能将对象恢复到原先保存的状态, 满足单一职责原则
    优点: 1). 提供一种可恢复状态的机制; 2). 实现了内部状态的封装; 3). 简化发起方

    图片来源于[设计模式](http://c.biancheng.net/view/1373.html)
    ![备忘录模式类图 图片来源于设计模式](http://c.biancheng.net/uploads/allimg/181119/3-1Q119130413927.gif)

  22. 解释器模式

    定义: 给分析对象定义一个语言, 并定义该语言的文法表示, 再设计一个解析器解析语言的句子
    优点: 1). 扩展性好, 2). 容易实现

  ![解释器模式类图 图片来源于涉及模式](http://c.biancheng.net/uploads/allimg/181119/3-1Q119150Q6401.gif)

### 2.14.4 封装、继承、多态
- 封装
  - 隐藏对象属性和细节, 仅对外公开接口, 控制在程序中属性的读、修改的访问
  - 目的: 增强安全性和简化编程, 使用者不需要关心具体细节

- 继承
  - 当有多个具有相同特征的属性或行为时, 即可以将相同的部分抽到父类, 子类继承
  - 目的: 代码复用

- 多态
  - 调用相同方法, 子类通过方法重写或成员覆盖, 表现行为不同
  - 目的: 程序的扩展性和可维护性增强

### 参考
- [java 面向对象三大特性（封装，继承，多态）以及抽象、接口的介绍](https://blog.csdn.net/qq_22118507/article/details/51422591)
- [Advantage and Disadvantage of ASP.NET MVC](https://www.c-sharpcorner.com/blogs/advantage-and-disadvantage-of-asp-net-mvc1)
- [设计模式](http://c.biancheng.net/view/1373.html)
