I"AC<p><em>第一份 Android 学习文档</em></p>

<h2 id="step1">Step1</h2>

<blockquote>
  <p>参考：<a href="https://developer.android.google.cn/training/basics/firstapp/creating-project">创建 Android 项目</a></p>
</blockquote>

<p>根据实验要求创建安卓新项目，参数：API23；Android6.0；Empty Activity。</p>

<h3 id="开发基础">开发基础</h3>

<p><code>Android</code> 开发的四大组件为：</p>
<ul>
  <li><code>Activity</code> ：用于表现功能</li>
  <li><code>Service</code> ：后台运行的服务</li>
  <li><code>Broadcast Receiver</code>：用于接收广播</li>
  <li><code>Content Provider</code> ：等同于数据库
<a href="https://blog.csdn.net/xchaha/article/details/80398620">参考</a></li>
</ul>

<h4 id="activity">Activity</h4>

<ul>
  <li>定义：用户操作的可视化界面，提供一个完成操作指令的窗口。当创建完毕 <code>Activity</code> 之后，需要调用 <code>setContentView()</code> 方法来完成界面的显示。</li>
  <li>依赖：需要在 <code>AndroidManifest.xml</code> <code>配置相关信息，否则系统将不识别也不执行该Activity</code> 。在 <code>android stdio</code> 会自动生成。</li>
  <li>通信： <code>Activity</code> 之间通过 <code>Intent</code> 通信。</li>
  <li>生命周期： <code>Android</code> 中维护一个 <code>Activity Stack</code> ， 使得一个 <code>Activity</code> 有四种状态： <code>Active</code> ； <code>Paused</code> ； <code>Stoped</code> ； <code>Destroyed</code> 。
    <blockquote>
      <p>暂停和停止的区别作于：暂停一般系统不会销毁该活动；而停止状态是该活动被其他活动完全覆盖（或点击 <code>HOME</code> 键退入后台），系统在需要时会自动销毁该活动。</p>
    </blockquote>
  </li>
</ul>

<p><img src="lab1-2.png" alt="" /><br /></p>

<h4 id="service">Service</h4>

<ul>
  <li>定义： <code>Service</code> 是一个专门在后台处理长时间任务的 <code>Android</code> 组件，没有 <code>UI</code> ，运行不依赖于任何用户界面。它有两种启动方式， <code>startService</code> 和 <code>bindService</code> 。</li>
  <li>依赖：需要在 <code>AndroidManifest.xml</code> 配置相关信息，使用 &lt;service&gt;&lt;/service&gt; 标签。</li>
  <li>生命周期：这里分两种启动方式讨论。
    <ul>
      <li><code>startService</code> ： 只是启动 <code>Service</code> ，启动它的组件（如 <code>Activity</code> ）和 <code>Service</code> 并 <strong>没有关联</strong> ，只有当 <code>Service</code> 调用 <code>stopSelf</code> 或者其他组件调用 <code>stopService</code> 服务才会终止。</li>
      <li><code>bindService</code> ： 其他组件可以通过 <strong>回调</strong> 获取 <code>Service</code> 的代理对象和 <code>Service</code> 交互，而这两方也进行了 <strong>绑定</strong> ，当启动方销毁时， <code>Service</code> 也会自动进行 <code>unBind</code> 操作，当发现 <strong>所有绑定</strong> 都进行了 <code>unBind</code> 时才会销毁 <code>Service</code> 。</li>
    </ul>
  </li>
</ul>

<h4 id="broadcast-receiver">Broadcast Receiver</h4>

<ul>
  <li>定义：广播接收器是对发送出来的广播进行过滤接受并响应的一类组件。
    <blockquote>
      <p>广播是 <code>Android</code> 中一种广泛运用的在应用程序之间传输信息的机制。</p>
    </blockquote>
  </li>
  <li>依赖：
    <ul>
      <li>广播接收器既可以在  <code>AndroidManifest.xml</code> 中注册（静态注册）。</li>
      <li>也可以在运行时的代码中使用 <code>Context.registerReceive()</code> 进行注册（动态注册）。
        <blockquote>
          <p>当用来注册的 <code>Activity</code> 关掉后，动态注册的 <code>Broadcast Receiver</code> 也随之失效。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>性质：
    <ul>
      <li>应用可以使用它对外部事件进行过滤，使其只对感兴趣的外部事件（例如电话呼入、网络可用时）接收并响应。
        <blockquote>
          <p>虽然 <code>Broadcast Receiver</code> 没有用户界面，但是它可以启动一个 <code>Activity</code> 或者 <code>Service</code> 来响应接收到的消息，或者用 <code>NotificationManager</code> 通知用户。通知方式包括闪灯，震动，放声，状态栏目标等等。</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h4 id="content-provider">Content Provider</h4>

<ul>
  <li>定义：该组件使一个应用程序的指定数据集可以提供给其他应用程序。其他应用可以通过 <code>ContentResolver</code> 类从该内容提供者中获取或存入数据。
    <blockquote>
      <p>即应用程序之间的通信（唯一方式），只有需要在多个应用程序间共享数据是才需要 <code>Content Provider</code> 。</p>
    </blockquote>
  </li>
  <li>依赖：没有依赖。 <code>ContentProvider</code> 使用 URI 来唯一标识其数据集，以 <code>content://</code> 作为前缀，表示该数据由 <code>ContentProvider</code> 来管理。</li>
  <li>性质：
    <ul>
      <li><code>ContentProvider</code> 用于保存和获取数据，即一份数据对所有应用程序可见。</li>
      <li>开发人员不会直接使用 <code>ContentProvider</code> 类对象，大多数通过 <code>ContentResolver</code> 对象实现对 <code>ContentProvider</code> 的操作。
        <blockquote>
          <p><code>ContentProvider</code> 是一个抽象类。创建 <code>MyProvider</code> 类继承 <code>ContentProvider</code> ，实现6个抽象方法： <code>onCreate</code> 、 <code>getType</code> 、 <code>query</code> 、 <code>insert</code> 、 <code>delete</code> 、 <code>update</code> 。 <code>onCreate()</code> 方法会在创建的时候调用一次。其它方法通过ContentResolver的增删改查方法触发。<a href="https://blog.csdn.net/sjdjdjdjahd/article/details/103694314">参考</a></p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h4 id="androidmanifestxml">AndroidManifest.xml</h4>

<ul>
  <li>
    <p>定义： <code>AndroidManifest.xml</code> 是整个 <code>Android</code> 程序的信息扫描文件，它位于整个项目的根目录，描述了 <code>package</code> 中暴露的组件 （<code>Activities</code>，<code>Services</code>， <code>Content provider</code> 和 <code>Broadcast Receiver</code>） 的信息，是每个 <code>Android</code> 程序都必须的文件，该文件在程序创建自动生成的，不需要我们自己创建（该文件的文件名不能修改）。</p>
  </li>
  <li>
    <p>结构：</p>
    <ol>
      <li>&lt;xml&gt; : 版本和编码信息</li>
      <li>&lt;manifest&gt; : <code>package</code> ，用于指定应用程序的包名。</li>
      <li>&lt;application&gt; :
        <ol>
          <li>Android:label : 指定 <code>Activity</code> 中标题栏的内容。默认为程序名。</li>
          <li>Android:supportsRtl (Rtl:right to left): 表示程序是否支持从右到左的布局方向。</li>
          <li>Android:allowBackup : <code>Android API Level 8</code>及其以上 <code>Android</code> 系统为应用程序提供的应用程序的数据备份和恢复功能。其默认为 <code>true</code> ，用户可以通过 <code>adb</code> 命令（ <code>backup</code> <code>restore</code> ） 对数据进行备份和恢复。
            <blockquote>
              <p>存在安全隐患。</p>
            </blockquote>
          </li>
          <li>……</li>
        </ol>
      </li>
      <li>&lt;activity&gt; :
        <ol>
          <li>Android:name : 在创建活动时，需要通过 &lt;activity&gt; 标签进行注册， name 即指定具体注册哪个互动。</li>
          <li>&lt;intent-fileter&gt; : 为程序配置主活动（程序运行时首先启动的活动）。
            <blockquote>
              <p>如果有多个&lt; Activity &gt;，那么其实有一个&lt; intent-filter &gt;标签就可以了，因为如果每个&lt; Activity &gt;标签中都含有&lt; intent-filter &gt;，那么就会按顺序去第一个含有&lt; intent-filter &gt;标签的&lt; Activity &gt;作为程序的主活动。</p>
            </blockquote>
          </li>
          <li>android:permission ： 设置许可名，这个属性若在上定义的话，是一个给应用程序的所有组件设置许可的便捷方式，当然它是被各组件设置的许可名所覆盖的。</li>
          <li>android:presistent ： 该应用程序是否应该在任何时候都保持运行状态,默认为 <code>false</code> 。因为应用程序通常不应该设置本标识，持续模式仅仅应该设置给某些系统应用程序才是有意义的。</li>
          <li>…</li>
        </ol>
      </li>
      <li>&lt;intent-filter&gt; :
        <ol>
          <li>&lt;action /&gt; : 只有 android:name 一个属性，常见的 android:name 值为 android.intent.action.MAIN 。</li>
          <li>&lt;category /&gt; : 也只有 android:name 这个属性，常见的 android:name 值为 android.intent.category.LAUNCHER 。</li>
        </ol>
      </li>
      <li>&lt;meta-data&gt; : 储存资源，供组件使用。</li>
      <li>&lt;activity-alias&gt; : 创建 <code>activity</code> 的快捷方式。</li>
      <li>&lt;service&gt; :
        <ol>
          <li>android:icon ： 声明图标，图片一般都放在 <code>drawable</code> 文件夹下</li>
          <li>android:enabled ： <code>Android</code> 系统是否能够实例化该应用程序的组件，如果为 <code>true</code> ，每个组件的 <code>enabled</code> 属性决定那个组件是否可以被 <code>enabled</code> 。如果为 <code>false</code> ，它覆盖组件指定的值；所有组件都是 <code>disabled</code> 。</li>
          <li>android:process ： 应用程序运行的进程名，它的默认值为元素里设置的包名，当然每个组件都可以通过设置该属性来覆盖默认值。如果你想两个应用程序共用一个进程的话，你可以设置他们的 android:process 相同，但前提条件是他们共享一个用户 ID 及被赋予了相同证书的时候</li>
          <li>…</li>
        </ol>
      </li>
      <li>&lt;Receiver&gt; : 和 <code>service</code> 基本相同。</li>
      <li>&lt;Provider&gt; :
        <ol>
          <li>android:authorities：标识这个 <code>ContentProvider</code> ，调用者可以根据这个标识来找到它。</li>
          <li>android:grantUriPermission：对某个URI授予的权限。</li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<h3 id="task1">Task1</h3>
<p>有了以上安卓编程基础，可以开始实现 Task1，首先创建一个 Receiver：
<img src="step1-1.png" alt="" />
可以看见在AndroidManifest.xml中已经自动添加了receiver字段，接下来实现要求：开机自启动和后台自启动一个service。</p>

<p>为实现以上功能，在清单中申请开机自启权限：
<code>&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;</code></p>

<p>然后完成receiver的onReceive方法，主要思路是：<strong>Receiver通过接受系统开机加载完毕后发送的<code>BOOT_COMPLETED</code>广播，使用Intent加载Mainactivity完成自启动。</strong></p>
<pre><code class="language-java">    @Override
    public void onReceive(Context context, Intent intent) {
        // TODO: This method is called when the BroadcastReceiver is receiving
        // an Intent broadcast.

        if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")){
            Intent i=new Intent(context,MainActivity.class);
            i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(i);
        }

        throw new UnsupportedOperationException("Not yet implemented");
    }
</code></pre>
<blockquote>
  <p>参考0：<a href="https://developer.android.google.cn/guide/components/broadcasts">要在清单中声明广播接收器，请执行以下步骤</a>
参考1：<a href="https://developer.android.google.cn/training/basics/firstapp/starting-activity">如何启动另一个activity</a>
参考2：<a href="https://blog.csdn.net/weixin_44618862/article/details/106268932">为什么要添加FLAG_ACTIVITY_NEW_TASK</a>，因为Context并不存在任务栈，被启动的活动就无法进入启动它的活动的任务栈中，就会出现错误。</p>
</blockquote>

<p>接下来实现无通知启动一个service，同理创建一个service文件后，receiver可以通过启动Mainactivity来间接启动service，即在Mainactivity中启动service。</p>
<pre><code class="language-java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Intent intent = new Intent(MainActivity.this, SecretService.class);
        startService(intent);
    }
</code></pre>
<blockquote>
  <p>报错：Installed Build Tools revision 33.0.0 is corrupted. Remove and install again using the SDK Manager.
解决：找到build tools目录中的d8.bat，将文件名修改为dx.bat。找到build tools目录中的lib/d8.jar，将文件名修改为dx.jar。</p>
</blockquote>

<p>以上，第一步实现完毕。接下来实现获取设备位置信息并每三秒弹窗显示。</p>

<p>首先在清单中添加前台位置权限信息：
<code>&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;</code>
<code>&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;</code>
然后在Mainactivity中申请权限：</p>
<pre><code class="language-java">if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
        != PackageManager.PERMISSION_GRANTED) {
    requestPermissions(new String[] { Manifest.permission.ACCESS_COARSE_LOCATION }, 0);
}
if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
        != PackageManager.PERMISSION_GRANTED) {
    requestPermissions(new String[] { Manifest.permission.ACCESS_FINE_LOCATION }, 1);
}
</code></pre>
<p>权限拿到手后，开始获取其位置信息，基本思路为使用LocationManager调用requestLocationUpdates方法每三秒获取位置信息，而LocationListener进行监听，监听结果使用toast进行显示。</p>
<pre><code class="language-java">    @Override
    public void onCreate() {
        super.onCreate();
        final LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        LocationListener locationListener = new LocationListener() {
            public void onLocationChanged(Location location) {
                String latitude = Double.toString(location.getLatitude());
                String longitude = Double.toString(location.getLongitude());
                String accuracy = Double.toString(location.getAccuracy());
                Log.i("log", "Location changed : Lat: " + latitude + " Lng: " + longitude);
                Toast.makeText(SecretService.this, "getAccuracy:" + 
                accuracy + "\ngetLatitude:" + latitude + "\ngetLongitude:" + 
                longitude, Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {
            }

            @Override
            public void onProviderEnabled(String provider) {
            }

            @Override
            public void onProviderDisabled(String provider) {
            }
        };

        //实现每三秒重新获取
        if (ActivityCompat.checkSelfPermission(
                this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;
            ActivityCompat.checkSelfPermission(
                this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 0, locationListener);

    }
</code></pre>

<blockquote>
  <p>参考1：<a href="https://developer.android.google.cn/training/location">官方文档-位置信息</a>
参考2：<a href="https://developer.android.google.cn/training/permissions/requesting">官方文档-请求权限</a>
参考3：<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html">官方文档-LocationManager</a>
参考4：<a href="https://developer.android.google.cn/reference/android/content/ContextWrapper#getSystemService(java.lang.String)">官方文档-getSystemService</a>
参考5：<a href="https://developer.android.google.cn/reference/android/location/LocationListener">官方文档-LocationListener</a>：其中的几个方法必须被覆盖。
参考6：<a href="https://developer.android.google.cn/reference/android/location/Location">官方文档-Location</a>
参考7：<a href="https://developer.android.google.cn/reference/android/widget/Toast">官方文档-toast</a></p>
</blockquote>

<h3 id="task2">Task2</h3>

<h4 id="ui控件">UI控件</h4>

:ET