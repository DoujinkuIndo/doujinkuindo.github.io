I"K!<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">LValue and Rvalue</a></p>

<p><a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">What are rvalues, lvalues, xvalues, glvalues, and prvalues?</a></p>

<center>

![도표](https://i.stack.imgur.com/xgCnV.png)

</center>

<table>
  <thead>
    <tr>
      <th style="text-align: center">표현</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">glvalue</td>
      <td>generalized + lvalue로 lvalue또는 xvalue를 의미합니다.</td>
    </tr>
    <tr>
      <td style="text-align: center">rvalue</td>
      <td>역사적으로는 표현식의 우측에 나타날 수 있기 때문에 rvalue로 부르며, xvalue 또는 임시 개체, 해당 하위 개체, 개체와 연결되지 않은 값입니다.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center">표현</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">lvalue</td>
      <td>역사적으로 표현식의 좌측에 나타날 수 있기 때문에 lvalue로 부르며, 함수또는 객체를 지정합니다.</td>
    </tr>
    <tr>
      <td style="text-align: center">xvalue</td>
      <td>expiring + value로 일반적으로 수명이 다한 개체를 나타냅니다.</td>
    </tr>
    <tr>
      <td style="text-align: center">prvalue</td>
      <td>pure + lvalue로 xvalue가 아닌 rvalue입니다.</td>
    </tr>
  </tbody>
</table>

<p>lvalue에는 프로그램이 액세스할 수 있는 주소가 있습니다. lvalue 표현식의 예로는 const변수, 배열 요소, lvalue 참조를 반환하는 함수 호출, 비트 필드, 공용체 및 클래스 멤버를 포함한 변수 이름이 있습니다.</p>

<p>prvalue 표현식에는 프로그램에서 액세스할 수 있는 주소가 없습니다. prvalue 식의 예로는 리터럴, 비참조 형식을 반환하는 함수 호출, 식 평가 중에 생성되지만 컴파일러에서만 액세스할 수 있는 임시 개체가 있습니다.</p>

<p>xvalue 표현식에는 프로그램에서 더 이상 액세스할 수 없지만 표현식에 대한 액세스를 제공하는 rvalue 참조를 초기화하는 데 사용할 수 있는 주소가 있습니다. 예에는 rvalue 참조를 반환하는 함수 호출, 배열 또는 개체가 rvalue 참조인 멤버 식에 대한 배열 첨자, 멤버 및 포인터가 포함됩니다.</p>

<details><summary>뭔소린가 싶을때</summary>
<div>

    <p><a href="https://stackoverflow.com/a/37872116/17691420">조금더 쉬운 표현</a></p>

    <p>기본 값 범주는 표현식의 두 가지 속성에 해당합니다.</p>

    <ul>
      <li>
        <p><strong>아이덴티티가 있음</strong>은 개체의 주소 또는 개체가 식별하는 기능(직접 또는 간접적으로 얻음)을 비교하여 표현이 다른 표현과 동일한 엔터티를 참조하는지 여부를 결정할 수 있습니다.</p>
      </li>
      <li>
        <p><strong>이동할 수 있음</strong>이동 생성자 이동 할당 연산자 또는 이동 의미 체계를 구현하는 다른 함수 오버로드에서 이동할 수 있습니다.</p>
      </li>
    </ul>

    <table>
      <thead>
        <tr>
          <th> </th>
          <th>Can be moved from (= rvalue)</th>
          <th>Cannot be moved from</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Has identity (= glvalue)</td>
          <td>xvalue</td>
          <td>lvalue</td>
        </tr>
        <tr>
          <td>No identity</td>
          <td>prvalue</td>
          <td>not used</td>
        </tr>
      </tbody>
    </table>

  </div></details>

<details><summary>그래도 모르겠어요</summary>
<div>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define IS_XVALUE(X) std::is_rvalue_reference&lt;decltype((X))&gt;::value
#define IS_LVALUE(X) std::is_lvalue_reference&lt;decltype((X))&gt;::value
#define IS_PRVALUE(X) !std::is_reference&lt;decltype((X))&gt;::value
</span>
<span class="cp">#define IS_GLVALUE(X) (IS_LVALUE(X) || IS_XVALUE(X))
#define IS_RVALUE(X) (IS_PRVALUE(X) || IS_XVALUE(X))
</span>
<span class="p">...</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_LVALUE</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>                        <span class="c1">// 1</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_LVALUE</span><span class="p">(</span><span class="n">x</span><span class="o">+=</span><span class="n">y</span><span class="p">));</span>                     <span class="c1">// 2</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_LVALUE</span><span class="p">(</span><span class="s">"Hello world!"</span><span class="p">));</span>           <span class="c1">// 3</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_LVALUE</span><span class="p">(</span><span class="o">++</span><span class="n">x</span><span class="p">));</span>                      <span class="c1">// 4</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>                       <span class="c1">// 5</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="n">x</span><span class="o">++</span><span class="p">));</span>                     <span class="c1">// 6</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>  <span class="c1">// 7</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{}));</span>           <span class="c1">// 8</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">()));</span>  <span class="c1">// 9</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_PRVALUE</span><span class="p">(</span><span class="n">doesNothing</span><span class="p">()));</span>           <span class="c1">// 10</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">IS_XVALUE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">)));</span>             <span class="c1">// 11</span>
<span class="p">...</span>
</code></pre></div>    </div>

    <p><a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a></p>

    <ol>
      <li>string literal
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"Abcdefg"</span><span class="p">);</span>
</code></pre></div>        </div>
        <p>C에서는 lvalue를 제외하고, 배열이 유형이 존재할 수 있는 방법이 없기 때문입니다…
그 외에 다른 literal은 rvalue입니다.</p>
      </li>
    </ol>

  </div></details>

<details><summary>음... 어디다 쓰는 건가요?</summary>
<div>

모든 C++ 표현식에는 유형이 있으며 값 범주 에 속합니다 . 값 범주는 표현식 평가 중에 임시 개체를 생성, 복사 및 이동할 때 컴파일러가 따라야 하는 규칙의 기초입니다.

* **RValue Reference**는 불필요한 복사를 제거해서 성능 향상에 도움을 주는 새로운 개념입니다.

</div></details>
:ET