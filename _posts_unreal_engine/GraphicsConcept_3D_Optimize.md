---
layout: post
title: 3D optimize
---

3D 랜더링에서 속도를 빠르게 하는 방법은 2가지 밖에 없다고 합니다. 하나는 안그리거나 가짜를 그리는 것 입니다.
* ? 인스턴스 드로잉 : 가짜를 그리는 건가??

모든 3D는 float곱하기로 연산되어 랜더링 되게 됩니다. (마소등에서 연산량을 줄이기 위해 32비트 플로트를 4개 묶어서 128비트씩 계산하는 방법도 지원합니다. (vectorization), [참고](https://docs.microsoft.com/ko-kr/cpp/parallel/auto-parallelization-and-auto-vectorization?view=msvc-170). 하지만 최적화 한다고 해도 어쨌든 연산 후 출력합니다.)

* 3D 모델을 최적화 하는 방법으로 [리토폴로지, LOD 적용, 수동 브러시 업, 오클루전 메시, 프록시 객체, 텍스쳐 크기 조정/압축 등](https://3d-ace.com/blog/3d-model-optimization/)의 3D 최적화 기술을 볼 수 있습니다.

# LOD(Level of detail)
LOD란 메시 모델링 데이터의 정밀도를 단계별로 조정하는 기술로, 렌더링 속도(Speed)와 질(Quality)사이의 타협 속에서 태어난 기술입니다.

거리에 따라 모델의 디테일을 낮춤으로 렌더링 속도를 향상시킵니다. 멀어질 수록 화면에서 차지하는 비율이 작아짐으로 질이 낮아지더라도 어느 정도 타협이 가능합니다.

## LOD의 종류
* **정적 LOD는 여러개의 메시를 준비해 놓고 게임 등에서 카메라와 물체간의 거리를 측정해서 카메라와 가까운 거리에 있는 물체는 정밀한 메시를 사용하고, 거리가 멀어질 수록 낮은 단계의 메시를 사용하는 기법입니다.**
    - 특징으로 처음부터 메시의 정밀도가 정해져 있고, 이를 카메라와의 거리에 따라서 단계별로 바꿔가며 출력합니다.
    - **따라서 연산이 간단하고, 속도가 빠릅니다. 하지만 모든 디테일 수준에 대해서 메모리상에 로드되어 있기 때문에 메모리 낭비가 있습니다.** 또한 거리에 따라서 메시의 단계가 급격하게 변할 경우 popping(튀는 현상)이 발생합니다.
* 동적 LOD는 카메라와 물체의 거리에 따라서 실시간으로 메시의 정밀도를 변화시키는 기법입니다. 일반적으로 메시 분할과 메시 간략화 기법으로 나뉩니다.
    - 거리에 따라서 자연스럽게 LOD가 이루어지기 때문에 튀는 현상이 적고, 낭비되는 메모리가 없으나, 간략화에 추가 연산이 필요하기 때문에 속도가 느립니다. 또한 정점 계산을 동적으로 수행하기 때문에 레벨이 바뀌거나 정점데이터를 갱신해야 할 때 GPU memory에 대해서 Lock-Unlock을 자주해야 합니다.

## LOD 계산 방법으로
* 거리기반 LOD는 시점 위치와 오브젝트의 거리를 이용해 단계 값을 구하는 방법으로 구현이 간단하고 부하가 적은 필요없는 부분이 세밀하게 보이거나 세밀하게 보여야 하는 부분이 단순하게 보일 수 있습니다.
* 면적기반 LOD는 오브젝트의 투영 면적에 따른 단계값을 구하는 방법입니다. 오브젝트가 화면 혹은 바운딩 박스에 투영된 면적을 통해 LOD 단계값을 구하는 방식으로,
LOD의 효율은 좋으나 CPU의 연산이 많습니다.

## LOD 만드는 방법
* **메시 간략화는 폴리곤의 수를 줄이는 방법**으로, 폴리곤의 수를 줄일 때 모양을 최대한 유지한 상태에서 간략화할 기준을 세우고 간략화할 방법을 통해 폴리곤의 수를 제거합니다. 간략화의 기준은 어느 폴리곤의 어느 꼭지점을 먼저 제거할 것인가등이 있습니다. 간략화 할 방법으로는 점 제거(Vertex Decimation), 점 합치기(Vertex Clustering), 면 줄이기(Edge Colaps)의 3가지 방법이 있습니다.
* 메시 분할는 1개의 폴리곤을 여러개의 폴리곤으로 분할하는 방법이다.

## LOD 사용하기
* 옜날에는 디자이너가 리소스를 여러개 만들어서 프로그래머가 작업을 했습니다. 지금은 엔진에서 계산해서 메모리에 얹혀줍니다. (언리얼 엔진)
* **보편적으로 LOD는 4개까지 사용합니다.**
* RPG계열 게임을 만들 때, 필드상에 존재하는 물체들은 LOD세팅을 다 켜줘야 합니다.
* 굳이 popping 현상이라고 부르기는 하지만 간단히 말하면, 너무 크게 바뀌면 이상하게 보이고, 자연스럽게 보이면, 매우 훌륭하게 변하는 것을 말합니다.

# Mipmap(MIP maps)
3차원 그래픽스의 텍스쳐 매칭 분야에서, 밉맵은 렌더링 속도를 향상시키기 위한 목적으로 기본 텍스처와 이를 연속적으로 미리 축소시킨 텍스처들로 이루어진 비트맵 이미지의 집합입니다. 
* 2D에서도 비슷한 개념입니다. 이때 밉맵은 LOD에 의해서 결정됩니다. 가까이 갈수록 비율이 큰 텍스쳐를 세팅하는 방식입니다. 
    - 스케일링을 해야 하기 때문에 보통 2의 배수로 세팅을 합니다.

## 밉맵의 사용
언리얼에서 밉맵은 자동으로 처리해주나, 개념은 외워두어야 한다고 들었습니다.

* 밉맵을 통해서 앨리어싱을 줄일 수 있습니다.
    - **앨리어싱은 신호 처리 및 관련 분야에서 샘플링 될 때 서로 다른 신호를 구별할 수 없게 만드는 효과입니다.** 또한 샘플에서 재구성된 신호가 원래의 연속 신호와 다를 때 발생하는 왜곡 또는 아티팩트를 종종 나타냅니다.
    - **Moiré패턴은 대규모 간섭 패턴 입니다. 투명한 간격이 있는 불투명한 괘선 패턴이 다른 유사한 패턴에 오버레이될 때 생성될 수 있습니다.** 모아레 간섭 무늬가 나타나려면 두 패턴이 완전히 동일하지 않아야 하며, 오히려 변위되거나 회전되거나 약간의 피치가 달라야 합니다.
    - [위키](https://en.wikipedia.org/wiki/Mipmap)에서 관련 내용을 찾으면 잘 설명 되어 있습니다.
* 카메라를 기준으로 화면이 이중 선형 필터링해서 텍스쳐를 그려줍니다. 이는 단순하게 거리에 따라 밉맵을 사용하면, 밉맵의 레벨이 변경되는 부분에서 경계선이 보입니다.
* 픽셀이 복잡하게 있을 경우 많은 양의 노이즈가 생기는 듯 하게 보이기 때문에 밉맵을 이용해서 자연스러운 랜더링을 구현하고 런타임 성능도 높일 수 있습니다.
* 원래 이미지의 해상도가 높다면 멀리떨어져 있을 때 이미지의 부분부분을 읽게되므로 캐시 효율성이 떨어집니다. 밉맵은 이를 보완할 수 있습니다.
* 다양한 많은 방식들이 있습니다.

## 추가적으로 해야할 것들
[모바일 게임 최적화의 정석?](http://egloos.zum.com/littles/v/3440645)
외... 언리얼 유튜브 찾아보면 이것저것 나온다. 막혀서 잘 안될때마다 공부하도록 하자.


# Culling

## Backspace culling
백스페이스 컬링이란? 그래픽스 파이프라인의 한 단계에 속하며 '컬링' 단계에서 이뤄집니다. 컬링은 최종 씬에서 보이지 않는 불필요한 폴리곤을 잘라내 랜더링 및 연산에서 제외시키는 작업입니다.

## ViewFrustum Culling(절두체 컬링)
모든 정보를 GPU로 보내지 않고 보이는 요소와 보이지 않는 요소를 정렬하고 보이는 요소만 랜더링 하는 방법입니다. 

즉 시야에서 벗어난 폴리곤은 그리지 않는 것을 말합니다.  또한 경계 체적을 구하는데 연산이 필요합니다.

보다 자세한 내용은 [Graphics API](https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling)들을 참고할 수 있습니다.

* 클리핑은 시야에서 벗어난 물체를 그리지 않거나, 시야에 걸친 폴리곤을 잘라내는 것을 말합니다. 클리핑은 단순히 그리기에 대한 예외 처리라서 연산은 적용이 되지 않습니다. **(클리핑은 연산이 되지만, 컬링은 연산이 이뤄지지 않습니다.)**

## Occlusion culling
오클루전 컬링은 뷰 프러스텀 외부에 있거나 카메라에 더 가까운 객체에 의해 숨겨진 형상을 렌더링하지 않음으로써 단순히 렌더링 성능을 향상시키는 방법입니다.

오클루전 쿼리는 기본적으로 간단하다고 합니다. GPU는 화면에 표시되어야 하는 픽셀 수를 구합니다. 이를 CPU에 알리고 렌더링을 결정하는데 사용합니다. (보이는 픽셀의 수가 0보다 크면 개체를 랜더링 합니다.)

* 오클루전 쿼리의 응용 하여 렌즈 플레어를 구현 할 수 있다고 합니다.

[니비디아 오클루젼 컬링 설명](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling)을 볼 수 있습니다.

# 리토폴로지
