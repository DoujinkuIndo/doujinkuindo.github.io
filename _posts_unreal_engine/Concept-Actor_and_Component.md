---
layout: post
title: Actor and component
---

# 주요 개념
언리얼 공식문서 ```기본에 대한 이해/컴포넌트```와 ```프로그래밍 및 스크립팅/액터```에서 설명하고 있습니다.

## 월드
월드는 게임 콘텐츠를 구동하기 위해 필요한 필수적인 환경을 의미하며, 다음과 같은 요소를 제공한다. [버추얼 월드 제작](https://docs.unrealengine.com/5.0/ko/building-virtual-worlds-in-unreal-engine/)에서 레벨 디자인 관련 항목을 보실 수 있습니다.
* 공간
    - 가상 세계를 구성하는 3차원의 영역을 의미합니다. 게임 콘텐츠를 구성하는 물체는 월드의 영역 어딘가에 반드시 존재해야 합니다. 이를 위해 트랜스폼이라는 구조체를 제공합니다. 공간의 기본단위는 cm입니다.
* 시간
    - 가상 곤간에서 흐르는 시간입니다. 가상 세계에서의 시간은 초 단위로 현실 세계와 동일하게 흘러가지만, 시간을 멈추거나 느리게 혹은 빠르게 흘러가도록 시간의 스케일을 조절할 수 있습니다.
* 물리
    - 월드 공간에 배치된 물체에 작용하는 물리적인 환경입니다. 대표적인 물리 환경으로 중력을 들 수 있습니다. 공간에 배치된 물체가 월드로부터 물리적인 영향을 받으려면 콜리전 정보가 있어야 합니다.
* 렌더링
    - 엔진이 제공하는 시각적인 기능, 빛과 이에 반응하는 머티리얼로 구성됩니다. 언리얼 엔진은 현실 세계와 유사하게 동작하도록 물리 기반 렌더링 시스템을 제공합니다.

## 액터(Actor)
[액터](https://docs.unrealengine.com/4.26/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/)는 **언리얼 엔진에서 콘텐츠를 구성하는 최소 단위의 물체입니다. 액터는 게임 월드의 특정 공간에서 자신에게 주어진 역활을 수행하는 물체를 의미합니다.** 월드에 존재하는 액터들의 목록은 월드 아웃라이너 윈도우에서 확인할 수 있습니다.

* 이름
    - 작업을 위해 액터에 부여된 명칭입니다. 여러 액터가 같은 이름을 가질 수 있습니다.
* 유형
    - 게임플레이에서 수행할 액터의 역활을 의미합니다. 프로그래밍 관점에서는 액터의 클래스 이름입니다.
* 트랜스폼
    - 액터는 반드시 월드에 존재해야 하므로 액터에는 항상 트랜스폼이 부여됩니다.
* 프로퍼티
    - 액터에 설정된 속성 값입니다. 액터의 유형에 따라 서로 다른 속성을 제공하며, 속성 값을 디테일 윈도우에서 편집해 같은 유형을 가진 액터가 서로 다른 일을 하게 만들 수 있습니다.
* 게임 로직
    - 액터에 특정 상황이 발생할 때 이에 대응할 구체적인 행동을 명령하기 위해서는 프로그래밍 코드가 필요합니다. 이를 게임 로직이라 합니다.

## 컴포넌트(Component)
액터의 주요 기능으로 크게 세가지로 나눌 수 있습니다. 플레이어에게 어떻게 보여질지 결정하는 시각적 기능, 액터의 이동과 액터들 간의 상호 동작을 어떻게 할 것인지 물리적 기능, 어떻게 움직일 것인지 움직임과 관련된 기능으로 나뉩니다.

[컴포넌트](https://docs.unrealengine.com/4.27/ko/Basics/Components/)는 액터에 추가시킬 수 있는 함수성 조각으로, 컴포넌트는 독립적으로 존재할 수는 없지만, 액터에 추가시킬 수 있는 자립적인 함수성 조각입니다.

예를 들면 스포트 라이트 컴포넌트는 액터가스포트 라이트처럼 빛을 내도록, 로테이팅 무브먼트 컴포넌트는 액터가 회전하도록, 오디오 컴포넌트는 액터가 사운드를 재생하도록 해줍니다.

또한 액터에 컴포넌트를 추가할 때, 그 액터 전체를 이루는 조각들을 함께 모아서 레벨에 배치하게 됩니다. 차를 예로 들면, 바퀴, 운전대, 차체, 라이트등이 컴포넌트로 간주되는 반면, 차 자체는 액터로 간주됩니다.

* 컴포넌트 핵심 유형은 다음과 같습니다.
    * UActorComponent : 베이스 컴포넌트입니다. **일반적으로 개념적 기능과 같은 것에 사용됩니다.**
    * USceneComponent : **씬 컴포넌트는 트랜스폼이 있는 액터 컴포넌트입니다. 트랜스폼은 위치, 회전, 스케일로 정의되는 월드상의 포지션을 나타냅니다.** 씬 컴포넌트는 계층구조 형태로 서로에게 붙일 수 있습니다.
    * UPrimitiveComponent : **그래픽적 표현이 있는 씬 컴포넌트를 말합니다.** 여기에는 재미난피직스 및 콜리전 세팅이 들어있습니다. 

* 컴포넌트 인스턴싱
    - 일반적인 서브 오브젝트의 기본 작동방식과는 상반되게, 액터 안에 서브 오브젝트로 생성된 컴포넌트는 인스턴스로 새엇ㅇ됩니다. 특정 클래스이 액터 인스턴스는 각각의 컴포넌트의 고유 인스턴스를 별도로 갖습니다.
* 컴포넌트 유형으로 대표적으로 AI 컴포넌트, 오디오 컴포넌트, 케이블 컴포넌트, 카메라 컴포넌트, 라이트 컴포넌트, 무브먼트 컴포넌트, 내비게이션 컴포넌트, 페이퍼 2D 컴포넌트, 피직스 컴포넌트, **컴포넌트 렌더링**, 셰이프 컴포넌트, **스켈레탈 메시 컴포넌트**, **스태틱 메시 컴포넌트**, 유틸리티 컴포넌트, 위젯 컴포넌트 등이 있습니다.
    - [참고자료](https://docs.unrealengine.com/4.27/ko/Basics/Components/)에서 보다 많은 내용을 볼 수 있습니다.

## 레벨
[레벨](https://docs.unrealengine.com/5.0/ko/levels-in-unreal-engine/)은 게임 개발 관점에서는 '플레이어에게 주어지는 스테이지'를 의미합니다. 잘 설계된 게임은 난이도에 따라 스테이지를 단계별로 기획해 플레이어에게 제공한다는 것을 생각한다면 전자와 후자의 개념은 어느 정도 유사하다고 할 수 있습니다.


# 액터(Actor)
액터란 레벨에 배치할 수 있는 오브젝트를 말합니다. 액터는 이동, 회전, 스케일과 같은 3D 트랜스폼을 지원하는 범용 클래스입니다.

* 액터는 게임플레이 코드를 통해 생성 및 소멸 가능합니다. 
* C++에서 AActor는 모든 액터의 베이스 클래스입니다.
* 액터는 트랜스폼 데이터를 직접 저장하지 않으며, 액터의 루트 컴포넌트에 트랜스폼 데이터가 존재하는 경우, 그 데이터를 사용합니다.
* AActor 클래스를 인스턴스로 새로 생성하는 것을 Spawn이라고 합니다. SpawnActor()를 사용할 수 있습니다.

액터는 한편으로 보면, Component라 불리는 특수 유형 Object를 담는 그릇으로 생각해 볼 수 있습니다. 여러가지 유형의 컴포넌트를 사용하여 액터의 이동 및 렌더링 방식 등을 제어할 수 있습니다. 

**액터의 또 다른 주요 기능은, 플레이 도중 네트워크를 통한 프로퍼티 및 함수 호출의 리플리케이션 입니다.**

## 액터 수명
[엑터의 수명 주기](https://docs.unrealengine.com/4.27/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/)를 읽을 수 있습니다.

* 참고로
    * 디스크에서 로드는 진한 퍼렁색
    * 에디터에서 플레이는 노란색
    * 스폰은 연한 파란색
    * 디퍼드 스폰은 주황색입니다.

* **Actor의 Construct 후 에 Component의 Construct가 호출되고, 그 다음 BeginPlay가 호출됩니다.**
Destroy 소멸 - 액터를 제거해야겠다 싶지만 게임플레이가 계속 진행중일 때 게임에서 수동으로 호출됩니다. 액터는 킬 대기 상태로 마킹되며, 레벨의 액터 배열에서 제거됩니다.

EndPlay 플레이 종료 - 액터의 수명이 막바지에 다다랐음을 보증하기 위해 여러 곳에서 호출됩니다.

* 액터는 RF_PendingKill 마킹되어 다음 가비지 컬렉션 주기 동안 deallocate (할당 해제)됩니다. 
* **pending kill (킬 대기상태)를 수동 검사하기 보다는, 보다 깔끔한 FWeakObjectPtr<AActor> 사용을 추천합니다.**

**OnDestroy 소멸시 - Destory (소멸)에 대한 구식(legacy) 반응입니다. 여기 있는 것들은 Level Transition (레벨 전환)이나 기타 게임 정리용 함수에 호출되는 EndPlay (플레이 종료)에 옮기는 것이 좋을 것입니다.**

* 위의 참조에서 추가적으로 고급 가비지 컬렉션에 대해서 설명하고 있습니다.
    * 클러스터는 IT용어에서 하드디스크의 논리 단위로 (하드디스크 드라이브에서 파일을 저장하는 단위로 1개 또는 복수의 섹터로 이루어진다. 작은 파일은 1개, 용량이 큰 파일은 여러 개의 클러스터를 사용하여 저장한다. 여러 개의 클러스터를 사용할 때 반드시 연결되어 있지는 않다. 여기저기 흩어져 있어도 그 위치와 순서를 기록한 FAT에 의하여 관리되므로, 한 번에 파일의 전체 내용을 읽을 수 있다.)사용됩니다.
    * [UE4 Garbage Collection](https://www.slideshare.net/QooJuice/ue4-garbage-collection-2)에 잘 설명되어 있습니다.

## 틱 그룹
* TG_PrePhysics
    - 액터가 물리 기반 어태치먼트를 포함해서 물리 오브젝트와 상호작용할 의도가 있는 경우 사용하는 틱 그룹입니다.
    - **이 틱 도중의 물리 시뮬레이션 데이터는 한 프레임 전, 즉 지난 프레임 화면에 렌더링된 데이터입니다.**
* TG_DuringPhysics
    - 이는 물리 시뮬레이션과 동시에 실행되기에, 이번 틱 도중의 물리 데이터가 전 프레임에서 온 것인지 현재 프레임에서 온 것인지 알 수 없습니다. 물리 시뮬레이션은 이 틱 그룹 내 언제든 완료 가능하며, 그러한 사실을 나타내는 정보를 제공하지는 않습니다.
    - 물리 시뮬레이션 데이터가 현재 또는 한 프레임 전의 것일 수 있으므로, 이 틱 그룹은 물리 데이터와 상관 없는 로직이나, 한 프레임 늦어져도 상관없는 경우에만 사용할 것을 추천합니다. **흔한 경우라면 인벤토리 화면 업데이트 또는 미니맵 표시의 경우인데, 물리 데이터가 완전히 무관하거나, 한 프레임 정도 지연되서 표시되도 별 상관이 없기 때문입니다.**
* TG_PostPhysics
    - 이 프레임의 물리 시뮬레이션 결과는 이 틱 그룹 실행 시점에서 완료됩니다.
    - **이 그룹은 무기나 무브먼트 트레이스에 사용하기 좋은데, 모든 물리 오브젝트는 최종 위치인 것으로 알려져 있어 이 프레임이 렌더링될 때 그려질 것이기 때문입니다.** 이는 슈팅 게임의 레이저 시야와 같은 것에 특히나 좋은데, 레이저 빔은 플레이어 총의 최종 위치에서 나오는 것처럼 보여야 하고, 한 프레임만 랙이 발생해도 매우 눈에 띄기 때문입니다.
* TG_PostUpdateWork
    - TG_PostPhysics 이후 실행됩니다. 역사적으로 그 주요 기능은 파티클 시스템에 최후의 순간 정보를 물려주는 것이었습니다.
    - TG_PostUpdateWork 는 카메라 업데이트 이후에 일어납니다. **카메라가 정확히 향하고 있는 방향에 의존하는 이펙트가 있는 경우라면, 그러한 이펙트 제어를 위한 액터는 이 곳에 넣는 것이 좋습니다.**
    - 프레임 내 완전 다른 모든 것 이후 실행시킬 게임 로직에 사용하기에도 좋은데, **격투 게임에서 같은 프레임에 서로를 잡으려 하는 두 캐릭터를 알아내려는 경우가 그렇습니다.**

## 액터 틱(Tick)
Tick, 틱이란 액터나 컴포넌트에 일정 간격, 보통 한 프레임에 한 번 코드 조각 또는 블루프린트 스크립트를 실행시키는 것을 말합니다.

**액터와 컴포넌트의 틱 주기는, 최소 틱 간격을 지정하지 않은 이상 한 프레임에 한 번입니다. 틱 발생은 틱 그룹에 따라 이루어지며, 틱 그룹은 코드 또는 블루프린트에서 할당할 수 있습니다.** 각 틱 그룹은 그에 할당된 모든 액터와 컴포넌트 틱이 완료된 이후에야 다음 틱 그룹을 시작합니다.

**틱 그룹에 더해, 액터나 컴포넌트는 틱 종속성을 설정할 수 있는데, 다른 액터나 컴포넌트의 틱 함수가 완료되기 전까지 틱이 일어나지 않도록 하는 것입니다.** 틱 그룹과 틱 종속성은 게임 내 물리 기반 동작과의 어우러짐이나, 다수의 액터 또는 컴포넌트가 연관된 순차적 게임플레이 동작이 어색하지 않도록 하는 데 있어서 매우 중요할 수 있습니다.

## 틱 종속성
하나의 액터 또는 컴포넌트에 다른 액터 또는 컴포넌트가 필요로 하는 데이터가 구성되는 경우에 특히나 유용합니다. 틱 그룹이 아닌 이 기능을 사용하는 이유라면, 액터가 같은 그룹에 있는 경우 다수의 액터가 병렬 업데이트일 수가 있기 때문입니다. 

* AddTickPrerequisiteActor, AddTickPrerequisiteComponent

? 액터가 병렬 업데이트일 수가 있다는 말이 먼 말이라냐?
