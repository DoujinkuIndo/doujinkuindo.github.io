---
layout: post
title: Fragment
---

## 오늘할건 배치한 물건들을 이론적인 설명함
커서를 올렸을 때 뜨는 정보가 다르다,
콜리젼 때문으로 알고있지만, 어떤 내용을 설명할 것인가?
굳이 들어가보지 않아도, 아이콘으로 충돌의 유무를 확인할 수 있다. 흠. 이건 생각못했는데.

단순 콜리젼이 있고, 복합 콜리젼이 있다.
일단 메쉬 뷰에서 복합 콜리젼을 선택해도 되는 것은 아닌데. 어쨌든 폴리곤 전부 검사하는 복합 콜리전은 너무 느려서 게임에서 사용하지 않는다고 생각하면 된다.

* 바운딩 박스라고 있다.

문제가 있다. 뱀이라고 하자. 박스콜리젼 어떻게 할 것인가? 아이템의 경우? 물체에 따라 달라진다. 점수를 주는 아이템의 경우? 먹냐 안 먹냐가 중요하지, 콜리전은 어색하지만 않을 정도의 어색하지 않게 하는게 중요, 정교하게 콜리젼을 만들 필요는 없다. 납득할 수 있을 정도의 정교함이 중요하다.

컨벡스 콜리젼은 나름 정교하게 하긴 하지만, 많이 먹는다.

그외 Ctrl Z는 한개씩 천천히, 맹신하지는 말자.

## 지금부터 사용하는 용어는 무조건 외워야함.

3D에서 속도를 빠르게 하는 것은 2가지 방법밖에 없다. 안그린다. 가짜를 그린다.

3D는 무조건 float 곱하기가 됨.

마소나 그런거는 32비트짜리 플로트를 4개 묶어서 128비트씩 계산함.

약자로는 LOD(Level of detail)라고 함.
LOD란 메시 모델링 데이터의 정밀도를 단계별로 조정하는 기술, 렌더링 속도(Speed)와 질(Quality)사이의 타협 속에서 태어난 기술

필요한 이유
우리가 사용하는 실시간 렌더링 기술은 실시간으로 화면에 캐릭터와 지형, 건물등을 그려야 하기 때문에 어느 정도 질을 떨어뜨리더라도 빠르게 렌더링 되는 것이 중요하다. 이럴때 가능하면 질을 적게 떨어뜨리면서 속도도 빠른 렌더링 기술을 개발하는 과정에서 태어난 기술입니다.

정적 LOD
여러개의 메시를 준비해 놓고 게임 등에서 카메라와 물체간의 거리를 측정해서 카메라와 가까운 거리에 있는 물체는 정밀한 메시를 사용하고, 거리가 멀어질 수록 낮은 단계의 메시를 사용하는 기법
특징. 처음부터 메시의 정밀도가 정해져 있고, 이를 카메라와의 거리에 따라서 단계별로 바꿔치기하며 출력한다.
장점
연산이 간단하기 때문에 속도가 빠른다.
단점
여러 단계의 메시를 추가로 가지고 있어야 하기 때문에 메모리 낭비가 심하고, 거리에 따라서 메시의 단계가 급격하게 변하기 때문에 튀는 현상(popping)이 발생한다.

동적 LOD
카메라와 물체의 거리에 따라서 실시간으로 메시의 정밀도를 변화시키는 기법, 일반적으로 메시 분할과 메시 간략화 기법으로 나뉜다.

장점.
거리에 따라서 자연스럽게 LOD가 이루어지기 때문에 튀는 현상이 적고, 낭비되는 메모리도 없다.
단점
메시 분할이나, 간략화에 추가 연산이 필요하기 때문에 속도가 느리다.
정점 계산을 동적으로 수행하기 때문에 레벨이 바뀌거나 정점데이터를 갱신해야할때 Lock-Unlock을 자주해야 한다.

LOD 계산 방법
거리기반 LOD
시점 위치와 오브젝트의 거리를 이용해 단계 값을 구하는 방법으로 구현이 간단하고 부하가 적은 필요없는 부분이 세밀하게 보이거나 세밀하게 보여야 하는 부분이 단순하게 보일 수 있따.
면적기반 LOD
오브젝트의 투영 면적에 따른 단계값을 구하는 것이다.
오브젝트가 화면 혹은 바운딩 박스에 투영된 면적을 통해 LOD 단계값을 구하는 방식이다.
LOD의 효율은 좋으나 CPU의 연산이 많다.

메시 간략화
폴리곤의 수를 줄이는 방법으로, 폴리곤의 수를 줄일 때 모양을 최대한 유지한 상태에서 간략화할 기준을 세우고 간략화할 방법을 통해 폴리곤의 수를 제거한다. 간략화의 기준은 어느 폴리곤의 어느 꼭지점을 먼저 제거할 것인가등이 있다.
간략화 할 방법으로는 점 제거(Vertex Decimation), 점 합치기(Vertex Clustering), 면 줄이기(Edge Colaps)의 3가지 방법이 있다.

메시 분할
1개의 폴리곤을 여러개의 폴리곤으로 분할하는 방법이다.

옜날에는 디자이너가 리소스를 여러개 만들어서 프로그래머가 작업을 했다.
지금은 엔진에서 계산해서 메모리에 얹여준다?!.
보편적으로 LOD는 4개까지 사용한다.
RPG계열 게임을 만들 때, 필드상에 존재하는 물체들은 LOD세팅을 다 켜줘야 한다.

굳이 Poping 현상이라고 부르기는 하는데, 너무 크게 바뀌면 이상하게 보이고, 자연스럽게 보이면, 매우 훌륭하게 변한다.

**LOD와 비슷하게 외워야 하는것. mipmap(밉맵)**
자동으로 해주지만, 어떤건지는 확실하게 알아야 한다.

## 잠재적으로 무한한 아이템 항목 만들기

데이터 테이블은 사용하기 쉬워야 하고 효과적이여야 합니다.
언리얼에서는 CSV와 JSON을 사용할 수 있습니다.

사용예시로 Google Sheet에서 CSV로 다운로드 받습니다.
CSV의 구조와 데이터 테이블에 사용할 자료형의 구조를 매칭시킵니다.
CSV를 임포트 시키면, 자료형을 선택하여 CSV를 임포트 합니다.

DataTableRow(만든 데이터 테이블을 가진)와 자료형 변수를 생성합니다.
데이터 테이블에서 읽어들인 로는 자료형 변수에 저장됩니다.
생성함수에서 데이터 테이블에서 읽어들인 후, 변수에 저장합니다.

데이터 테이블은 노동을 줄일 뿐만 아니라, 유연성을 제공합니다.

##

Validation(유효한)은 어떻게 사용해야 하는가?

```
$ git submodule add https://github.com/kbmhansungb/UnrealPlugin_HorrorCore Plugins/Horrorplugin
```

[특정 디렉토리 서브모듈 이용법](https://postlude.github.io/2019/01/06/git-submodule/)
[서브모듈 사용법2](https://pinedance.github.io/blog/2019/05/28/Git-Submodule)
[서브모듈 사용법](https://ohgyun.com/711)
[Git submodule 간단하게 삭제하기](https://asbear.tistory.com/190)

## Replication

1. RPC는 클라이언트가 UFUNCTION(Server, Reliable, WithValidation)함수 A를 호출하면, A함수가 서버에서 UFUNCTION(NetMulticast, Reliable) B함수를 호출한다. 그럼 각 서버와 클라이언트에서 B함수가 원하는 동작을 수행한다.

2. 선언 할 때는 A, B라 선언하지만 정의 할 때는 A_Implementation, B_Implementation라 정의해야 합니다. 언리얼 코드 제너레이터가 뒤에 Implementation가 붙은 함수를 호출합니다.

3. 추가로 bool A_Validate함수가 필요합니다.

4. (몽타주 애니메이션)모든 동작마다 replicate를 따로 해줘야 합니다.

5. 발사와 같이 특정 방향 캐릭터 기준이 필요한 경우에는 UFUNCTION(Server, Reliable, WithValidation)함수에 파라미터로 넘겨줘야 합니다.

6. 몽타주 실행을 위한 AnimInstance는 5번을 생각해서 파라미터로 넘겨주면 문제가 생길 수 있습니다. AnimInstance는 Transient합니다. 

* 컴퓨터 프로그래밍에서, transient는 일시적인 시스템의 모든 요소의 속성입니다.

7. 몽타주의 전체 재생 시간보다 blend 시간을 압도적으로 짧게 잡아야 합니다. 그렇지 않으면 blend 하는 사이에 애니메이션이 끝나 결과적으로 애니메이션이 재생되지 않는  것처럼 보입니다.

? WithValidation 

```cpp
UFUNCTION(Client, Reliable)
void ClientRPCFunction();
...
```

```cpp
UFUNCTION(Server, Reliable)
void ServerRPCFunction();
...
```

```cpp
UFUNCTION(NetMulticast, Reliable)
void MulticastRPCFunction();
...
```

Class 설정에서 Replication/Replicates 마킹을 선택해야 서버와 클라이언트 두 곳에서 스폰됩니다.

[블루프린트 리플리케이션 특강](https://www.unrealengine.com/ko/blog/crash-course-in-blueprints-replication)

## RPC(remote procedure call, 원격 프로시저 호출)

* **함수 앞에 Client, Server, Multicast 키워드를 붙인 것은 프로그래머에게 각각 어디서 호출되는지 한눈에 파악하기 위해 합의된 규칙입니다.**

* reliable은 게임플레이에 핵심에 관련된 모든것들 입니다. 입력을 기반으로 최대한 빨리 처리해야 하는 것에 사용합니다.
* unrealiable은 파티클이나 사운드 같이 올바른 순서로 클라이언트에 제공할 필요가 없는 경우 사용합니다. 지연 처리됩니다. RepNotify를 통해 대신할 수 있습니다.


* 원격 프로시저 호출은 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술입니다.

* 보안상의 이유로 클라이언트는 자신이 소유한 액터로부터만 RPC를 보낼 수 있습니다.
    - PlayerController 또는 PlayerCharacter 액터에서 RPC를 보내거나 Component에 정의하여 사용할 수 있습니다.
    - Owner가 Outer였는지는 확인필요.

* 서버가 이벤트를 실행할 때 클라이언트가 이벤트를 보도록 하려면 NetMulticast RPC를 사용해야 합니다.

##

* 결과보다는 방법이 더 중요하다. 프로그램에 대한 노력이 없으면, 포트폴리오로부터 가치가 없다.

* 애셋을 병합만 하고 저장하지 않고 이주하면, 머티리얼은 이주되지 않음. 흠. 이주하고 저장을 하면 꼬임?

* 언리얼 리소스 이주. 폴더 명을 맞추고 이주해야함?

* 3D에 관련된 용어는 외워야 할 것.
Backspace culling. 뒷면을 고른다.
뷰프로스턴 컬링. 이거는? Frustum culling(절두체 컬링)
걸쳐져있는것을 잘라서 그리는 것을 클리핑이라 한다.

렌더링에 컬링 반전이 있네?. 몰랐던게 나왔네.

## 오늘하는거는 Asset을 가져와서 읽는 것.

* 언리얼 설치하거나 할 때 200GB정도는 여유가 있어야 한다. 언리얼 설치한 폴더도 50 ~ 100GB는 여유가 있어야 한다. 왜냐하면, 언리얼 에셋을 다운받으면, 먼저 엔진에 캐시를 만든후, 에셋을 추가하면 그 다음 폴더에 추가된다.

* 쓰지 말아야할 에셋은 무엇인지?

왜 검증된 리소스냐면 아이폰 4였을때, 서비스를 끝낸, 모바일상에서 돌아갔다를 근거로 검증되었다고 말한다.

프로젝트 생성하거나 추가하는 에셋이 있다. 생성한 프로젝트의 리소스를 사용하는 방법은 리소스 이주라고 한다.
왜 리소스 이주를 하냐, 리소스가 너무 많아서 정리가 안되기 때문이다. 또한 컴퓨터가 못버틴다. 따라서 리소스 이주를 사용한다.

어떻게 작업해야 하나, 새로운 프로젝트를 만들어서, 추가하고 독립적인 기능을 만들고, 가공이 끝나야, 애셋을 통합해서 관리해야 한다.
음. 프로젝트 별 관리라 한다는 구만.

모든 애셋은 아래에 구현설명이 있다. 안에 어떤게 들어있는지 등이 있다. 설명을 잘 읽으면 어떤식으로 해야하는지 잘 나와있다.

Showcase또는 오버뷰를 먼저 열어봐야 한다. 오버뷰를 먼저 열어야 나중에 쉐이더 컴파일 하느라 지연되지 않으며 겸사겸사 볼 수 있다.

셈플을 가져와서 쓰는건 문제가 없지만(프로그래밍 포트폴리오닌까) 그대로 쓰는건 안되고 최소한 재가공은 해야 한다.

**맵을 만들 때 중요한건, 절대로 시야밖에 아무것도 없는 빈공간이 있으면 안된다. 절대로 안된다. 기본적인 성의에 관련된 거다.**
이런 자잘한 작업에 생각보다 시간이 굉장히 많이 든다.

**물건을 클릭하고 Cntl-b를 누르면 에셋 탐색한다.**
뒤로 이동이라던가.

## 

정확하게 붙여야 할때는 역시 뷰옵션을 바꿔서 하는것.

키보드 End키를 누르면 수직방향으로 다을때까지 물건을 놓아줌. 이것도 중요한 기능.

그리드 스냅을 껐다 켰다하면서 물건 배치하면 됨.

중요한 단축키, 마우스 우클릭 휠은 속도조절, 많이쓰게됨.!?
f키를 누르면 바로 앞으로 이동.

과제: 레벨 디자이너 퀵 스타트 끝까지 하는 것이 과제. 마지막 밥아저씨 같은거 까지는 안해도 된다.

인스턴스에 직접 컴포넌트를 추가해서 만드는 경우, 그거는 영상물 만드는 사람들이다.

작업하는 폴더가 어떻게 되든간에, 영문으로 폴더를 만들고 선택.
최대퀄리티는? 레이트레이스는 이거는 게임에 쓰는게 아니라, 영상처리에 사용하는거

본인 컴퓨터가 너무 성능이 안좋으면, 모바일로 해도 됨.
시작용 콘텐츠는 있어야함.

3인칭으로 만드는데, 3인칭이 제일 어려워서 3인칭으로 한다고 한다. 1인칭 3인칭 혼합해서 사용하기 때문에?

프로젝트 만들때 진짜 조심해야할 주의사항. (언리얼 뿐만 아니라, 만에 하나라는게 있어서)
모든 작업폴더와, 연관 폴더는 영문만 써야함.

## 중요하게 생각하는거 2가지
가장 중요한건 3D에 대한 이해
어지간한 기능은 엔진이 다해줌. 프로그래밍 포트폴리오는 최소한의 여기에 어떤식으로 프로그래밍 요소를 넣어서 관리할 것인가 이게 반드시 있어야함.
기능의 타협을 한다면 (어려워서 포기하면) 포트폴리오로서의 가치가 없을 수 있다.

상속으로 할 거냐, 디스패치로 할거냐, 조립을 할 거냐, 어떤 걸 선택해도 일단은 돌아감. 중요한건 왜 이렇게 관리하도록 만들 었는가? 이래야 나중에 할 이야기가 있다.

SCANS라 한다면, 게임용 리소스는 아님. 받아도 못사용하는 것.

LOWPOLY의 문제는 LOWPOLY에 어울리는 리소스 찾기가 쉽지 않다.

중요한건 어떤식으로 적용이되느냐, 적용할 것이냐 아니냐, 가 중요. 어떻게 돌아가는지는 별로 안중요하다.

그래픽은 전부다 노가다. 예를 들어 수상작같은 것들 보면 전부 그래픽 작업. 프로그래밍적인 내용이 없음.

언리얼 엔진 DOC의 문제는 이름을 몰라서 검색을 못하는게 문제이다. 이름을 알아야 검색을 할 수 있는데, 이름을 모르면 검색을 못한다. 따라서 기능적인 것은 까먹어도 되지만, 구성을 할 때 어떤 걸 먼저해야 하고, 어떤걸 어떻게 해서 어떻게 들어갈지는 절때 까먹으면 안된다?

수업시간에는 C++을 다루지 않음. 블루프린트로 작업한다고함.

UE4 시작하기 클릭, 레벨 디자이너 퀵스타트 가이드 보고 하기

일단 본인이 노트북으로 언리얼 프로그래밍 하겠다는 마음가짐을 버린다. 데스크탑으로 해야 한다. 의외로 그래픽카드는 그렇게 부담이 되지 않는다. 근데 CPU와 RAM, 하드공간이 가장 중요하다.

학원 강의 렘 16GB <- 작업하는데 어려움을 겪음. 원할하게 엔진작업을 하고 싶다. 32GB가 권장.

###

? UAnimSequenceBase를 상속받는 UAnimSequence와 UAnimStreamable 있음. 여기서 문제가 발생함. UAnimStreamable이 뭔지 모르겠음.

해매지 않았다면 한번에 AnimNotify로 만들었을 거 같은데. 음... 근데 내부 코드를 모르니 그저 가정일 뿐인가?

## FGuid
전역 고유 식별자(全域固有識別子, 영어: Globally Unique Identifier, GUID)는 응용 소프트웨어에서 사용되는 유사난수이다.

## 3D 탐색 플러그인
설마 이렇게 만들었나 싶지만 실제로 이렇게 만들었다고 한다. unreal engine forum을 보면 [3D navigation](https://forums.unrealengine.com/t/3d-navigation-plugin/112703)에 대한 정보를 보여준다. 관련 내용을 찾기가 어렵다고 한다.

[3D navigation system for virtual reality based on 3d game engine](https://www.semanticscholar.org/paper/3D-navigation-system-for-virtual-reality-based-on-SharkawiK.-Ujang/0f3fed63730ec4ded51ff0b78ca80356ca790263#citing-papers)에 관한 내용은 찾을 수 있다. 하지만 2008년에 작성된 내용이다. 2D에서 찾아서 3D에 적용하는 방법을 찾아야 하나?

* 여러개의 NavMesh를 합치는 방법은 나중에 생각하도록 하자.

## UPROPERTY 단위 표시
CharacterMovementComponent를 보면 ForceUnits를 통해서 Editor에서 단위를 표시할 수 있음.
```cpp
	UPROPERTY(Category="Character Movement: Walking", EditAnywhere, BlueprintReadWrite, meta=(ClampMin="0", UIMin="0", ForceUnits="cm"))
	float MaxStepHeight;
```


## UOject Class를 변수로

* UCLASS 매크로에 BlueprintType, DefaultToInstanced, EditInlineNew을 추가합니다.
    * 

* UPROPERTY 매크로에 Instanced를 추가합니다.

! 개발을 좀더 편하게, Editor는 디버그가 편하게 DebugGame, 그리고 BuildTarget에서 Non-Unity mode로 빌드되도록.
! 자동으로 인클루드 하는게 엄청 많았나 보구나, 오래걸릴만 하네. PCH가 하는 역활인가? 가끔식 PCH바뀌면서 엄청 오래걸렸던거 같은데?
! 엄청나게 직접 추가해야 하기는 하는데, 빠를 수만 있다면, 충분히 감수할만하다고 생각합니다. 실제로 엄청더 빠릅니다.
그래 빌드 속도가 이정도는 되야 할만하지. ㅠㅠ
! 내가 병신이였구나, 이렇게 빌드 속도가 빨랐는데, 시간을 낭비하다니.

```c#
        bUseUnityBuild = false;
        bUsePCHFiles = false;
```

? PoseLink는 Local space(부모본과의 관계)
? ComponentSpacePose는 Component와의 관계

? 이름은 안바꾼다고 생각하고 만들도록 하자.

? **ㅠㅠㅠㅠㅠㅠㅠㅠㅠ 쓸데없는데서 시간 오래 잡아먹혔네, 내일 정리하자.**
Interface,

? UnityBuild로 cpp자동으로 통합되니, 한 클래스안에 때려박지 말도록 하자.

? 디퍼드 렌더링 모드, Static mesh component는 simulation 되어 있지 않으면 velocity를 그리지 않음.

? 공부할 때는 25분 5분 타이머가 굉장히 효율적이다.

? 로딩 스크린 만드는 방법.
https://www.youtube.com/watch?v=6CkR6KG2znM
MainMenu만들고 시간을 들여서 이것을 공부하도록 하자.

? 이걸로 함수에 대한 이해를 높일 수 있지 않을까요?
https://scahp.tistory.com/81
근데 이 내용은 아무리 봐도 DX12 튜토리얼 에서도 볼 수 있을 꺼라 생각하는데, 판단은 읽어보고 하도록 합시다.
어쨋든 이사람 블로그 정말 좋구만,
IT개발노트, 언제한번 천천히 다 흡수해야지.

? 이걸로 Raymarching Algorithm을 공부할 수 있을 것 같아요.
https://vateran.tistory.com/52

? 에미리트 보간법도 공부하고 싶어요.
잘못 찾은거 같은데...? https://conerstone.tistory.com/5

? 커스텀 언리얼 엔진 노드를 쉽게 만드는 방법.
커스텀 노드랑 커스텀 표현식은 다른 내용 같다. 여기서는 블루프린트 커스텀 노드를 쉽게 만드는 방법을 설명하는 것 같다.
https://rhyce.dev/2021/09/17/how-to-make-custom-unreal-engine-nodes-easily/?utm_source=rss&utm_medium=rss&utm_campaign=how-to-make-custom-unreal-engine-nodes-easily

? UI만들때 라이브 코딩하면 실패하는 구만. 변수가 자동으로 2로 이름이 변경되면서.

? 나나이트와 루멘

? 써봤을 떄 유용하다면 조금 더 공부할 필요가 있는 것이다?

? VAssistX와 PVSStudio

? 카오스 솔버

? 플루이드

? 복셀로 자연스럽게 연결하고

? UV설정해준후

? 머티리얼의 색을 맞추면 완성

? Lamp 만드는 방법들

? 머테리얼 도메인은 무엇인가?

[언리얼 엔진 모델링 모드](https://www.unrealengine.com/ko/tech-blog/unreal-engine-5-s-modeling-mode-takes-shape)

어떻게 사용해야 보다 효율적으로 사용할 수 있을까?
일단 무지하게 좋다는 사실은 알았다.

? 보다 사실적이고 좋은 그래픽을 위한 방법

? MS shader 별 내용없는 것 같지만, 그렇다고 하자.


이해하기 어렵네. 
만약에 쉐이더 컴파일할때 오류를 출력하는 거면,
내가 멍청해서 못한거니 앞으로 행동을 수정할 필요 있음.
멍청해서인지 아닌지 아직은 모르겠지만, 일단은 안보임.
픽셀 쉐이더의 시맨틱이 SV_POSITION 하나만 사용할 때는 생략가능함.
하지만 하나 이상이 되면 명시해줘야함.
명시하지 않으면 Fatal error를 발생시킴.


추가적으로 알게된 사실이지만, 언리얼 엔진 설치중에 해당 엔진을 이용하는 비쥬얼 스튜디오를 키면 응답오류를 발생합니다.
엔진 커스터마이징 해보고 싶었지만 200GB 넘어가는 것, 컴파일 하는데 하루걸리는 것 보고 지금은 아닌 것 같습니다. 엔진 커스터마이징 하는 방법 기록을 남겨두고 정리합시다.

? 망할 모르는 것을 어떻게 모르는지 아는가?

어리석고 겁이 없어라. 이제 겁을 좀 가지고 살자.

게임을 만들기 위해서는 국영수가 필수인가.

이 사고방식들에 대한 이론 또는 근거가 필요하다.
- 중요하지 않은 것은 상관 없지만, 중요한 것들은 효율성, 또는 정확성을 위해서 이론 또는 근거를 필요로 한다. 혼자 백날 생각하는 것 보다 논문 한편 읽는게 효율적이다. 

그림으로 이해한다. 이것은 기억하기 위한 필수 조건이다. 기억을 해야 응용하기 쉽다.
- 글로 기억한 것은 머리에 남지 안지만, 그림으로 기억한다면 이는 상당히 머리속에 오래 남는다. (지극히 당연한 이야기이다)
- 그림으로 그리기 어렵다면, 동사로라도 외우도록 하자.

분해하고 쪼갠다. 이것은 사용하기 위한 접근방식이다.
- 가장 단순한 selection sort를 생가하면 기준이 되는 피벗과 셀렉션을 분할 할 수 있다.
- 분해하고 쪼개기 위해서는 증명을 필요로 한다.

깊게 이해한다. 이것은 응용하기 위한 접근방식이다.
- 예를 들어 헤미스피어가 (사실 헤미스피어는 아니지만) 평면위의 한 점에 대한 레이의 축척이라는 점을 이용해서 빛의 반사 성질을 설명할 수 있다.
- 프레넬공식은 잘 모르지만, 들어오는 빛과 노말법선의 세타값이 커질 때 빛의 반사가 커진다. 이는 림라이트를 고려할 수 있다. 림라이트를 생각하면 NPBR과 PBR을 생각할 수 있는데, NPBR에서 흥미로운 것을 생각할 수 있다.

왜 펄어비스에서 못했을 까? 지금 생각해보면 할만 했었는데.
코드분석을 할줄 몰랐다.
- **사실 지금도 할줄 모른다. 하지만 코딩 규약을 따른 코드가 정말 읽기 쉽다는 사실은 알았다.**
- 읽기 쉬운 코드를 작성하는 것이 정말 중요하구나. KISS원칙이라고 하나. 추가적으로 간단하기 위해서는 정말 많이 알아야 한다. 다만 반복을 줄이기 위해서 사용한 코드가 어디에 있는지 아는게 조금 어렵다. 규칙이 있을 것 같은데 아직은 잘 모르겠다.
이상행동을 좀 많이 했다.
- 말할 때 생각하고 말하기.
    - 질문을 할 때는 상대방이 무슨 질문을
못하는 것을 할려했다.
- 개발자에게 처음해보는 그냥 처음 하는 사람과 다를게 없다.
- 개발자들은 자신의 커리어를 위해서 자신한테 필요한 것을 할려고 한다.
- 프로는 정체기를 얼마나 잘 견디냐 이다.
    - 나는 정체기를 안견딜려 했다.

게임 코드를 작성할 때는 IS a와 Has a관계, 상속에 대해서 생각해야 한다. 복잡하게 말하면 그렇고 게임 코드 작성 패턴은 오브젝트와 컴포넌트 패턴이다. 조립을 전제로 코드를 작성한다.

GlobalShader를 추가하기 위해 시도한 것들.
- 처음에 따라할려 했지만, 안됬다. 여기서 멘탄이 나갔다. 포럼, 사이트 등등 여러개를 찾았지만, 유용한 결론에 도달하지 못했다.
    - 버전을 생각하자. 버전이 다르니 코드도 많이 달랐다.
    - 이에 대해서 git변경이력을 보는 것이 도움이 될지도 모른다는 사실을 들었다.
        - 해당 파일에 대한 git변경이력을 보는법은 잘 모르겠다. 하지만 생각지도 못한 방법이다.
        - 추가적으로 GitHub 특정 메서드 찾기가 궁금하다. 그래야 해당 변경 이력을 쉽게 찾을 수 있지 않을까 생각한다.
    - 공식문서 씨이발, 버전이 바뀌었으면 업데이트 해줘야지잉. 안되는거 그대로 올려놨다.
        - 다르게 생각하면 현업에서 사용하는 사람한테는 별로 필요없다는 뜻이 되는 것인가?
- IT 개발 노트와 중국어로 된 사이트를 찾았다.
    - 댓글 보니 버전이 올라가면서 달라진 부분이 있었다.
        - 댓글도 꼼꼼하게 읽어야 된다는 사실을 알았다.
    - 버전이 다르니 달라진게 굉장히 많았다.
- 다른 분석 문서를 보았다.
    - 자동 한글번역 개판이다. 영어를 잘할 수 있으면 좋겠다.
- 가장 심플한 코드를 찾아 이해하였다. 사실 이게 제일 효율적인 것 같다. 다만 코드를 보고 이해하기 위해서는 해당 코드의 개념이 필요하다.
    - 개념은 공식문서, 분석문서를 한번 쭉 **정독**하는 것이 제일 효과적인 것 같다. 물론 전부 읽을라면 머리가 상당히 아프다.

쉐이더를 대하는 자세.
- 다필요 없고 쉐이더가 어떻게 작동하는지 쪼갤 수 있는 수식, 함수 단위로 쪼개서 이해하도록 하자. 그래야 자유롭게 응용 가능하다.

* final 어떻게 쓰는건지 모르겠네.

* 사소한 코드의 오류로 시간을 낭비하는 것을 막는 방법이 있을까?
    - 테스트 주도 개발, 다만 UI를 어떻게 테스트해야하는지는 모르겠음.

* 비쥬얼 스튜디오로 디버그를 활성화 해도 핫 리로드가 작동함.

* 함수 오버로딩은 하지말자, 하루동안 삽질했네...

* Widget을 생성할때 World가 아니면 Loop에 빠지는가?

* TSubclassOf<Class>에서 Class가 final일 경우?
상관없다고 한다.
* TSubclassOf<Class>에서 Class가 전방선언인 경우?
상관없다고 한다.

## Asset의 구조와 애셋의 래퍼런싱?


## 링크 모음

도저히 답이 없다 싶을때는 코드를 분석해야 한다.
|[시간이 오래걸릴 것 같다 싶을때는 programmer all로](https://www.programmerall.com/article/60142006637/)|

수까락, 기타 등등.

: [Unreal 4 렌더링 프로그래밍 주제 개요 및 목차](https://zhuanlan.zhihu.com/p/36675543)
, [건강한 남자??](https://blog.csdn.net/qq_16756235)
, [Realities.io](https://medium.com/realities-io/creating-a-custom-mesh-component-in-ue4-part-1-an-in-depth-explanation-of-vertex-factories-4a6fd9fd58f2)
, [IT개발 노트](https://scahp.tistory.com/10?category=848072)
, [Space Panda](https://spacepanda.tistory.com/4?category=704623)
, [보트내에 물 뺴기](https://forums.unrealengine.com/t/take-out-water-from-inside-of-the-boat-with-custom-stencil-logic-puzzle/365545/6)

[카메라 흔들기](https://microsoft.tistory.com/983?category=826831)

## UE5 Blueprint Widget

이야,,, 희한한거 많이 추가되었네???
세상 좋아졌구만,
