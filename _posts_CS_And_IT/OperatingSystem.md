---
layout: post
title: Operating system
---

## Operating system

운영체제(OS, operating System)는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스입니다.

> 한정된 메모리나 시스템 자원을 효율적으로 분배하는 참된 일꾼입니다. 
> 
> 참고로 운영체제와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것을 펌웨어(firmware)라고 합니다.
> 
> "면접을 위한 CS전공지식 노트"

<details><summary>운영체제의 역활과 구조</summary>
<div markdown="1">

운영체제의 역활은 크게 네 가지가 있습니다.

1. CPU 스케줄링과 프로세스 관리
    - CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리합니다.
2. 메모리 관리
    - 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리합니다.
3. 디스크 파일 관리
    - 디스크 파일을 어떠한 방법으로 보관할지 관리합니다.
4. I/O 디바이스 관리
    - I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.

</div></details>

<details><summary>운영체제의 구조</summary>
<div markdown="1">

유저 프로그램이 맨 위에 있고 그 다음으로 GUI, 시스템콜, 커널, 드라이버가 있으며 가장 밑에 하드웨어가 있는 구조입니다.

* GUI, 시스템콜, 커널, 드라이버 부분이 바로 운영체제를 지칭합니다.
* 참고로 GUI가 없고 CUI만 있는 리눅스 서버도 있습니다.

![운영체제의 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS3U2H%2FbtqHxbOhB2V%2FWeQANBQKfm6F58xkWsJZy0%2Fimg.png)

* GUI는 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태입니다. 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 해줍니다.
* 드라이버는 하드웨어를 제어하기 위한 소프트웨어입니다.
* CUI는 그래픽이 아닌 명령어로 처리하는 인터페이스 입니다.

이때 

</div></details>

<details><summary>시스템콜</summary>
<div markdown="1">

시스템콜이란 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 씁니다.

유저 프로그램이 I/O 요청으로 트랩(trap)을 발동하면 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행됩니다.

예를 들어 I/O 요청인 fs.readFile()이라는 파일 시스템의 파일을 읽는 함수가 발동했다고 해봅시다.

![운영체제](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJXwNG%2Fbtqw787Kgfe%2FvmrkitiEEjDI8G9w2mFzUk%2Fimg.png)

이때 유저 모드에서 파일을 읽지않고 커널 모드로 들어가 파일을 읽고 다시 유저 모드로 돌아가 그 뒤에 있는 유저 프로그램의 로직을 수행합니다. 이 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단 할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있습니다.

* I/O요청이란 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일
* 드라이버는 하드웨어를 제어하기 위한 소프트웨어

프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때 시스템콜이라는 인터페이스와 커널을 거쳐 운영체제에 전달됩니다.

이 시스템콜은 하나의 추상화 계층입니다. 그렇기 때문에 이를 통해 네트워크 통신이나 데이터베이스와 같은 낮은 단계의 영역 처리에 대한 부분을 많이 신경 쓰지 않고 프로그램을 구현할 수 있는 장점이 있습니다.

**modebit**

시스테콜이 작동될 때 modebit을 참고해서 유저 모드와 커널 모드를 구분합니다. modebit은 1또는 0의 값을 가지는 플래그 변수입니다. 카메라, 키보드 등 I/O 디바이스는 운영체제를 통해서만 작동해야 합니다. 

카메라를 켜는 프로그램이 있다고 해봅시다. 만약 유저 모드를 기반으로 카메라가 켜진다면, 사용자가 의도하지 않았는데 공격자가 카메라를 갑자기 켤 수 있는 등 나쁜 짓을 하기가 쉽습니다.

물론 커널 모드를 거쳐 운영체제를 통해 작동한다고 해도 100% 막을 수는 없지만 운영체제를 통해 작동하게 해야 막기가 쉽습니다. 이를 위한 장치가 바로 modebit입니다. modebit의 0은 커널 모드, 1은 유저 모드라고 설정되며, 유저 모드일 경우에는 시스템콜을 못하게 막아서 한정된 일만 가능하게 합니다.

앞의 그림처럼 유저 프로그램이 카메라를 이용하려고 할 때 시스템콜을 호출하고 modebit을 1에서 0으로 바꾸면 커널 모드로 변경한 후 카메라 자원을 이용한 로직을 수행합니다. 그 이후에 modebit을 0에서 1로 바꿔서 유저 모드로 변경하고 이후 로직을 수행합니다.

* 유저 모드는 유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하는 모드입니다.
* 커널 모드는 모든 컴퓨터 자원에 접근할 수 있는 모드입니다.
* 커널은 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역활을 합니다.

</div></details>

<details><summary>시스템콜은 왜 필요할까?</summary>
<div markdown="1">

우리가 일반적으로 사용하는 프로그램은 `응용 프로그램`입니다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 때문에, 커널(kernel)의 도움을 반드시 받아야 합니다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행할 수 없습니다. 반드시 Kernel에 관련된 것은 커널모드로 전환한 후에야, 해당 작업을 수행할 권한이 생깁니다. 커널 모드를 통한 이러한 작업은 반드시 시스템콜을 통해 수행하도록 설계되어 있습니다. 아래 그림(1.13)을 살펴보면 이해가 빠를 것입니다.

그렇다면 권한은 왜 필요한 것일까? 의문이 생길 수 있습니다. 그 이유는 해커가 피해를 입히기 위해 악의적으로 시스템콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문입니다. 따라서 이러한 명령어들은 특별하게 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 유저 모드에서 시스템 콜을 호출할 경우에는 운영체제에서 불법적인 접근이라 여기고 trap을 발생시킵니다.

</div></details>

<details><summary>시스템 콜 예시</summary>
<div markdown="1">

```
cp in.txt out.txt
```

일반적으로 윈도우 운영체제라면 마우스가, 리눅스라면 키보드가 사용자로부터 입력을 받는데 이때 I/O 시스템콜을 사용합니다. 위와 같은 문장을 입력을 받아서 'cp'프로그램을 실행시키면 먼저 'in.txt'파일이 현재 디렉터리에서 접근할 수 있는 파일인지를 검사하기 위해 시스템 콜을 호출합니다.

만약 파일이 존재하지 않는다면 애러를 발생시켜야 하고, 프로그램을 종료하는데 이때 시스템콜이 사용됩니다.

만약 파일이 존재한다면, 복사한 파일을 저장하기 위해 'output.txt'파일명이 있는지 검사합니다. 그리고 이 때도 마찬가지로 이 파일 명이 존재하는지 존재하지 않는지 검사하기 위해 시스템 콜을 통해 확인합니다.

그리고 만약 파일 명이 이미 존재한다면, 덮어 씌워야 할지 아니면, 이어서 붙여야 하는지 User에게 물어볼 수 있습니다. 만약 저장하고자 하는 파일 이름이 겹치지 않다면, 파일을 저장해야 하는데 이 때도 시스템 콜을 이용합니다.

![시스템콜](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAPjla%2Fbtqw7Qe9Ppa%2FFhpxhmnirEN1k63R6Qr3nk%2Fimg.png)

텍스트를 복사하는 간단한 프로그램임에도 불구하고, 상당히 많은 시스템 콜이 발생함을 알 수 있습니다.

</div></details>

<details><summary>시스템 콜의 종류</summary>
<div markdown="1">

아래는 UNIT의 시스템콜의 종류입니다.

* 프로세스 컨트롤
    * 프로세스 생성 및 종료
    * 메모리에 로드, 실행
    * 프로세스 속성 값 확인, 지정
    * wait 이벤트, signal 이벤트
    * 메모리 할당

* 파일 메니지먼트
    * 파일 생성, 파일 삭제
    * 열기, 닫기
    * 읽기, 쓰기, Reposition
    * 파일 속성 값 확인, 지정

* 디바이스 매니지먼트
    * 디바이스 요청 및 해제
    * 읽기, 쓰기, Reposition
    * 디바이스 속성 확인, 지정
    * 비 물리적인 디바이스 해제 및 장착

* 정보 관리
    * 시간 확인, 시간 지정
    * 시스템 데이터 확인, 지정
    * 프로세스, 파일, 디바이스 속성 가져오기
    * 프로세스, 파일, 디바이스 속성 설정하기

* 커뮤니케이션
    * 커뮤니케이션 연결 생성 및 삭제
    * 메시지 송신, 수신
    * 상태 정보 전달
    * remote 디바이스 해제 및 장착

* 보안
    * Permission 흭득
    * Permission 설정

</div></details>

## CPU 구조

CPU(Central Processing Unit)는 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치를 말하며, 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 핵서해서 실행합니다.

운영체제의 커닐이 프로그램을 메모리에 올려 프로세스로 만들면 일꾼인 CPU가 이를 처리합니다.

* CPU는 명령어를 해석, 연산, 그 결과를 저장하는 등의 수행을 하는 유닛을 말합니다.

![CPU 이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F380Mt%2Fbtq49R5Ol13%2FE6ue4DRtUgJYJJuykkSSPK%2Fimg.png)

* 제어장치(CU, Control Unit)는 프로세스 조작을 지시하는 CPU의 한 부품입니다. 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.
* 레지스터는 CPU안에 있는 매우 빠른 임시기억장치를 가리킵니다. CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠릅니다. CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달합니다.
* 산술논리연산장치(ALU, Arithmetic Logic Unit)는 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로입니다.

<details><summary>코어란?</summary>
<div markdown="1">

코어는 CPU 역활을 수행하는 블록이며 블록이란 것으 물리적인 단위를 뜻합니다. 한 개의 CPU 칩 안에 한개의 코어를 가지는 것을 일반적으로 알고 있는 싱글코어라 불리며, 한 개의 CPU 칩 안에 복수개의 코어를 가지는 것을 멀티코어라 하며 코어 개수에 따라 접두사(prefix)가 달라집니다.

</div></details>

<details><summary>코어의 요소</summary>
<div markdown="1">

**제어 장치(CU, Control Unit)**

제어 장치는 메모리에서 명령을 가져와 명령어 해독과 해독된 명령어 실행을 지시하는 핵심 장치입니다.

제어장치(CU, Control Unit)는 프로세스 조작을 지시하는 CPU의 한 부품입니다. 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.

**연산 장치(산술논리연산장치, ALU, Arithmethic Login Unit)**

제어 장치의 지시를 받아 산술, 논리, 비트 연산등의 실제 연산을 수행하는 장치입니다.

산술논리연산장치(ALU, Arithmetic Logic Unit)는 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 베타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로입니다.

**기억장치 (Register)**

제어, 연산 장치 등에서 사용하는 임시 기억 장치의 역활을 수행한다. 종류는 다음과 같습니다.

레지스터는 CPU안에 있는 매우 빠른 임시기억장치를 가리킵니다. CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠릅니다. CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달합니다.

* PC(Program Counter)는 다음 인출(Fetch)될 명령어의 주소를 가지고 있는 레지스터입니다.
* AC(Accumulator)는 연산 결과 데이터를 일시적으로 저장하는 레지스터입니다.
* IR(Instruction Register)는 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터입니다.
* SR(Status Register)는 현재 CPU의 상태를 가지고 있는 레지스터입니다.
* MAR(Memory Address Register)는 PC에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터입니다.
* MBR(Memory Buffer Register)는 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터입니다.

</div></details>

<details><summary>인터럽트</summary>
<div markdown="1">

인터럽트는 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말합니다. 키보드, 마우스 등 IO디바이스로 인한 인터럽트, 0으로 숫자를 나누는 산술 연산에서의 인터럽트, 프로세스 오류 등으로 발생합니다.

인터럽트가 발생되면 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행됩니다.

인터럽트 간에는 우선순위가 있고 우선순위에 따라 실행되며 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트 두 가지로 나뉩니다.

* 인터럽트 핸들러 함수
    - 인터럽트가 발생했을 때 이를 핸들링하기 위한 함수, 커널 내부의 IRQ를 통해 호출되며 request_irq()를 통해 인터럽트 핸들러 함수를 등록할 수 있습니다.

**하드웨어 인터럽트**

하드웨어 인터럽트는 키보드를 연결한다거나 마우스를 연결하는 일 등의 IO디바이스에서 발생하는 인터럽트를 말합니다.

이때 인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행합니다.

**소프트웨어 인터럽트**

소프트웨어 인터럽트는 트랩(trap)이라고도 합니다. 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동합니다.

</div></details>

<details><summary>캐시 메모리란?</summary>
<div markdown="1">

코어 내 레지스터는 메인 메모리(RAM)에서 데이터를 읽어 올 수 있지만 메인 메모리는 레지스터 보다 상대적으로 속도가 느리기 때문에 병목현상이 발생할 수 있습니다. 이 속도 차이를 극복하기 위해 사용되는 것이 캐시 메모리입니다.

캐시 메모리 또한 종류가 나뉘는데 L1 Cache는 코어 간 독립적으로 가지며 코어 내 레지스터로 부터 읽히고 쓰이는데 사용됩니다. 그리고 L2 Cache는 L1 Cache간 공유되어 읽히고 쓰이는데 사용됩니다. L3 Cache역시 L2 Cache들로부터 읽히고 쓰이는데 사용됩니다.

* 코어내 레지스터와 메인 메모리간 속도 차이를 극복하고자 중간에 캐시 메모리를 두는 것 입니다.

![코어와 메인 메모리의 중간 메모리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmlFSV%2Fbtq44O3jOiZ%2F4f1Arc048UHdYBjQhJnvQ0%2Fimg.png)

</div></details>

<details><summary>DMA 컨트롤러</summary>
<div markdown="1">

DMA 컨트롤러는 I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치를 뜻합니다. CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며 CPU의 일을 부담하는 보조 일꾼이라고 보면 됩니다. 또한, 하나의 작업을 CPU와 DMA컨트롤러가 동시에 하는 것을 방지합니다.

</div></details>

<details><summary>메모리</summary>
<div markdown="1">

메모리(memory)는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치를 말하며, 보통 RAM(Random Access Memory)을 일컬어 메모리라고도 합니다. CPU는 계산을 담당하고, 메모리는 기억을 담당합니다.

> 공장에 비유하자면 CPU는 일꾼이고, 메모리는 작업장이며, 작업장으 크기가 곧 메모리의 크기입니다. 작업장이 클수록 창고에서 물건을 많이 가져다놓고 많은 일을 할 수 있듯이 메모리가 크면 클수록 많은 일을 동시에 할 수 있습니다.

</div></details>

<details><summary>타이머</summary>
<div markdown="1">

타이머(timer)는 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역활을 합니다. 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재합니다.

</div></details>

<details><summary>디바이스 컨트롤러</summary>
<div markdown="1">

디바이스 컨트롤러(device controller)는 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU를 말합니다.

</div></details>

<details><summary>클럭 (Clock)</summary>
<div markdown="1">

클럭이라는 수치는 CPU 내부에서 일정한 주파수를 가지는 신호로, 이 신호에 동기화되어 CPU의 모든 명령어가 동작하게 됩니다. 클럭 수가 2.0GHZ라면 초당 20억 번의 명령어를 처리할 수 있다는 의미입니다.

</div></details>

## 커널

<details><summary>커널 주소 공간의 내용</summary>
<div markdown="1">

**Code 영역**

* 시스템 콜, 인터럽트 처리 코드
* CPU, 메모리 등 자원 관리를 위한 코드
* 편리한 인터페이스 제공을 위한 코드

**Data 영역**

* PCB(Process Controll Block)은 현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조
* CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장

**Stack 영역**

* 각 Process의 커널 스택을 저장
    - 프로세스는 함수 호출시 자신의 복귀 조스를 저장하지만, 커널은 커널 내의 주소가 됩니다.
    - 각각의 프로세스마다 별도의 스택을 두어 관리합니다.

</div></details>

<details><summary>커널은 힙 메모리가 없는건가요?</summary>
<div markdown="1">

먼저 커널이 무엇인지 정확하게 짚고 넘어가야 합니다. 커널(kernel)은 Linux 운영 체제(OS)의 주요 구성 요소이며 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스입니다. 그리고 두 가지 관리 리소스에서 최대한 효과적으로 통신합니다

`커널 == 운영체제`가 아니라, 커널은 운영체제의 주요 구성 요소입니다. 리눅스로 예를 들어 설명하면, 커널은 메모리 관리, 프로세스 관리, 하드웨어와 프로세스 사이에서 인터프리터 역활을 수행하거나 시스템의 호출이나 보안등의 기능을 수행합니다 즉, 리눅스에서 (다른 OS는 다를 수 있습니다.) 커널은 하나의 프로세스가 아니라 컴퓨터 하드웨어와 프로세스를 잇는 인터페이스로 보아야 합니다.

커널은 힙메모리를 사용하지 않습니다. 커널은 운영체제(리눅스)에서 동 메모리 할당을 위해 필요한 기능들을 커널이 제공합니다. 운영체제는 커널에서 제공하는 기능을 사용해서 메모리 풀(memory pool)을 관리합니다.

</div></details>

## 메모리 (memory)

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있습니다.

<center><div markdown="1">

![Computer Memory Hiearachy](https://velog.velcdn.com/images/yu-jin-song/post/76e33966-4b59-4f77-9887-f2f332ec072b/pngwing.com.png)

</div></center>

* 레지스터는 CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적습니다.
* 캐시는 L1, L2캐스를 지칭합니다. 휘발성, 속도 빠름, 기억 용량이 적습니다. 참고로 L3 캐시도 있습니다.
* 주기억장치는 RAM을 가리킵니다. 휘발성, 속도 보통, 기억 용량이 보통입니다.
* 보조기억장치는 HDD, SDD를 일컬으며 휘발성, 속도 낮음, 기억 용량이 많습니다.

램(RAM)은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달하는 역활을 합니다. 계층 위로 올라갈수록 가격은 비싸지는데 용량은 작아지고 속도는 빨라지는 특징이 있습니다.

<details><summary>캐시</summary>
<div markdown="1">

캐시(cache)는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말합니다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있습니다.

실제로 메모리와 CPU사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결합니다. 이렇게 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 합니다. 예를 들어 캐시 메모리와 보조기억장치 사이에 있는 주기억장치를 보조기억장치의 캐싱계층이라고 할 수 있습니다.

**지역성의 원리**

자주 사용하는 데이터에 대한 근거가 되는 것은 지역성입니다. 지역성은 시간 지역성(temporal locality)과 공간 지역성(spatial locality)로 나눠집니다.

**시간 지역성**

시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성을 말합니다.

**공간 지역성**

공간 지역성은 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말합니다.

</div></details>

<details><summary>캐시히트와 캐시미스</summary>
<div markdown="1">

캐시에서 원하는 데이터를 찾았다면 캐시히트라고 하며, 해당 데이터가 캐시에 업다면 주 메모리로 가서 데이터를 찾아오는 것을 캐시미스라고 합니다.

캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 됩니다. 캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠릅니다. 반면에 캐시미스가 발생되면 메모리에서 가져오게 되는데, 이는 시스템 버스를 기반으로 작동하기 때문에 느립니다.

**캐시매핑**

캐시매핑이란 캐시가 히트되기 위해 매핑하는 방법을 말하며 CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때는 기반으로 설명합니다. 레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역활을 잘 해주려면 이 매핑을 어떻게 하느냐가 중요합니다.

|이름|설명|
|:-:|---|
|직접 매핑(directed mapping)|메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20... 이런 식으로 매핑하는 것을 말합니다. 처리가 빠르지만 충돌 발생이 잦습니다.|
|연관 매핑(associative mapping)|순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑합니다. 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느립니다.|
|집합 연관 매핑(set associative mapping)|직접 매핑과 연관 매핑을 합쳐 놓은 것입니다. 순서는 일치시키만 집합을 둬서 저장하며 블록화되어 있기 때문에 검색은 좀 더 효율적입니다. 예를 들어 메모리가 1~100이 있고 캐시가 1~10이 있다면 캐시 1~50의 데이터를 무작위로 저장하는 것을 말합니다.|


</div></details>

<details><summary>메모리 관리</summary>
<div markdown="1">

운영체제의 대표적인 할 일 중 하나가 메모리 관리입니다. 컴퓨터 내의 한정된 메모리를 극한으로 활용해야 하는 것입니다.

가상 메모리(virtual memory)는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말합니다.

이때 가상적으로 주어진 주소를 가상 주소(logical address)라고 하며, 실제 메모리상에 있는 주소를 실제 주소(physical address)라고 합니다. 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요 없이 프로그램으 구축할 수 있게 됩니다.

* TLB는 메모리와 CPU사이에 있는 주소 변환을 위한 캐시입니다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층입니다.

</div></details>

<details><summary>스와핑</summary>
<div markdown="1">

만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생합니다. 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것을 스와핑(swapping)이라고 합니다.

</div></details>

<details><summary>페이지 폴트</summary>
<div markdown="1">

페이지 폴트(page fault)란 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생합니다. 이때 운영체제는 다음 과정으로 해당 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 거서럼 츠로그램이 작동하게 해줍니다.

페이지 폴트와 그로 인한 스와핑은 다음 과정으로 이루어집니다.

1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체젱 알립니다.
2. 운영체제는 CPU의 동작을 멈춥니다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾습니다. 물리 메모리에도 없다면 스와핑이 발동됩니다.
4. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화합니다.
5. 중단되었던 CPU를 다시 시작합니다.

* 페이지(page)는 가상 메모리를 사용하는 최소 크기 단위입니다.
* 프레임(frame)은 실제 메모리를 사용하는 최소 크기 단위입니다.

</div></details>

<details><summary>스레싱</summary>
<div markdown="1">

스레싱(thrashing)은 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능저하를 초래합니다.

스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나느 것입니다. 페이지 폴트가 일어나면 CPU 이용률이 낮아집니다.

</div></details>

<details><summary>작업 세트(working set)</summary>
<div markdown="1">

작업 세트(working set)는 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것입니다. 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있습니다.

</div></details>

<details><summary>PFF(Page Fault Frequency)</summary>
<div markdown="1">

PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법입니다. 만약 상한선에 도달한다면 페이지를 늘리고 하한선에 도달한다면 페이지를 줄이는 것입니다.

</div></details>

## 프로그램 (Program)

컴퓨터에서의 `프로그램`은 사용자가 원하는 일을 처리할 수 있도록 프로그래밍 언어를 사용하여 올바른 수행절차를 표현해 놓은 명령어들의 집합입니다. 그에 필요한 데이터를 묶어 놓은 파일로 보조 기억장치에 저장되어 있습니다.

* `예로 Windows의 경우 exe파일입니다.`
* 컴퓨터에서 어떤 작업을 위해 실행할 수 있는 '정적인 상태'의 파일 이라고 볼 수 있습니다.

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행할 수 있는 파일이 되는 것을 의미합니다.

<details><summary>컴퓨터 프로그램</summary>
<div markdown="1">

[computer program](https://en.wikipedia.org/wiki/Computer_program)

컴퓨터 프로그램은 컴퓨터가 실행할 수 있는 프로그래밍 언어의 명령 시퀀스 또는 집합입니다. 컴퓨터 프로그램은 문서 및 기타 무형 구성요도 포함하는 소프트웨어의 한 구성 요소입니다.

사람이 읽을 수 있는 형태의 컴퓨터 프로그램을 소스 코드라고 합니다. 컴퓨터는 기본 기계 명령만 실행할 수 있기 떄문에 소스 코드를 실행 하려면 다른 컴퓨터 프로그램이 필요합니다. 따라서 소스코드는 언어의 컴파일러를 사용하여 기계 명령어로 번역될 수 있습니다.

* 기계어 프로그램은 어셈블러를 사용하여 번역됩니다.

결과 파일을 실행파일이라고 합니다. 또는 소스 코드가 언어의 인터프리터 내에서 실행될 수 있습니다.

실행 파일의 실행이 요청되면 운영체제는 이를 메모리에 로드하고 프로세스를 시작합니다. 중앙 처리 장치는 곧 이 프로세스로 전환하여 각 기계명령을 가져오고 디코딩한 다음 실행할 수 있습니다.

실행을 위해 소스 코드가 요청되면 운영체제는 해당 인터프리터를 메모리에 로드하고 프로세스를 시작합니다. 다음 인터프리터는 소스 코드를 메모리에 로드하여 각 명령문을 번역하고 실행합니다. 소스 코드를 실행하는 것은 실행 파일을 실행하는 것보다 느립니다. 또한 인터프리터가 컴퓨터에 설치되어 있어야 합니다.

![프로그램 실행](https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Concepts-_Program_vs._Process_vs._Thread.jpg/1024px-Concepts-_Program_vs._Process_vs._Thread.jpg)

</div></details>

<details><summary>프로그래밍(Programming)</summary>
<div markdown="1">

프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미합니다. 이렇게 작성된 프로그램은 먼저 실행 파일(executable file)로 변환되어야 실행할 수 있습니다.

<center><div markdown="1">

![소스파일](http://www.tcpschool.com/lectures/img_c_programming.png)

</div></center>

1. 소스 파일(source file)의 작성
2. 선행처리기(preprocessor)에 의한 선행처리
3. 컴파일러(compiler)에 의한 컴파일
4. 링커(linker)에 의한 링크
5. 실행 파일(executable file)의 생성

프로그래밍에서 가장 먼저 해야 할 작업은 바로 프로그램을 작성하는 것 입니다.

선행처리(preprocess)란 소스 파일 중에서도 선행처리 문자(#)로 시작하는 선행처리 지시문의 처리 작업을 의미합니다. 이러한 선행처리 작업은 선행처리기(preprocessor)가 수행합니다. 선행처리기는 코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역활만을 합니다.

컴퓨터는 0과 1로 이루어진 이진수로 작성된 기계어만을 이해할 수 있습니다. 소스 파일은 개발자에 의해 C언어로 작성되므로, 컴퓨터는 그것을 바로 이해할 수 없습니다. 따라서 소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 컴파일(compile)이라고 합니다.

컴파일은 컴파일러에 의해 수행되며, 컴파일이 끝나 기계어로 변환된 파일을 오브젝트 파일(object file)이라고 합니다.이러한 오브젝트 파일의 확장자는 .o나 .obj가 됩니다.

컴파일러에 의해 생성된 오브젝트 파일은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않습니다. 또한, 대부분의 C프로그램에서 사용하는 C표준 라이브러리 파일도 포함되어 있지 않습니다.

이때 하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 링크(link)라고 합니다.

링크는 링커(linker)에 의해 수행되며, 링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성됩니다. 이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의 실행 파일로 만드는 것을 분할 컴파일이라고 합니다.

<details><summary>분할 컴파일</summary>
<div markdown="1">

[분할 컴파일](http://www.tcpschool.com/c/c_complie_module)

모듈(module)이란 프로그램을 구성하는 구성 요소로, 관련된 데이터와 함수를 하나로 묶은 단위를 의미합니다.

보통 하나의 소스 파일에 모든 함수를 작성하지 않고, 함수의 기능별로 따로 모듈을 구성합니다. 이처람 모듈을 합쳐 하나의 파일로 작성하는 방식으로 프로그램을 만들게 됩니다.

위처럼 프로그램 코드를 기능별로 나눠서 독립된 파일에 저장하여 관리하는 방식을 모듈화 프로그래밍이라 합니다.

**분할 컴파일**

작성된 모듈(module)은 개별적으로 컴파일된 후, 링커에 의해 하나의 실행 파일로 만들어집니다. 이렇게 하나의 실행 파일을 만들기 위해서 소스 파일을 여러 개로 나누어 개발하는 방식을 분할 컴파일 방식이라 합니다.

<center><div markdown="1">

![분할 컴파일](http://www.tcpschool.com/lectures/img_c_compile_module.png)

</div></center>

최종적인 실행 파일의 생성을 위해서 접근하는 변수나 호출하는 함수가 어디에 있는지 서로 연결해주는 작업을 링크(link)라고 합니다.

* extern 키워드는 분할 컴파일 방식에서 여러 개의 소스 파일 사이의 상호 참조는 전역 변수와 전역 함수만이 가능합니다. 기본적으로 C컴파일러는 프로그램에 등장하는 전역 변수를 오로지 해당 파일에서만 찾습니다. 따라서 외부 파일에서 참조하는 전역 변수는 컴파일러에게 외부 파일에 존재하는 변수라는 사실을 알려줍니다.
* static 키워드는 분할 컴파일 방식에서 변수의 접근 영역을 해당 파일로만 한정시키고자 할 때는 static키워드를 사용하여 선언하면 됩니다. 이렇게 선언된 변수는 다른 소스 파일에서 extern키워드를 사용해 선언하더라도 접근할 수 없는 전역 변수가 됩니다.

</div></details>

</div></details>

<details><summary>프로세스와 컴파일 과정</summary>
<div markdown="1">

프로세스는 프로그램으로부터 인스턴스화된 것을 말합니다. 에를 들어 프로그램은 구글 크롬 프로그램(chrome.exe)과 같은 실행 파일이며, 이를 두번 클릭하면 구글 크롬 '프로세스'가 시작되는 것 입니다.

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는 파일이 되는 것을 의미하며 '컴파일 과정'이란 다음과 같습니다. 참고로 여기서 말하는 프로그램이란 C언어 기반의 프로그램을 의마하며, 이는 별도의 컴파일 과정 없이 한 번에 한 줄씩 읽어들여서 실행하는 프로그램인 인터프리터 언어로 된 프로그램과는 다릅니다.

1. 선행처리기(pre-processor)에 의한 선행처리
2. 컴파일러(compiler)에 의한 컴파일
3. 링커(linker)에 의한 링크
4. 실행 파일(executable file)의 생성

**선행처리기(전처리, pre-processing)**

전처리는 
1. 소스 코드의 주석을 제거하고,
2. #include지시문을 만나면 해당하는 헤더 파일을 찾아 헤더 파일에 있는 모든 내용을 복사해서 소스 코드에 삽입합니다.
    - 즉, 헤더 파일은 컴파일에 사용되지 않고 소스 코드 파일 내에 전부 복사됩니다. 헤더 파일에 선언된 함수 원형은 후에 링킹 과정을 통해 실제로 함수가 정의되어 있는 오브젝트 파일(컴파일된 소스 코드 파일)과 결합합니다.
3. 매크로 치환 및 적용합니다. #define 지시문에 정의된 매크로를 저장하고 같은 문자열을 만나면 #define된 내용으로 치환합니다. 간단하게 말해 매크로 이름을 찾아서 정의한 값으로 전부 바꿔줍니다.

**컴파일(Compilation)과정**

컴파일(Compilation)과정은 컴파일러(Compiler)를 통해 전처리된 소스 코드 파일(*.i)을 어셈블리어 파일 (*.s)로 변환하는 과정입니다.

이 과정에서 우리가 일반적으로 컴파일하면 생각하는 언어의 문법 검사가 이루어집니다. 또한 static한 영역(Data, BSS영역)들이 메모리 할당을 수행합니다.

* 컴파일러는 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환합니다.

<details><summary>컴파일러 구조</summary>
<div markdown="1">

컴파일러는 세 단계(프론트 엔드 - 미들 엔드 - 백 엔드)로 구성되어 있습니다.

<center><div markdown="1">

![컴파일러 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRsK26%2FbtrdqL3NcDd%2FEYkqxQc7xVKL07pv8mQNSK%2Fimg.png)

</div></center>

**프론트엔드(Front-end)**

프론트엔드에서는 언어 종속적인 부분을 처리합니다.

소스 코드가 해당 언어로 올바르게 작성되었는지 확인하고 미들엔드에 넘겨주기 위한 GIMPLE 트리(소스 코드를 트리 형태로 표현한 자료 구조)를 생성합니다.

이 과정에서 C, C++, Java와 같은 다양한 언어들이 각 언어에 맞게 처리된 후 공통된 중간 표현인 GIMPLE 트리로 변환되므로 언어 종속적인 부분을 처리할 수 있습니다.

**미들엔드(Middle-end)**

미들엔드에서는 아키텍쳐 비종속적인 최적화를 수행합니다.

아키텍쳐 비종속적인 최적화란 CPU아키텍쳐가 무엇이든(arm, x86 등) 상관없이 할 수 있는 최적화를 말합니다. 프론트엔드에서 넘겨받은 GIMPLE 트리를 이용해 아키텍쳐 비종속적인 최적화를 수행한 후 백엔드에서 사용하는 RTL(Register Transfer Language, 고급 언어와 어셈블리 언어의 중간 형태)를 생성합니다.

**백엔드(Back-end)**

백엔드에서는 아키텍쳐 종속적인 최적화를 수행합니다.

아키텍쳐 종속적인 최적화란 아키텍쳐 특성에 따라 최적화를 수행하는 것을 말합니다. 같은 기능을 수행하는 명령이여도 CPU 아키텍쳐별로 더욱 효율적인 명령어로 대체하여 성능을 높이는 작업을 예를 들 수 있습니다.

미들엔드에서 넘겨받은 RTL을 이용해 아키텍쳐 종속적인 최적화를 수행하고 최적화가 완료되면 어셈블리 코드를 생성합니다.

아키텍쳐 종속적인 최적화를 수행하면 해당 아키텍쳐만 이해할 수 있는 언어가 되기 때문에 아키텍쳐가 맞지 않으면 어셈블리 코드를 해석할 수 없습니다.

**어셈블리어 정의**

기계어는 다른 말로 명령어(Machine Instruction)이라고 부르는데 명령어는 0101010과 같은 이진수로 이뤄진 숫자로 CPU종류마다 고유한 내용을 가지고 있습니다.

어셈블리어는 이런 명령어를 사람이 이해할 수 있게 부호화한 것으로 CPU 명령어(기계어)와 1대1로 매칭됩니다.

많은 컴파일러가 앞서 설명한 세 단계의 구조를 따르고 있지만, 컴파일러마다 차이가 존재한다.

* GNU에서 만든 C 컴파일러인 gcc는 프론트엔드/미들엔드/백엔드 단계가 깔끔하게 분리되어 있지 않고 의존성이 존재합니다.
* 그에 비해 오픈 소스 C 컴파일러인 Clang(프론트엔드) + LLVM(미들엔드, 백엔드)는 단계가 잘 분리되어 있습니다.

</div></details>

**어셈블리(Assembly)과정**

<center><div markdown="1">

![어셈블리 과정](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fsz3Fu%2FbtrdqSBMnid%2Fqb4T0MZXpliiZ2xfFtuLM0%2Fimg.png)

</div></center>

어셈블리(Assembly)과정은 어셈블러(Assembler)를 통해 어셈블리어 파일(*.s)을 오브젝트 파일(*.o)로 변환하는 과정입니다.

**오브젝트 파일(Object file) 정의**

어셈블리 코드는 이제 더 이상 사람이 알아볼 수 없는 기계어로 변환되는데 이를 오브젝트 코드(Object code, 목적 코드)라 부릅니다.

오브젝트 코드로 구성된 파일을 오브젝트 파일(Object File)이라 부르며 이 오브젝트 파일은 특정한 파일 포맷을 가집니다.

* 오브젝트 파일 포맷의 종류는 Windows의 경우 PE(Protable Executable), Linux의 경우 ELF(Executable and Linking Format)로 나눠집니다.

**오브젝트 파일 포맷(Object File Foramt)**

![오브젝트 파일 포멧](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtMFGd%2Fbtrdon37ct9%2FRng1Ns2LqARYZmKe0tTpG0%2Fimg.png)

오브젝트 파일 헤더(Object File Header)는 오브젝트 파일의 기초 정보를 가지고 있는 헤더입니다.

텍스트 섹션(Text Section)은 기계어로 변환된 코드가 들어 있는 부분입니다.

데이터 섹션(Data Section)은 데이터(전역 변수, 정적 변수)가 들어 있는 부분입니다.

심볼 테이블 섹션(Symbol Table Section)은 소스 코드에서 참조되는 심볼들의 이름과 주소가 정의 되어 있는 부분입니다.

재배치 정보 섹션(Relocation Information Section)은 링킹 전까지 심볼의 위치를 확정할 수 없으므로 심볼의 위치가 확정 나면 바꿔야 할 내용을 적어놓은 부분입니다.

디버깅 정보 섹션(Debugging Information Section)은 디버깅에 필요한 정보가 있는 부분입니다.

* 링커는 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듭니다. 실행 파일의 확장자는 .exe 또는 .out이라는 확장자를 갖습니다.

**심볼 테이블 섹션과 재배치 섹션**

심볼(Symbol)은 함수나 변수를 식별할 때 사용하는 이름으로 심볼 테이블(Symbol Table) 안에는 오브젝트 파일에서 참조되고 있는 심볼 정보(이름과 데이터의 주소 등)을 가지고 있습니다.

이때 오브젝트 파일의 심볼 테이블에는 해당 오브젝트 파일의 심볼 정보만 가지고 있어야 하기 때문에 **다른 파일에서 참조되고 있는 심볼 정보의 경우 심볼 테이블에 저장할 수 없습니다.**

![코드의 변환](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FevQuzf%2FbtrdmB2FsRq%2F6dqgfHPjFHOXaOjK1JINxK%2Fimg.png)

이 소스 코드 파일을 컴파일하여 오브젝트 파일을 생성할 수 있습니다.

하지만 이 오브젝트 파일은 독립적으로 실행할 수 없습니다. 이 파일 안에는 printf 함수를 구현한 내용이 없기 때문입니다.

전처리 과정을 통해 #include <stdio.h>로부터 printf 함수의 원형은 복사했지만 printf를 구현한 내용은 포함되어 있지 않습니다. 오브젝트 파일 구조에서 말한 것처럼 심볼 테이블에는 해당 오브젝트 파일의 심볼 정보만 가지고 있지 외부에서 참조하는 printf 함수에 대한 심볼 정보는 가지고 있지 않습니다.

즉, 이 오브젝트 파일을 실행하기 위해서는 printf 함수를 사용하는 오브젝트 파일과 printf 함수를 구현한 오브젝트 파일(libc.a 라이브러리)을 연결시키는 작업이 필요합니다.

이러한 연결 과정을 링킹(Linking)이라고 부릅니다.

**링킹(Linking) 과정**

![링킹](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdW1GTK%2FbtrdqLirXQS%2Fupv8Q3omleeiAIGGPlCJdk%2Fimg.png)

링킹(Linking) 과정은 링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어 실행 파일로 만드는 과정입니다.

이 과정에서 오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크하여 하나의 실행 파일을 만듭니다.

이때 라이브러리를 링크하는 방법에 따라 정적 링킹(Static Linking)과 동적 링킹(Dynamic Linking)으로 나눌 수 있습니다.

**링커의 역활**

링커의 역활은 크게 심볼 해석과 재배치로 나눌 수 있습니다.

![링커의 역활](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbt3Zgi%2Fbtrdly6bqc4%2Fdr1x43NX2Qv0QonOYS7Idk%2Fimg.png)

심볼 해석(Symbol Resolution)은 각 오브젝트 파일에 있는 심볼 참조를 어떤 심볼 정의에 연관시킬지 결정하는 과정입니다. 여러 개의 오브젝트 파일에 같은 이름의 함수 또는 변수가 정의되어 있을 때 어떤 파일의 어떤 함수를 사용할지 결정합니다.

재배치(Relocation)는 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소를 알맞게 배치하는 과정입니다. 링커가 컴파일러가 생성한 오브젝트 파일을 모아서 하나의 실행 파일을 만들 때, 각 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소가 링커에 의해 합쳐진 실행 파일에서의 주소와 다르기 때문에 그것을 알맞게 수정해줘야 합니다.

이를 위해 오브젝트 파일 안에 재배치 정보 섹션(Relocation Information Section)이 존재합니다. 링킹 과정에서 같은 세션끼리 합쳐진 후 재배치가 일어납니다.

![재배치](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbwt02u%2Fbtrdr4BPvps%2FlNZWkcxCnSWihTgfTJuOv1%2Fimg.png)

위 그림을 통해 알 수 있듯이 오브젝트 파일 형식은 링킹 과정에서 링커가 여러 개의 오브젝터 파일들을 하나의 실행 파일로 묶을 때 필요한 정보를 효율적으로 파악할 수 있는 구조입니다.

링킹을 하기 전 오브젝트 파일을 재배치 가능한 오브젝트 파일(Relocatable Object File)이라 부르고 링킹을 통해 만들어지는 오브젝트 파일을 실행 가능한 오브젝트 파일(Executable Object File)이라 부릅니다.

</div></details>

## 프로세스(Process)

프로세스(Process)는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰입니다. 프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어납니다. 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행합니다.

> 프로그램이 실행되서 돌아가고 있는 상태, 컴퓨터에서 연속적으로 실행되고 있는 `동적인 상태`의 컴퓨터 프로그램입니다.
> 
> 작업관리창에 표시되어 있는 것들이 동적인 상태의 프로그램입니다.

프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고, 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행합니다.

* 프로세스는 운영체제가 메모리 등의 필요한 자원을 할당해준 `실행중인 프로그램`입니다. 프로그램을 실행하면 운영체제로부터 실행에 필요한 자원을 할당받아 `프로세스`가 됩니다.
* 프로세스가 할당받는 시스템 자원의 예로, CPU 시간, 운영되기 위해 필요한 주소 공간, Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역이 있습니다.

![Operating System](https://velog.velcdn.com/images%2Fgparkkii%2Fpost%2F3ad2bcba-e652-4213-a10c-78b5a13c95b0%2FKakaoTalk_Photo_2021-01-02-18-02-01.jpeg)

프로세스의 특징으로 운영 체제 (Operating System)에서 
1. 프로세스는 각각 Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역을 할당 받습니다.
2. 각 프로세스는 별도의 주소 공간에서 실행되며, 서로 독자적인 메모리 공간을 갖기 때문에 서로 메모리 공간을 공유할 수 없습니다. 즉, 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다.
3. 다른 프로세스의 자원에 접근하려면 프로세스간의 통신(IPC)을 사용해야합니다.
4. 프로세스는 최소 하나 이상의 스레드를 포함합니다.

<details><summary>프로세스의 상태</summary>
<div markdown="1">

프로세스의 상태는 여러 가지 상태 값을 갖습니다.

* 생성 상태
    - 생성 상태(craete)는 프로세스가 생성된 상태를 의미하며 fork()또는 exec()함수를 통해 생성합니다. 이때 PCB가 할당됩니다.
    - `fork()`는 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수입니다. 주소 공간만 복사할 뿐이지 부모 프레스의 비동기 작업 등을 상속하지는 않습니다.
    - `exec()`는 새롭게 프로세스를 생성하는 함수입니다.
* 대기 상태(ready)는 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러부터 CPU 소유권이 넘어오기를 기다리는 상태입니다.
* 대기 중단 상태(ready suspended)는 메모리 부족으로 일시 중단된 상태입니다.
* 실행 상태(running)는 CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미합니다. 이를 CPU burst가 일어났다고도 표현합니다.
* 중단 상태(blocked)는 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태입니다. I/O 디바이스에 의한 이터럽트로 이런 현상이 많이 발생하기도 합니다. 
    - 예를 들어 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯한 때가 바로 그 상태입니다.
* 일시 중단 상태(blocked suspended)는 대기 중단과 유사합니다. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태입니다.
* 종료 상태(terminated)는 메모리와 CPU 소유권을 모두 놓고 가는 상태를 말합니다. 종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제시키는 **비자발적 종료(abort)**로 종료되는 것도 있습니다. 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등 여러 명령어로 프로세스를 종료할 때 발생합니다.

</div></details>

<details><summary>프로세서의 프로세싱</summary>
<div markdown="1">

옛날엔 컴퓨터가 한번에 하나의 동작밖에 수행하지 못했습니다. 하지만 다중 작업을 가능하게하는 멀티태스킹 기능이 나오면서 컴퓨터가 프로세스 여러개를 함께 돌리는 것이 가능해졌습니다.

* 프로세서는 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛입니다. 이는 중앙 처리 장치(CPU)를 뜻하며, 명령어를 해석하는 컴퓨터의 한 부분입니다.
* 멀티 프로세싱은 여러 개의 프로세스를 사용하는 것을 의미합니다.
* 멀티 태스킹은 같은 시간에 여러 개의 프로그램을 띄우는 것 입니다.

</div></details>

<details><summary>동시성(Concurrency)</summary>
<div markdown="1">

프로세서는 원래 한번에 하나의 프로세스만 실행시킬 수 있습니다. 때문에 동시성은 프로세서 하나가 프로그램 1, 2, 3, 4 여러 작업을 돌아가며 일부분씩 수행하는 방식입니다.

이렇게 진행중인 작업을 바꾸는 걸 `Context Switching`이라고 부릅니다. 이 과정이 매우 빠른 속도로 돌아가게 되면서 사람들에게는 이 프로세스들이 동시에 진행되는 것 처럼 보입니다.

</div></details>

<details><summary>병렬성(Parallelism)</summary>
<div markdown="1">

병렬성은 프로세서 하나에 코어 여러개가 달려서 각각 동시에 작업을 하는 방식입니다. 듀얼코어, 쿼드코어, 옥타코어와 같은 명칭의 프로세서가 달린 컴퓨터에서 할 수 있는 방식입니다.

* 코어를 여러개 달아 작업을 분담하게 만든 것 입니다.

</div></details>

<details><summary>프로세스(Process)와 쓰레드(Thread)</summary>
<div markdown="1">

프로세스는 스레드의 컨테이너입니다. 스레드의 정보를 담고있는 것에 불과합니다.

프로세스는 각 작업(Task)마다 운영체제로부터 자원을 할당받기 위해 시스템 콜을 하는 부담이 생기지만 멀티 스레드를 사용한다면 시스템 콜을 한번만 해도 되기 때문에 효율적입니다.

또한 IPC방식보다는 스레드 간 통신이 덜 복잡하고 시스템 자원 사용이 더 적으므로 통신의 부담도 줄일 수 있습니다.

|차이점|프로세스|스레드|
|:-:|:-:|:-:|
|정의|실행중인 프로그램|프로세스의 실행단위|
|생성/종료시간|많은 시간 소요|적은 시간 소요|
|컨텍스트 전환|많은 시간 소요|적은 시간 소요|
|상호작용|IPC사용|공유 메모리 사용|
|자원 소모|많음|적음|
|독립성|각각 독립적|스택만 독립적이고 이외에는 공유|

</div></details>

<details><summary>멀티프로세스와 멀티쓰레드</summary>
<div markdown="1">

**멀티 프로세싱이란**

하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것 입니다.

**멀티 프로세싱의 장점**

여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상이므로 다른 영향이 확산되지 않습니다.

**멀티 프로세스의 단점**

Context Switching과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됩니다.

프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 합니다.

프로세스 사이의 어렵고 복잡한 통신 기법(IPC)으로 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없습니다.

**멀티 스레딩이란**

하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것 입니다.

윈도우, 리눅스 등 많은 웅영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있습니다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램입니다.

**멀티 스레딩의 장점**

시스템의 자원 소모 감소합니다. 즉 자원의 효율성 증대합니다. 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.

시스템 처리량이 증가합니다. 즉 처리 비용 감소합니다. 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 됩니다. 스레드 사이의 작업량이 작아 Context Switching이 빠릅니다.

간단한 통신 방법으로 인한 프로그램 응답 시간 단축합니다. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적습니다.

**멀티 스레딩의 단점**

주의 깊은 설계가 필요합니다. 또한 디버깅이 까다롭습니다. 단일 프로세스 시스템의 경우 효과를 기대하기 여럽습니다. 다른 프로세스에서 스레드를 제어할 수 없습니다. 멀티 스레드의 경우 자원 공유의 문제가 발생합니다. 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받습니다.

**멀티 프로세스 대신 멀티 쓰레드를 사용하는 이유는?**

프로그램을 여러개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더 낫기 때문입니다.

**자원의 효율성 증대**

멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.

스레드는 프로세스 내의 메모리를 공유하고 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 됩니다.

**처리 비용 감소 및 응답 시간 단축**

또한 프로세스 간읜 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.

스레드는 Stack영역을 제외한 모든 메모리를 공유하기 때문에 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠릅니다. Context Switching시 스레드는 Stack 영역만 처리하기 때문입니다.

</div></details>

<details><summary>프로세스의 메모리 구조</summary>
<div markdown="1">

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당합니다.

![프로세스의 메모리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcqk9Wt%2Fbtq9Rehkwfd%2F6QNk4WEKb7O7JR4TvXakvK%2Fimg.png)

프로세스의 주소 공간은 코드(code), 데이터(data), 스택(stack), 힙(heap)영역으로 구성됩니다. 이러한 주소 공간을 우리는 가상 메모리(또는 논리적 메로리: logical memory)라고 부릅니다.

|영역|설명|
|:-:|---|
|Code|사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간입니다. 컴파일(compile)타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-Only로 되어있습니다.|
|Data|전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간입니다. 전역 변수 또는 static 값을 참조한 코드는 컴파일이 완료되면 data 영역의 주소값을 가르키도록 바뀝니다. 전역변수가 변경 될 수도 있어 Read-Write로 되어있습니다.|
|Stack|호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간입니다. <br> 이 영역은 함수 호출시 기록하고 함수의 수행이 완료되면 사라집니다. 메커니즘은 자료구조(stack)에서 배운 LIFO(Last In First Out)방법을 따릅니다. 컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정 할당 할 수 없습니다. 따라서 재귀함수가 반복해서 호출되거나 함수가 지역변수를 메모리를 초과할 정도로 너무 많이 가지고 있다면 stack overflow가 발생합니다.|
|Heap|프로그래머가 필요할 때마다 사용하는 메모리 영역입니다. Heap영역은 런타임에 결정됩니다. <br> 예를 들어 벡터 같은 동적 배열은 당연히 힙에 동적 할당됩니다. 힙은 '동적'인 특징을 가집니다.|

</div></details>

<details><summary>스택(Stack)</summary>
<div markdown="1">

스택에는 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되며 '동적'인 특징을 갖습니다.

스택 영역은 함수가 함수를 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있는데, 이때 힙과 스택의 메모리 영역이 겹치면 안되기 때문에 힙과 스택 사이의 공간을 비워 놓습니다.

</div></details>

<details><summary>데이터 영역(Data)</summary>
<div markdown="1">

데이터 영역은 전역변수, 정적변수가 저장되고, 정적인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어 있는 영역입니다.

데이터 영역은 BSS영역과 Data 영역으로 나뉘고, BSS영역은 초기화가 되지 않은 변수가 0으로 초기화되어 저장되며 DAta 영역(Data segment)은 0이 아닌 다른 값으로 할당된 변수들이 저장됩니다.

</div></details>

<details><summary>코드 영역(Code)</summary>
<div markdown="1">

코드 영역은 프로그램에 내장되어 있는 소스 코드가 들어가는 영역입니다. 이 영역은 수정 불가능한 기계어로 저장되어 있으며 정적인 특징을 가집니다.

</div></details>

<details><summary>힙(Heap)</summary>
<div markdown="1">

힙은 동적 할당할 때 사용되며 런타임 시 크기가 결정됩니다. 예를 들어 벡터 같은 동적 배열은 당연히 힙에 동적할당 됩니다. 힙은 '동적'인 특징을 가집니다.

</div></details>

## 스레드 (Thread)

스레드는 프로세스 내에서 프로세스의 자원을 이용해서 실제로 작업을 수행하는 일꾼입니다. 스레드가 소속된 프로세스가 운영체제로부터 자원을 할당받으면 그 자원을 스레드가 사용합니다.

프로세스는 최소 한 개 이상의 스레드를 가지며 이 스레드를 메인 스레드(main thread)라고 합니다.

* 스레드는 작업을 처리하는 논리적인 단위를 말합니다. 
* 하나의 코어에 보통 하나의 스레드가 존재하는 것이 일반적이지만 하이퍼 스레딩 기술을 이용해 하나의 코어에 두개의 스레드를 사용하여 성능을 높이는 기술도 존재합니다. 이때 운영체제는 코어를 2개로 인식한다고 합니다.
* 스레드는 프로세스의 실행 가능한 가장 작은 단위입니다.
* 프로세스는 여러 스레드를 가질 수 있습니다.
* 추가적으로 프로그래밍 관점에서 멀티스레드 환경의 경우 CPU가 논리적으로 가지는 스레드 개수만큼 병렬적으로 처리가 되지만 CPU가 논리적으로 가지는 스레드 개수보다 초과되어 스레드 작업이 요청되면 논리적인 스레드 개수 이외의 작업들은 동시성으로 처리가 됩니다.
* 스레드(thread)는 프로세스가 할당 받은 자원을 이용하는 실행 단위이지, 프로세스의 특정한 수행 경로이자 프로세스 내에서 실행되는 여러 흐름의 단위입니다.

![Operating System](https://velog.velcdn.com/images%2Fgparkkii%2Fpost%2F5b17f0cb-d2c7-4995-b2dd-f86f58968d2f%2FKakaoTalk_Photo_2021-01-02-18-29-56.jpeg)

코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와는 달리 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유합니다. 그 외의 영역은 각각 생성됩니다.

<details><summary>스레드의 특징</summary>
<div markdown="1">

각 스레드는 독자적인 스택(Stack) 메모리를 갖습니다.

스레드는 프로세스 내에서 각각 스택만 할당받고 Code, Data, Heap 영역은 공유합니다.

스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하며 실행됩니다.

각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있습니다.

한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있습니다.

스레드는 메모리를 공유하기 때문에 동기화, 데드락 등의 문제가 발생 할 수 있습니다.

스레드는 대부분의 현대 운영체제가 지원하고 있으며, 이와 관련된 주요 라이브러리로는 POSIX Pthreads, Windows threads, Java threads가 있습니다.

</div></details>

<details><summary>멀티스레딩</summary>
<div markdown="1">

멀티스레딩은 프로세스 내 작업을 여러 개의 스레드, 멀티 스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높습니다. 예를 들어 웹 요청을 처리할 때 새 프로세스를 생성하는 대신 스레드를 사용하는 웹 서버의 경우 훨씬 적은 리소스를 소비하며, 한 스레드가 중단(blocked)되어도 다른 스레드는 실행(running) 상태일 수 있기 때문에 중단되지 않은 빠른 처리가 가능합니다. 또한, 동시성에도 큰 장점이 있습니다. 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점이 있습니다.

* 동시성은 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것입니다.

</div></details>

<details><summary>공유 자원(shared resource)</summary>
<div markdown="1">

공유 자원은 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미합니다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 합니다. 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 있는 상태를 말합니다.

</div></details>

<details><summary>임계 영역</summary>
<div markdown="1">

공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 임계 영역(critical section)이라고 합니다. 임계 영역을 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 세 가지가 있으며, 이 방법 모두 상호 배제, 한정 대기, 융통성이란 조건을 만족합니다.

이 방법에 토대가 되는 메커니즘은 잠금(lock)입니다. 예를 들어 임계 구역을 화장실이라고 가정하면 화장실에 A라는 사람이 들어간 다음 문을 잠급니다. 그리고 다음 사람이 이를 기다리다 A가 나오면 화장실을 쓸 수 있는 것입니다.

* 상호 배제는 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없습니다.
* 한정 대기는 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안됩니다.
* 융통성은 한 프로세스가 다른 프로세스의 일을 방해해서는 안됩니다.

<details><summary>뮤텍스(mutex)</summary>
<div markdown="1">

뮤텍스는 공유 자원을 사용하기 전에 선정하고 사용한 후에 해제하는 잠금입니다. 잠금이 설정되면 단른 스레드는 잠긴 코드 영역에 접근할 수 없습니다.

또한 뮤텍스는 하나의 상태(잠금 또는 잠금 해제)만 가집니다.

</div></details>

<detials><summary>세마포어(semaphore)</summary>
<div markdown="1">

세마포어는 일반화된 뮤텍스입니다. 간단한 정수 값과 두가지 함수 wait(P 함수라고도 함) 및 signal(V 함수라고도 함)로 공유 자원에 대한 접근을 처리합니다.

wait()는 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수입니다.

프로세스가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고 프로세스가 공유 자원을 해제하면 세마포어에서 signal() 작업을 수행합니다. 세마포어에는 조건 변수가 없고 프로세스가 세마포어 값을 수정할 때 다른 프로세스는 동시에 세마포어 값을 수정할 수 없습니다.

</div></details>

<details><summary>모니터(monitor)</summary>
<div markdown="1">

모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공합니다.

앞의 그림처럼 모니터는 모니터큐를 통해 공유 자원에 대한 작업을 순차적으로 처리합니다.

* 모니터는 세마포어보다 구현하기 쉬우며 모니터에서 상호 배제는 자동인 반면에, 세마포어에서는 상호 배제를 명시적으로 구현해야 하는 차이점이 있습니다.

</div></details>

<details><summary>교착 상태(deadlock)</summary>
<div markdown="1">

교착 상태(deadlock)는 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말합니다. 예를 들어 프로세스 A가 프로세스 B의 어떤 자원을 요청할 때 프로세스 B도 프로세스 A가 점유하고 있는 자원을 요청하는 것입니다.

**교착상태의 원인**

상호 배제는 한 프로세스가 자원을 독접하고 있으며 다른 프로세스들은 접근이 불가능합니다.

점유 대기는 특정 프로세스가 점유한 자원을 다른 프로세스가 오청하는 상태입니다.

비선점은 다른 프로세스의 자원을 강제적으로 가져올 수 없습니다.

환형 대기는 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 말합니다.

**교착 상태의 해결 방법**

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계합니다.
2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능여부를 파악하는 '은행원 알고리즘'을 씁니다.
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지웁니다.
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료합니다. 현대 운영체제는 이 방법을 채택했습니다. 예를 들어 프로세스를 실행시키다 '응답 없음'이라고 뜰 때, 교착상태가 발생한 경우에 이와 같은 경우가 발생하기도 합니다. 

</div></details>