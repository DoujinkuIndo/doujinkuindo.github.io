---
layout: post
title: Fragment
---


# IT 용어
## 레거시 시스템(Legacy System)
레거시 시스템(legacy system)은 낡은 기술이나 방법론, 컴퓨터 시스템, 소프트웨어 등을 말한다. 이는 현대까지도 남아 쓰이는 기술을 부르는 말일 수도 있지만, 더 이상 쓰이지 않더라도 현대의 기술에 영향을 주는 경우도 포함한다.

예를 들어 미국 항공우주국의 스페이스 셔틀은 처음 만들어졌을 때의 기술을 쓴 부품을 계속 써왔다. 안정성 등의 조건을 충족시키면서 부품을 새로 개발하는 것은 너무 비용이 많이 들었기 때문에, 대부분의 부품을 1970년대 기술로 계속 만들어 써온 것이다.

많은 소프트웨어 개발자들이 레거시 시스템을 사용하는 것에 잠재적 문제가 있다고 생각한다. 예를 들어 오래된 하드웨어를 위해 설계된 소프트웨어의 경우, 새로운 하드웨어에서 실행되도록 하기 위해서 에뮬레이션이나 하위 호환성을 구현해줘야 할 수 있다.

[레거시 시스템](https://ko.wikipedia.org/wiki/%EB%A0%88%EA%B1%B0%EC%8B%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C)


## 검사(Verification)
'소프트웨어가 기획서의 요구 사항에 맞게 올바르게 만들어졌는가?'를 확인하는 것

문서와 파일을 검사하는 명세 기반의 확인 방법이다.
개발 단계의 시작 부분에서 부과된 조건을 만족하는지를 확인해 소프트웨어를 평가하는 과정이다.(CMMI-SW v1.1)

## 검증(Validation)
'소프트웨어가 실제 의도한 용도를 충족할 수 있는가?'를 확인하는 것

사용자의 관점에서 확인으로 코드 실행을 수반한다
개발과정 중,또는 끝에 소프트웨어를 평가하는 과정이다.(CMMI-SW v1.1)

## ISA(Industry Standard Architecture)
초기 PC인 IBM PC의 XT 및 AT에서 사용하던, 8비트 또는 16비트 버스 구조 방식

* 버스폭  : 16 비트 단위
* 최대전송속도 : 8 MB/s

* 버스(Bus)란 2 이상의 관련된 시호선들을 모아놓은 것으로 공통 기능을 수행하는 배선 그룹을 말합니다. 회로도 상에서는 보통 굵은 선으로 표시합니다.

! [Bus](http://www.ktword.co.kr/img_data/1249_1.JPG)

* 컴퓨터 버스 구조는 다음과 같습니다.
    - 시스템 버스는 CPU와 노스브리지(north bridge) 칩셋 간의 데이터 통로 입니다. 주로, 컴퓨터 CPU 보드 즉, 인쇄회로기판(PCB)상의 전기적 신호입니다.
    - I/O 버스는 CPU보드와 사우스브리지 칩셋(South bridge, I/O 컨트롤러)을 통한 외부 입출력 장치 간의 버스입니다.

[ISA](http://www.ktword.co.kr/word/abbr_view.php?m_temp1=732)

# Switch문과 if문의 성능 비교

**이와 관련된 자료들은 상당히 오래된 자료들입니다. 알아두기만 합시다.**

switch문이 점프 테이블을 만든다면, 조건이 몇개든 훨씬 빠르게 넘어 갈 수 있습니다.

## switch를 if보다 우선해서 사용해야 합니다.
최악의 경우 컴파일러는 if-else 체인과 동일한 코드를 생성하므로, 아무 것도 잃지 않습니다.

최상의 경우 최적화 프로그램은 코드를 생성하는 더 좋은 방법을 찾을 수 있습니다. 컴파일러가 하는 일반적인 작업은 이진 결정 트리(비교를 저장하고 평균적인 경우 점프)를 작성하거나, 단순히 점프 테이블(비교 없이 작동)을 작성하는 것 입니다.

**함수로 감싸기**
switch를 이용하여 작성할 수 있지만, 다음과 같이 가독성을 더 높일 수 있습니다. 
```cpp
bool IsError(ERROR Error)
{
    return Error | ErrorFlag;
}
```

**더 나아가**
특정 값에 대해 비트를 설정하여, 이용할 수 있습니다. 하지만, 이는 선택사항 입니다.

```cpp
const std::bitset<MAXERR> specialerror(initializer);
```

[Advantage of switch over if-else statement](https://stackoverflow.com/questions/97987/advantage-of-switch-over-if-else-statement)

* 분기 테이블(branch table) 또는 점프 테이블(jump table)은 분기나 점프 명령어들을 이용해서, 프로그램의 제어를 프로그램의 다른 부분으로 옮기는 방법입니다. 주로 Switch문을 구현하는, 컴파일러에 의해 생성된 어셈블리어 프로그램에 사용됩니다.


# 고정 소수점

## 부동소수점
부동소수점(浮動小數點, floating point) 또는 떠돌이 소수점 방식은 실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수(假數)와 소수점의 위치를 풀이하는 지수(指數)로 나누어 표현한다.

컴퓨터에서는 고정 소수점 방식보다 넓은 범위의 수를 나타낼 수 있어 과학기술 계산에 많이 이용되지만, 근삿값으로 표현되며 고정 소수점 방식보다 연산 속도가 느리기 때문에 별도의 전용 연산 장치를 두는 경우가 많다. 고정 소수점과 달리 정수 부분과 소수 부분의 자릿수가 일정하지 않으나, 유효 숫자의 자릿수는 정해져 있다.

* 부동소수점 활용에 관련해서 찾아볼 필요가 있습니다.

**어떻게 계산하는가?**
예를 들어, 십진수 21.8125를 정규화된 이진수로 나타낸다고 해보자. 소수점 위의 (21.)10=(10101)2이고, 소수점 아래 (0.8125)10=(1101)2이다. 즉 (21.8125)10=(10101.1101)2이며, 이를 정규화하면 0.101011101×25이다. 지수의 5를 이진법으로 바꾸면 101이다. 따라서, 32비트 정규화된 부동소수점수로 나타낸다면 맨 앞 비트의 부호는 0(양)이고, 지수부 부호는 0(양)이며, 지수부 나머지 6개 비트는 000101, 가수부는 101011101000…이 된다. 이것을 결합하면 (0000001011010111010000000000000000)2가 된다.

# 부동 소수점 연산. 단정밀도와 배정밀도의 차이
## 계산식의 자리수를 억제, 부동 소수점
컴퓨터는 숫자를 연산할 때 정수 연산과 소수 연산의 2가지로 나눠 구현합니다. 이건 '처리해야 하는 숫자의 자리수'가 매번 다르기 때문입니다. 

## 왜 부동소수점을 쓰는가?
정수는 보통 10자리 정도면 충분합니다. 대규모 기업의 회계 처리라면 10자리로도 부족하지만 그런 경우는 많지 않겠지요. 그러나 소수는 필요한 자리수가 매번 다릅니다. 옐르 들어 백만원이라면 7자리인데 여기에 할푼리가 붙으면 9자리 10자리가 됩니다. 

이 경우 정수 8자리에 소수 2자리 정도면 되지만, 어떤 경우에는 정수는 2자리면 족한데 소수가 5자리 필요한 경우도 있습니다. 이들 모두를 맞추려면 13자리 가지고선 부족하며 더 많은 자리수가 필요하게 됩니다.

이렇게 만들면 항상 다 쓰지도 않는 자리수 때문에 너무 많은 공간을 할애하게 되니, 소수를 다룰 때는 부동 소수점이라는 방식을 쓰게 됐습니다. 예를 들어 123456.789라는 숫자를 다룰 경우 이렇게 데이터를 저장합니다.
 
## 부동소수점 표현 방식
|---|---|---|
|**123456.789의 표시 방식**|---|---|
|기존의 방식(고정 소수점 방식)   | 123456.789	         |정수 부분 6자리 + 소수 3자리   |
|부동 소수점 방식	            | 1.23456789 × 10 5	    |가수 부분 9자리 + 지수 1자리   |
|**12345678.9의 경우**|---|---|
|고정 소수점 방식	            |12345678.9	            |정수 부분 8자리 + 소수 1자리   |
|부동 소수점 방식	            |1.23456789 × 10 8	    |가수 부분 9자리 + 지수 1자리   |
|**1.23456789의 경우**|---|---|
|고정 소수점 방식	            |1.23456789	            |정수 부분 1자리 + 소수 8자리   |
|부동 소수점 방식	            |1.23456789 × 10 0	    |가수 부분 9자리 + 지수 1자리   |
 

고정 소수점 방식으로는 1.23456789 ~ 12345678.9까지의 모든 숫자를 처리하기 위해 정수 부분 8 자리 + 소수 8 자리가 필요합니다. 하지만 부동 소수점 방식에선 가수 부분(1.23456789를 저장하는 곳)이 9자리, 지수(10의 제곱을 저장하는 자리) 1자리니까 총 10자리입니다.

다루는 값의 범위가 엄격하게 정해져 있고, 이게 변하지 않는다면 고정 소수점 방식이 나쁘지 않습니다. 오히려 편하지요. 하지만 **어떤 값이 나올지 예상하지 못하는 경우가 많으며, 이 경우에는 부동 소수점이 더 작은 공간을 차지합니다.**

## 숫자 표현은 반정밀도에서 8배정밀도까지

## 기본이 되는 단 정밀도 부동 소수점 연산, 2진수를 10진수로 변환하면 오차가 생겨남

## 정확도 향상의 댓가는 느린 연산 속도
단정밀도와 배정밀도를 비교하면 배정밀도가 2~4배 정도 느려집니다. 이건 처리해야 할 데이터의 양이 배로 늘어마면서, 덧셈은 2배, 곱셈은 4배가 느려졌기 때문입니다. 구체적으로 얼마가 느려지는지는 구현 방법에 따라 다릅니다. 예전의 x86처럼 64비트 연산에 32비트 연산기를 사용할 경우엔 64비트 곱셉이 32비트 곱셈을 4번 수행하고 여기에 32비트를 더해야 하니까 5배 이상 느려지기도 했습니다. 

**그래서 정확도는 적당한 수준이면 되니 빠른 연산이 필요한 경우에는 배정밀도가 맞지 않습니다. 이를 극단적으로 추구한 것이 3D그래픽과 Z 버퍼**, 머신 러닝에 쓰이는 CNN(Convolutional Neural Network)의 처리입니다.

[부동 소수점 연산. 단정밀도와 배정밀도의 차이](https://gigglehd.com/gg/hard/5427559)


# 수치해석
우선순위 낮음?

[수치해석](http://www.aistudy.com/math/numerical_analysis.htm)
책한권 사서 읽는게 제일 빠를 것 같다.