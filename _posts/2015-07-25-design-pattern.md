---
published: true
layout: post
title:  "设计模式汇总"
date:   2010-10-04 09:52
categories: 设计模式
---

**蝇量（Flyweight）**模式： 当一个应用中需要某个类的很多实例，而这些实例能被同一方法控制时，我们可以使用蝇量模式。它将许多“虚拟”对象的状态集中管理，可以减少运行时对象实例的个数，节省内存。但缺点是，一旦你实现了它，单个的逻辑实例将无法拥有独立而不同的行为。

**适配器（Adapter）**模式： 当程序中需要的接口与我们实现的类的接口不一致时，为了避免修改已有程序，我们可以把实现的类适配成程序需要的类，让原本接口不兼容的类可以合作无间。依据适配的不同方式，适配器可以分为对象适配器 （利用组合）和类适配器 （利用继承）。

**外观（Facade）**模式： 外观模式创建一个接口简化而统一的类，用来包装子系统中一个或多个复杂的类。它允许我们让客户和子系统之间避免紧耦合。与适配器模式不同的是，外观模式的意图是提供子系统的简化接口，而适配器模式的意图是将接口转换成客户所期望的接口。

**装饰者（Decorator）**模式： 装饰者模式将一个对象包装起来以增加新的行为和责任。

**生成器（Builder）**模式： 生成器模式在导向者的控制下一步一步构造产品，它允许产品通过多个步骤来创建，并且可以改变过程。仅当该产品完成时导向者才从生成生成器中取回它。

**原型（Prototype）**模式：原型模式动态抽取当前对象运行时的状态，同时通过提供统一的clone接口方法，使得客户代码可以在不知道对象具体类型时仍然可以实现对象的拷贝 ，而无需运用type-switch检测对象的类型信息来分别调用创建方法创建一个新的拷贝。

**命令（Command）**模式： 命令模式将发出请求的对象和执行请求的对象解耦，在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个（或一组）动作。调用者通过调用命令对象的 execute() 发出请求，这可以让接收者的动作被调用。宏命令 是命令的一种简单延伸，它允许调用多个命令（接受一个命令组作为参数）。

**备忘录（Memento）**模式：备忘录模式可以存储对象之前的状态，需要时可以让对象返回之前的状态。它的缺点是储存和恢复状态的过程可能相当耗时。

**访问者（Visitor）**模式： 访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。使用访问者模式，必须定义两个 类层次：一个对应于接受操作的元素，另一个对应于定义对元素的操作的访问者。给访问者层次增加一个新的子类即可创建一个新的操作。

参考资料：【[访问者模式的进阶](http://www.javaeye.com/topic/345384)】

**中介者（Mediator）**模式： 当一系列的对象之间存在很多的交互时，可以引入一个中介对象来封装这些交互。中介者负责控制和协调这组对象间的交互，使各对象不需要显式地相互引用，从而 使其耦合松散。这些对象仅知道中介者（一旦某个对象状态发生改变，它会通知中介者，而中介者再根据此对象的改变通知相关的对象），从而减少了相互连接的数 目。

**桥接（Bridge）**模式： 桥接模式通过将抽象和实现放在两个不同的类层次中，将抽象部分与它的实现部分分离，使得它们可以独立地扩展，不会影响到对方。比如在游戏开发中，不同型号的坦克需要在不同的操作系统平台上实现，不同型号的坦克是一个变化的维度，不同操作系统平台上的实现是另外一个维度。

参考资料：【<http://lc-abcdefg.blog.163.com/blog/static/19554211201062602038683/>】

**责任链（Chain of Responsibility）**模式： 责任链模式为某个请求创建一个对象链，让这个对象链上的对象都有机会能够处理某个请求，哪个对象处理该请求在运行时刻自动确定。链中的每个对象扮演处理 器，并且有一个后继对象。如果它可以处理这个请求，就进行处理；否则把请求转发给后继者。因为一个请求没有明确的接受者，所以无法保证它一定会被处理（该 请求可能一直到链的末端都得不到处理）。责任链模式将请求的发送者和接受者解耦。

**解释器（Interpreter）**模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。如果某一特定领域的问题比较复杂，类似的模式不 断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释 这样的句子，从而达到解决问题的目的。

参考资料：【<http://blog.163.com/lc-abcdefg/blog/static/19554211201062602518875/>】

**代理（Proxy）**模式：对于复杂的软件系统常常有一种处理手法，即增加一层间 接层，从而使得系统获得一种更为灵活、满足特定需求的解决方案。在面向对象的系统中，有些对象由于某种原因，比如对象创建的开销很大，或者某些操作需要安 全控制，或者需要进程外的访问等，直接访问会给使用者或者系统结构带来很多麻烦。 Proxy设计模式就是在不失去透明操作对象的同时，通过增加一层间接层来管理、控制这些对象特有的复杂性。 
三种常用的代理 ： 
1、远程（remote）访问代理（可能为了简化客户代码，也可能为了集中管理等）；
2、虚拟（virtual，或称为重要对象）访问代理（可能是共享对象或大的，耗资源的对象，比如word中的超大显示图片）；
3、保护（protection，或称为访问控制）代理，例如不同用户对对象有不同的操作权限等等。

参考资料：【<http://lc-abcdefg.blog.163.com/blog/static/19554211201062602312307/>】