---
layout: post
title: CPP *.inl
---

## 재귀 호출의 개념
Recursive call(재귀 호출의 개념)   
재귀 호출은 알고리즘이나 자료 구조론에서는 매우 중요한 개념 중 하나입니다.
또한 재귀 호출을 사용하면 복잡한 문제도 매우 간단하게 논리적으로 접근하여 표현할 수 있습니다.   

진짜 좋네....
http://www.tcpschool.com/c/c_function_recursive   

재귀 호출은 다양한 알고리즘을 표현한 의사 코드를 그대로 코드로 옮길 수 있게 해줍니다.
따라서 재귀 호출은 직관적인 프로그래밍을 하는데 많은 도움을 줍니다.   

스택 오버플로우(stack overflow)는 메모리 구조 중 스택(stack)영역에서
 해당 프로그램이 사용 할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생합니다.

재귀 호출로 실행하는 것은 for문보다 느리기는 합니다.

-----------------------------------

https://sudeky.tistory.com/156 

알고리즘에 따라 특정 상황에서 유리한, 또 다른 상황에서는 불리한 알고리즘이 있지만,
성능 이외에 알고리즘의 또 단른 특성 중 하나는 어떤 이해 및 구현의 난이도를 보이냐입니다.
보통 초기 구현과정에서는 가장(이해 구현이) 쉬운 알고리즘을 사용하며,
해당 알고리즘의 적용이 문제 해결의 correctness를 보장한다는 사실을 확인한 이후에
보다 어렵지만 나은 성능을 보이는 알고리즘으로 대체하는 것이 가능합니다. 

정렬은 컴퓨터 공학의 오래된 연구 분야이므로 이미 아주 훌륭한 정렬 관련 라이브러리가 존재합니다.

주요 관심사. 어떻게 이걸 생각해 낼 수 있었을까? 그리고 어디에 쓸 수 있을까?

##
- [ ] [지후에게 조롱을 받고 한달만에 인라인 함수를 다시 공부했습니다.](https://jerish.blog.csdn.net/article/details/85759127)
- [ ] [역사상 가장 완벽한 C++/게임 개발 인터뷰 질문 요약 (2) - 가상 기능, 메모리, STL](https://jerish.blog.csdn.net/article/details/99098535)
- [ ] [4년 동안 언리얼 엔진을 사용한 네트워크 아키텍처 공개](https://blog.csdn.net/csdnnews/article/details/106935212?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-9-106935212-blog-105101177.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.6&utm_relevant_index=12)
- [ ] ["Exploring in UE4" 게임 캐릭터의 동작 원리(파트 1)](https://blog.csdn.net/u012999985/article/details/105101177)


## TCHAR
요즘은 문자를 처리할 때 유니코드를 주로 사용합니다. WBCS라고 하며 모든 문자와 숫자를 2바이트로 처리합니다.

 

모든 프로그램이 유니코드를 사용하면 좋겠지만.... 실상은 아니죠.

 

초창기, 문자열 처리는 아스키코드로 사용해왔고, 아스키 코드는 1바이트로 구성됩니다.

 

그리고 초창기부터 사용되어 왔던 아스키코드를 지금도 사용하고 있죠.

 

C/C++에선 유니코드를 사용함에 따라 문자열 처리를 1바이트와 2바이트 이 두개를 신경써서 해야 했고,

 

결론적으로 유니코드를 처리할 수 있는 자료형을 만들어 냅니다.

 

바로 앞에 w를 붙인 자료형이죠.

 

아래 자료형 선언은 <Windows.h> 헤더파일에 정의되어 있습니다.

(정확히 말하자면 winnt.h에 있지만 이 해더파일을 Windows.h가 포함하고 있습니다.)

char = 1바이트
wchar_t = 2바이트
 
wchar_t로 선언된 char형은 2바이트로 처리하게 됩니다.

 

하지만 MS에선 이 자료형들에 대해 일관성을 부여하기위해 typedef를 사용해 대문자로 사용합니다.

char -> CHAR
wchar_t -> WCHAR
 
 

char 를 대문자인 CHAR로

wchar_t 를 대문자인 WCHAR로 말이죠.

 

따라서 아스키코드를 사용하는 프로그램은 CHAR를 사용하면 되고

유니코드를 사용하는 프로그램은 WCHAR를 사용하면 됩니다.

 

 

 

그러면 상수 문자열은 어떻게 처리해야 할까요??

예를들자면 이런거 말입니다.

char arr[] = "hi my name";
printf("안녕하세요?\n");
 

이런 문자열들은 상수로 선언된 것입니다. 이것들은 기본적으로 1바이트로 구성되어 있죠.

따라서 프로그래머는다음 키워드를 통해 2바이트로 바꿔줘야 합니다.

 

char arr[] = L"hi my name";
printf(L"안녕하세요?\n");
 
 

문자열 앞에 'L'을 붙여주는 것이죠. 이렇게 하면 해당 문자열은 2바이트로 처리가 됩니다.

 

 

 

하지만 여기서 불편한 점이 생김니다.

 

아스키코드로 사용된 프로그램이 유니코드를 사용해야 한다면.....

혹은 유니코드로 사용된 프로그램이 아스키코드를 사용해야 한다면....

 

똑같은 프로그램을 유니코드용과 아스키코드용으로 만들어야 합니다.

즉, 2개의 프로그램이 필요한 것이죠.

 

이러한 점 때문에 MS에선 한가지 방법은 고안해 냅니다.

 

전처리 함수를 통해 유니코드일 땐 WCHAR로 변환해서 사용하고 아스키코드일땐 CHAR로 변환해서 사용하는 것입니다.

 

컴파일러의 설정에 따라서 말이죠.

 

즉, 프로그래머는 사용환경에 맞춰 컴파일 빌드만 바꿔주면 아스키코드용 프로그램이 만들어지고

유니코드용 프로그램이 만들어 지는 것입니다.

 

그리고 이를 정의하 전처리 함수는 다음과 같습니다.

#ifdef UNICODE
    typedef WCHAR TCHAR;
#else
    typedef CHAR TCHAR;
#endif
 
 

 

TCHAR로 통일하는 것입니다. 

(다른 자료형들도 많이 있지만(LPTSTR, LPCTSTR 등) 생략했습니다.)

 

그리고 상수로 표현하는 문자열의 처리도 다음과 같이 정의되어 있습니다.

#ifdef _UNICODE
    #define __T(x) L ## x
#else
    #define __T(x) x
#endif

#define _T(x)        __T(x)
#define _TEXT(x)     __T(x)
 
 

따라서 문자열 앞에 '_T'를 붙여주면 컴파일 환경에 따라 문자열을 처리할 수 있게 됩니다.

그리고 이걸 사용하기 위해선 <tchar.h> 헤더 파일을 선언해 줘야합니다.

 

보통은 <Windows.h>와 <tchar.h> 요 두를 동시에 선언하는게 보편적입니다.