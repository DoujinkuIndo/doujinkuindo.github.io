---
layout: post
title: "Docker"
excerpt_separator: "<!--more-->"
tags:
  - docker
  - devops
---

This document describes Docker’s basic concepts. 

### What is Docker?

Docker is a powerful tool to manage isolated containers - as the applications are called. It is a complete platform designed to deliver applications faster. It’s based on LXC - Linux Container.

[As defined at Linux Containers’ webpage [1]](#references), LXC’s focus is system containers. 

> That is, containers which offer an environment as close to possible as the one you'd get from a VM but without the overhead that comes with running a separate kernel and simulating all the hardware.
This is achieved through a combination of kernel security features such as namespaces, mandatory access control and control groups.

Without the extra load of the Hypervisor and Virtual OS, containers have some upsides:

* Containers are faster because they use the host’s kernel and its features;
* One might distribute the containers to the team easily;
* One might deploy those applications to production environment.

<img src="{{ site.url }}/assets/docker/docker.png?raw=true" align="center" style="display: block;margin: 0 auto;" />




### Installation

Docker’s installation, on Linux OS, is rather simple, therefore few commands solve the issue. Docker’s webpage has an excellent article to show how this is done. [Link [2]](#references)


### Hello, Docker!
At the first example, look at the command below:

```console
machine:curso user$ docker run ubuntu /bin/echo Hello, Docker!
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

2f0243478e1f: Pull complete 
d8909ae88469: Pull complete 
820f09abed29: Pull complete 
01193a8f3d88: Pull complete 
Digest: sha256:8e2324f2288c26e1393b63e680ee7844202391414dbd48497e9a4fd997cd3cbf
Status: Downloaded newer image for ubuntu:latest
Hello, Docker!
```


So, what is happening here? Let’s step by step:

At first, docker downloaded the image that was requested, Ubuntu’s image. Following that, docker created a container using this image. Finally it executed the ```/bin/bash``` command passing ```Hello, Docker!``` as parameter. 

One should understand images as a read-only template. The images define which applications will be in containers when they are up, since these images are used to create containers. For instance, an image could have Ubuntu, Mysql and JDK 8.

Even though, other steps were taken in this process, so far, these are the most important ones.

### Exploring Docker

There are a set of commands that provide many options to interact with containers. The first one, run command, was introduced above. But there are others possibilities, let’s dig deeper.

```console
machine:curso user$ docker run -it ubuntu
root@2a67c557c71b:/# pwd
/
root@2a67c557c71b:/# ls -l
total 64
drwxr-xr-x  2 root root 4096 Aug  9 16:25 bin
drwxr-xr-x  2 root root 4096 Apr 12 20:14 boot
drwxr-xr-x  5 root root  380 Aug 17 08:21 dev
drwxr-xr-x 45 root root 4096 Aug 17 08:21 etc
drwxr-xr-x  2 root root 4096 Apr 12 20:14 home
drwxr-xr-x  8 root root 4096 Sep 13  2015 lib
drwxr-xr-x  2 root root 4096 Aug  9 16:24 lib64
drwxr-xr-x  2 root root 4096 Aug  9 16:24 media
drwxr-xr-x  2 root root 4096 Aug  9 16:24 mnt
drwxr-xr-x  2 root root 4096 Aug  9 16:24 opt
dr-xr-xr-x 99 root root    0 Aug 17 08:21 proc
drwx------  2 root root 4096 Aug  9 16:24 root
drwxr-xr-x  5 root root 4096 Aug  9 16:24 run
drwxr-xr-x  2 root root 4096 Aug 11 17:46 sbin
drwxr-xr-x  2 root root 4096 Aug  9 16:24 srv
dr-xr-xr-x 12 root root    0 Jul 23 12:51 sys
drwxrwxrwt  2 root root 4096 Aug  9 16:25 tmp
drwxr-xr-x 11 root root 4096 Aug 11 17:46 usr
drwxr-xr-x 13 root root 4096 Aug 11 17:46 var
```

The example shows how to access the container’s terminal. To do so, two arguments, -i and -t, were passed. The parameter -i means interactivity and the second one, -t, means to create a link to container’s terminal. Once it is connected, one might execute many commands.

To check any container’s information, see the next command.


```console
machine:curso user$ docker ps -a
CONTAINER ID    IMAGE               COMMAND                  CREATED             STATUS                     PORTS                NAMES
2a67c557c71b     ubuntu              "/bin/bash"              12 minutes ago     Exited (0) 4 seconds ago                         jolly_goldberg
```

Docker gave a name to the container that was created sooner. Now its name is jolly_goldberg. Other informations are important here: Container id is the container’s identify and it is used to do many activities; image shows which image generated the container; status shows if the container is up or not.

Let’s improve the container. Let’s install apache2 on it.

```
1. docker run -it ubuntu - Run the container
2. apt-get update - Update operational system
3. apt-get install -y nano wget dialog net-tools - Install some packages to support apache2’s installation
4. apt-get install -y apache2 - Install apache2
```

That’s it! Apache2 is installed, though all changes done within the container will be lost because it is volatile. Then to keep the changes, one must commit them, as the following command.

```console
machine:curso user$ docker commit 946fd794a4f6 ubuntu/apache2
sha256:f426e9522b8b0f3140b56f5ffd7d758cf1747cd6fce1b006551aaf92440ba561
```

After that, the new image is created and its name is ubuntu/apache2. Look at here:

```console
machine:curso user$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu/apache2      latest              f426e9522b8b        2 minutes ago       267.6 MB
```

The command docker has some options. One might list all images installed as the prior command shows.

The Apache2 was installed, the image was created. How to run the Apache2 server?

```console
machine:curso user$ docker run -it --rm -p 8080:80 ubuntu/apache2 /bin/bash
root@26e000aa6c59:/# apache
apache2     apache2ctl  apachectl   
root@26e000aa6c59:/# apachectl start
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
```

News arguments come with the last command. To create a temporary container just passe the --rm argument. The -p argument allows the mapping of a port between the host and the container. The first port, 8080, is the host’s port and the second one, 80, is the container’s port. One might confirm the server’s up either the browser or the following command:

```console
Machine:curso user$ curl -I http://localhost:8080
HTTP/1.1 200 OK
Date: Wed, 17 Aug 2016 09:15:51 GMT
Server: Apache/2.4.18 (Ubuntu)
Last-Modified: Wed, 17 Aug 2016 08:48:53 GMT
ETag: "2c39-53a4088eb6740"
Accept-Ranges: bytes
Content-Length: 11321
Vary: Accept-Encoding
Content-Type: text/html
```

The -p argument connects the host to the container through their ports. So that, every request on the mapped host’s port, 8080 in the example, will be redirected to the container’s port, 80 in this case, which is the default apache’s port.

Another important argument is -d that allows the creation of a container in a background process, releasing the terminal.

### Dockerfile

Dockerfile is an important docker’s feature that standardizes the image’s creation, providing a unique file to control. This is a simple text file in any directory which has nothing special, besides the key-words known by Docker. Look at the example.

```
FROM ubuntu

RUN apt-get update

RUN apt-get install -y nano wget dialog net-tools

RUN apt-get install -y apache2

EXPOSE 80

CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

```

The first command defines the image’s basis, therefore the image generated by this Dockerfile has Ubuntu as the operational system. It could be CentOS, Fedora and so on. Following that, the image is being updated and some packages are being installed to support Apache’s installation. Then Apache is installed. Finally the expose command provides the port to be accessed from outside. And the last line executes an apache’s command to turn up the service.

After that, the image might be created. To do so, Docker has an easy command. Look at that:

```console
machine:curso user$ docker build -t ubuntu/my_apache .
Sending build context to Docker daemon 212.9 MB
Step 1 : FROM ubuntu
 ---> f8d79ba03c00
Step 2 : RUN apt-get update
 ---> Using cache
 ---> 68018abe62a0
Step 3 : RUN apt-get install -y nano wget dialog net-tools
 ---> Using cache
 ---> 1a221996e17e
Step 4 : RUN apt-get install -y apache2
 ---> Using cache
 ---> 59d242bf03ae
Step 5 : EXPOSE 80
 ---> Using cache
 ---> af290e3d8223
Step 6 : CMD /usr/sbin/apache2ctl -D FOREGROUND
 ---> Using cache
 ---> 6fd0890420e5
Successfully built 6fd0890420e5
```

Finally the image is ready to be used and the command below shows that.


```console
machine:curso user$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu/my_apache    latest              6fd0890420e5        2 minutes ago       269.3 MB
```

Now the first ubuntu/my_apache’s container is up.

```console
machine:curso user$ docker run -d -p 80:80 ubuntu/my_apache
186a6885517ae8399f8f1698372878059d88d0581592e47b2198153b3a630453
Machine:curso user$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
186a6885517a        ubuntu/my_apache    "/usr/sbin/apache2ctl"   4 seconds ago       Up 2 seconds        0.0.0.0:80->80/tcp   suspicious_goodall
Machine:curso user$ curl -I http://localhost
HTTP/1.1 200 OK
Date: Wed, 17 Aug 2016 21:49:31 GMT
Server: Apache/2.4.18 (Ubuntu)
Last-Modified: Wed, 17 Aug 2016 21:44:04 GMT
ETag: "2c39-53a4b5d30f100"
Accept-Ranges: bytes
Content-Length: 11321
Vary: Accept-Encoding
Content-Type: text/html
```

That’s great!


### Where are the images from?

[Docker has an amazing library to keep saved images, Docker Hub [3]](#references). There are many images to be used, you must choose one of them, as it has been chosen above. Everyone can upload images as well, but it’s necessary to create a Docker ID.

Explore the library there may be what you need.


### Volumes

Volume is the way used by Docker to share directories between containers and the hosts. A directory can be shared between many containers. This approach provides a great channel to manipulate data within the containers and keep them saved.


<img src="{{ site.url }}/assets/docker/volume.png?raw=true" align="center" style="display: block;margin: 0 auto;" />


Let’s create a container that executes MySql database. After that, let’s connect to it and create a database. Look at the commands.

```console
machine:curso user$ docker run -d -p 3306:3306 --name database -e MYSQL_ROOT_PASSWORD=1 mysql
968f7d2282a6c917666f22973251736a661cbecd2eedfd134eb80f6a9c971562
Machine:curso user$ mysql -h 127.0.0.1 -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.13 MySQL Community Server (GPL)

Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql> create database test;
Query OK, 1 row affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.00 sec)

mysql> 

```

There are news here. At first, the --name argument allows you to name the container. Afterwards, -e that passes key and value parameter to the environment. Following that, it connects to the database and creates test database.

Now, let’s stop the container and remove it.

```console
machine:curso user$ docker stop database
database
machine:curso user$ docker rm database
database
```

So let’s create another container with the same name - it could be any name - and connect to it.

```console
machine:curso user$ docker run -d -p 3306:3306 --name database -e MYSQL_ROOT_PASSWORD=1 mysql
4ee4367f69dd2b6a9e5d34e09fde2e690bcc725a636eaf3f30a224492d281e7b
Machine:curso user$ mysql -h 127.0.0.1 -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.13 MySQL Community Server (GPL)

Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql> 
```

Notice that the database created earlier disappeared. So what is going on? Don’t you remember?! Containers are volatile! We need to create the channel between the host and the container’s directory that is desired to keep data saved. Let’s do it!

```console
machine:db user$ docker run -d -p 3306:3306 --name database -v $(pwd):/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1 mysql
b20d235f1aebcb1dc8610a995672336f0f325787f4341307956d3399f694db5e
Machine:db user$ mysql -h 127.0.0.1 -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.13 MySQL Community Server (GPL)

Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.03 sec)

mysql> create database test;
Query OK, 1 row affected (0.01 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.01 sec)

mysql> exit
Bye
```

Look at the ```-v $(pwd):/var/lib/mysql``` argument. It allows the creation of the connection between the host and the containers. The first part,```$(pwd)```, points to the host’s directory and the second one, /var/lib/mysql, indicates the container’s directory shared - in this case, it is the directory used by Mysql. 

Try out yourself!

### Network

Every container created gives its own Ip address. Docker does it for us. Then how to create connection between containers?

Imagine two containers are running: the first one is running mysql and the second one is running apache. The container, which apache is running, needs to connect to database.

Docker solves the problem easily. Look:

```console
docker run -d -p 80:80 --name apache  --link database:db  ubuntu/my_apache
```

The --link database:db parameter passed to create the container is the solution! The first part, database, is the container’s name desired to connect to, and the second part, db, is how database container must be called in the container. Now the new container might connect to the database.

```console
machine:db user$ docker -it apache bash

root@93d07262f55d:/# apt-get install -y mysql-client-5.7

root@93d07262f55d:/# mysql -h db -u root -p

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.02 sec)
```


At first, it connected to container’s terminal. After the mysql client was installed, it was connected to database using the alias created, db.

### Conclusion

As said, Docker is a powerful tool. Its goal is to simplify the software's environment and to make easier its transferring between both the team and the cloud.

[According Docker’s web page [4]](#references), it might be used to 
>faster delivery of your applications faster, deploying and scaling more easily, achieving higher density and running more workloads.

Docker has many other features that are not being treated here. 

This document is a simple overview in this amazing platform! So let’s go ahead and use it!


### Appendix

Some commands to be a quick view.

```console
docker images
docker commit -m “comment” <container_id>
docker run -it -p 80:80 ubuntu/apache bash
docker exec -it <container_id> ls -l /var/...
docker build -t ubuntu/apache .
docker run -d -p 80:80 ubuntu/apache
Background
--name container_name
--link container_name:alias
--rm
docker-compose up
docker inspect
docker run -it -v $(pwd):/tmp
docker run -d -p 80:80 -c 512 -m 1024m <container_name>
docker stats <container_name>
docker rm <container_id>
docker rmi <image_name>
```


### References
1. [Linux Containers’ webpage](https://linuxcontainers.org/)
2. [Docker’s webpage](https://docs.docker.com/engine/installation/#installation)
3. [Docker hub](https://hub.docker.com/)
4. [What can I use Docker for?](https://docs.docker.com/engine/understanding-docker/)


