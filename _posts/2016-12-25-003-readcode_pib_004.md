---
layout: post
title: pibドライバを読む (第4回)
---

こんにちは。気力が続いているうちに、さくさく読んでいきます。


前回宿題として残したportについて、今日は書いていきたいと思います。まず、前提情報について。InfiniBandのportの状態は、通信準備前の初期状態（INIT）と通信準備完了の（ACTIVE）が主にあります。通信準備前の初期状態では、ethernetのMACアドレスに *似た* lidというSubnet内通信用識別（Local-IDentifire:LID）が振られておらず、Subnet-Managerとの通信を経て、Subnet-Managerの貸し出したLIDがポートに割り当てられます。DHCPみたいですね。なお参考までに書きますと、LIDはSubnet内に存在するすべての構成要素に配布されます。そのため、ethernetではスイッチングハブのポートは名前が付いていませんが、InfiniBandネットワークでは、InfiniBandスイッチのポートにもLIDが付いています。

- [InfiniBand Essentials Every HPC Expert Must Know](http://www.slideshare.net/mellanox/1-mellanox) ... Slide45

<!--break-->

ポート初期化関数は `init_port` [pib_main.c-L670](https://github.com/xinolinx/pib/blob/master/driver/pib_main.c#L670) です。ここで `struct ib_port_attr` に初期値・許容値を代入していきます。

pibは仮想デバイスですので、この時点でLinkupさせてしまいます。 `port->real.initialized` を落としているのは、 *本当に通信するデバイス* というのが接続されていないためです（なお今回のrepositopryは実際に通信できないデバイスにしているため、この値がtrueになることはないでしょう：笑）。

```c
	port->is_connected = true;
	port->ib_port_attr.phys_state = PIB_PHYS_PORT_LINK_UP;
	port->ib_port_attr.state      = IB_PORT_INIT;
	port->real.initialized = false;
```

以上でport構造体が初期化されましたので、デバイス本体をLinuxシステムへ登録します。

```c
	if (ib_register_device(&dev->ib_dev, NULL))
		goto err_register_ibdev;
```

その後、このrepositoryのpibは、Subnet-ManagerからLIDが割り振られた、というていで、自分でポートに自分が生成したLIDを割り付け、勝手にACTIVE状態へ遷移させています。実際のInfiniBandデバイスでは、この箇所は実際にInfiniBandの通信線上を通してSubnet-Managerと通信を行い、LIDを割り振られ準備ができた後に、ACTIVEになります（自分で勝手にLIDを生成するとSubnet内部で衝突が起きますので、Subnet-ManagerがLIDを配布するというポリシーになっています）。

```c
#ifdef RUNMODE_STANDALONE
	for (i=0 ; i < dev->ib_dev.phys_port_cnt ; i++) {
		rdev_adddevice(i, dev);
	}
#endif /* STANDALONE_MODE */
```

最後に、デバイスのイベントを処理する、Kernel Threadを生成します( [here](https://github.com/xinolinx/pib/blob/master/driver/pib_main.c#L613) ) 。 `pib_create_kthread` は `driver/pib_thread.c` に定義されていて、InfiniBand Device1個に対して1個のKernel Threadを生成し（NOT-each-Port)、このKernel Threadがpibに届いたイベントを順次解決することで、pibは機能します。

```c
	if (pib_create_kthread(dev)) {
		goto err_create_kthread;
	}
```

---

- ~~**宿題 ib_register_deviceする前にKernel Threadを作らないのは何故だろう？--~~
 - ib_register_deviceが先でもKernel Threrdが先でも、dev構造体内のフラグにより仕事をKernelに積む
 - そのため、Thread起動前のイベント発生も、Thread開始後に回収される。

```c
static void kthread_routine_iteration(struct pib_dev *dev)
{
	if (test_and_clear_bit(PIB_THREAD_STOP, &dev->thread.flags)) ...
	if (test_and_clear_bit(PIB_THREAD_WQ_SCHEDULE, &dev->thread.flags)) { ...
	if (test_and_clear_bit(PIB_THREAD_READY_TO_RECV, &dev->thread.flags)) { ...
	if (test_and_clear_bit(PIB_THREAD_QP_SCHEDULE, &dev->thread.flags)) { ...
```

---

```c
int pib_create_kthread(struct pib_dev *dev)
{
        ...
	dev->thread.timer.function = timer_timeout_callback;
	dev->thread.timer.data     = (unsigned long)dev;
        ...
	dev->thread.send_buffer	   = vmalloc(PIB_PACKET_BUFFER);
        ...
	dev->thread.recv_buffer	   = vmalloc(PIB_PACKET_BUFFER);
        ...
	task = kthread_create(kthread_routine, dev, "pib_%d", dev->dev_id);
	if (IS_ERR(task))
		goto err_task;
```

なお、pibの生成するKernel Threadは `dev->thread.send_buffe` と `dev->thread.recv_buffer` をそれぞれ確保しており、これがデバイスの送受信バッファになり、すべてのポートの通信は、このバッファでシリアライズされているようです。

- **宿題** Port単位でバッファを持つと衝突しにくそう。
- 送出データ構築は `dev->thread.send_buffe` と `dev->thread.recv_buffer` 外で実行する、とか？

最後にKernel Threadが立ち上がり、イベントがあるか、Queue-Pair（後日説明）にエントリがある場合に逐次処理を行う流れとなります。

```c
static int kthread_routine(void *data)
{
        ...
	phys_port_cnt = dev->ib_dev.phys_port_cnt;
        ...
	while (!kthread_should_stop()) {
                ...
		while (dev->thread.flags) {
			cond_resched();
			kthread_routine_iteration(dev);
		}
                
		process_on_qp_scheduler(dev);
```

僕への宿題は積みあがりましたが、前提の部分はざっくり読めたのかなと思います。次回以降は具体的なQueueなど、イベント処理に入っていこうと思います（宿題片づける方が先だけれど！）。


それでは、今日はこのあたりで失礼いたします。
