After the morning meeting with Dr. G, I have a list of tasks that I want to accomplish by this weekend: 
1. Correct my error estimates from yesterday, which applied Poisson statistics to the wrong data type
2. Create a new version of the code that is designed to work with drizzled HST images
3. Improve my source detection. Right now, I am detecting far more sources than there actually are. I will try to determine the average, maximum, and minimum full-width half-maximum (FWHM) for sources in the field I've been looking at and utilize that information to improve my search. I also may expand the field some to 300x300, possibly up to 500x500 to include more sources. 

Getting this done before the weekend would leave me feeling prepared to look at the black-box HST photometry software that we're actually using for this particular data next week. I do hope we still end up using the codes Rory and I are writing for some of the real data analysis on our sources of interest; I'm starting to become proud of this code. 

## Better Error Estimation
To correct yesterday's code, I went back to [aperture_photometry.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/aperture_photometry.py) and manipulated the data explcitly to change it to total counts by multiplying the data array by the exposure time for that observation. Doing this means that I get total flux at the end instead of flux rate. For some reason, this change causes [aperture_photometry.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/aperture_photometry.py) to give the error "invalid values encountered in np.sqrt()", even though the negatives have been replaced by zero like before. Also, this error doesn't happen if I just don't multiply by effective gain. But, the code still compiles and runs and gives me this out:  
![fluxes]({{thom-ory.github.io}}/images/fluxes.png) 
_Above: Sources in the field  
Below: Source ID as defined by [phot_table.txt](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/day_five/phot_table.txt) vs Total Flux   
note: The error bars are tiny and very hard too see. If you look closely, you can see a little bit of red on top of most of the blue circles; this is the error_

---
I'm shocked at how tiny the errors are. I thought there was a problem at first and they weren't getting drawn, but I changed the plot to have the error bars over the data points instead of underneath them (visually), and sure enough they're there, and tiny. You can also see the values of the error in the last column of [phot_table.txt](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/day_five/phot_table.txt).

I then tried to lean into the drizzled images that I already have to work with, and did an entirely different method that allowed me to get counts/s out. I saved this version of the file as [aperture_photometry_drz.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/aperture_photometry_drz.py), and instead of explicitly writing out `np.sqrt(data)` to get a Poission uncertainty estimate, I used `photutils.utils.calc_total_error()`, which requires a "background error" (bkg_err) array (which is the error associated with background objects or the instrument and does not include Poisson noise) and an effective gain. The effective gain (gain_eff) is a conversion factor that converts whatever data you have into counts. Bkg_err and the data must have the same array shape and if you write units explicitly they must have the same units, and gain_eff must have units that cancel to counts when multiplied with the data array and be either a scalar or an array of the same shape as data. Since the drizzled data is already flat-fielded, and since I subtract the background with localized aperture photometry, I can make bkg_err an array full of zeros; there's nothing that bkg_err corrects for that I don't account for somewhere else. I used 7058 seconds as gain_eff, since that was how long the exposure time was, this cancels to total counts when multiplied with data. With this method, I no longer need to explicitly multiply the data array by the gain, and the results I get are in counts/s:  
![flux_rates]({{thom-ory.github.io}}/images/flux_rates_2.png)
Above: Sources in the field  
Below: Source ID as defined by [phot_table_drz.txt](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/day_five/phot_table_drz.txt) vs Flux Rate   
_note: The source image looks darker than it did; that's because with this second method I never have to replace negative values with zero because I don't explicitly take the square root_

---
This code doesn't produce andy error messages like the earlier one. The graph looks proportionally the same as the other one, but is a factor of 7058 smaller in value (I checked by hand, the errors are exactly that much smaller, and of course the counts divided by exposure time would be that much smaller as well). It also has different units. I like that they're so symmetrical, because the particular lines of code that produced these two graphs are very different. The errors are significantly smaller than the ones I got yesterday, which were an incorrect application of Poisson statistics anyway. The values can be seen here: [phot_table_drz.txt](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/day_five/phot_table_drz.txt)

# Conclusion
Tomorrow, I want to tackle the FWHM problem, then I'll decide if the code is actually any good at source detection. When it inevitably is not great, I'll make it better until it is. 
