---
layout: post
title: *Under Construction* Creating a Deep Learning Heroku Python/Flask App on a Static Jekyll Site 
---

Often times, especially with side projects you're really proud of, a simple blog post isn't enough to showcase a model you've spent months developing. I created one [here](trap-generator.zeager.xyz) for a trap rap lyric generation model. This tutorial will take you through the various steps needed to create your own machine learning Heroku app on a static site like this one (a Jekyll site hosted on Github). 

**Step 1: Train Your Model**

Of course, in order to utilize your model in a web app, you'll need to first train your model. In my case, since I had a neural network *and* a word2vec model, and both of them had to be trained prior to creating the web app.

**Step 2: Set up a Heroku Account and download Heroku CLI**

Head on over to [the heroku site](www.heroku.com) and create a free account. Now, you *may* find that you may need more memory than the free tier depending on the model (I certainly did), but you can upgrade your payment information later if find the free tier apps too slow or unreliable for your use case.  After you create an account, download and install the Heroku Command Line Interface (CLI). Then, after you install the CLI, head over to your command line and log in to heroku.

{% highlight shell %}
$ heroku login
  Enter your Heroku credentials.
  Email: python@example.com
  Password:
  ...
{% endhighlight %}

**Step 3: Install Flask and set up your Flask application**

Next, you'll need to download flask using pip or whatever python package manager you prefer.

{% highlight shell %}
pip install flask
{% endhighlight %}

And now you'll have to do several things within your python app `app.py`. First, import the necessary modules and initialize the flask app.

{% highlight python %}
import numpy as np
import flask
from flask import request, render_template, flash
import io
import keras
from gensim.models import Word2Vec
import re

app = flask.Flask(__name__)
app.config.from_object(__name__)
{% endhighlight %}

Now we need to set up some of the necessary functions for my app. Because my app was a text generation application, my full code may be way more complicated than you'll need. At the very least, you'll definitely need a function that loads your model like I have below. You *must* have the models set up as global variables in order for the prediction code to utilize the models in its predictions.

{% highlight python %}
def load_model():
    #load word 2 vec model
    global w2vmodel
    w2vmodel = Word2Vec.load('word2vec_model')
    w2v_weights = w2vmodel.wv.syn0
    global model
    model = lstm_model(num_layers, dropout, layer_size, w2v_weights, max_seq_length)
    model.load_weights('model/model_dropout0.05_num_layers_2_layersize_512_batch_size_64max_seq_length6_weights.h5', by_name=True)
{% endhighlight %}

After you create that function and any other helper functions your model needs to predict with new data, you need to set up the `GET` and `POST` methods. In the code below, we use the request.form module from Flask to define our html form. This is served through our `GET` method.

{% highlight python %}
class ReusableForm(Form):
    seed = TextField('Seed:', validators=[validators.required()])
    
@app.route("/", methods=["GET"])
def serve_form():
    return render_template("form.html", form=ReusableForm(request.form))
{% endhighlight %}

Now of course, we don't have a `form.html` file yet! I used a template to create mine, but for this simple example, let's use a basic form.html file with just the input fields we need. In my case, I need three things from the user to output text: temperature (this allows you to select how diverse/creative the model will get with the output), the seed text, and the length that the user wants the generated text to be. 

{% highlight html %}
<html>
    <head>
        <title>Trap Music Demo</title>
    </head>
    <body>
      <h1>Trap Music Generator</h1>
        <form action="/" method="POST">
            {{ form.csrf }}

            <div>
              <input placeholder="temperature (0.01 to 1)" class="form-control" name="temperature"></input>
              <input placeholder="generated text length" class="form-control" name="length"></input>
            </div>
            <div>
              <textarea rows="50" cols="50" class="form-control" placeholder="seed text" name="seed"></textarea>


            </div>

            <div class="btn btn-success">
                <input type="submit" value="Submit" />
            </div>
        </form>
    </body>
</html>
{% endhighlight %}

{% highlight python %}
@app.route("/", methods=['POST'])
def generate_text(): # model, w2vmodel, length=75, max_seq_length=20, temp=1, seed="Rain drop drop top"):
    load_model()
    global w2vmodel
    w2v_weights = w2vmodel.wv.syn0

    form = ReusableForm(request.form)
    print(form.errors)
    #initialize data dictionary that will be returned by app
    data = {"success": False}

    if flask.request.method =='POST':
        seed=request.form['seed']

        length=int(request.form['length'])
        temp=float(request.form['temperature']
        
        # I skipped the code that produced the generated text that will be returned by the function
        # called generated

        return render_template('success.html', generated=generated)
{% endhighlight %}

{% highlight python %}
if __name__ == '__main__':
    print("* Loading Keras model and Flask starting server..."
        "please wait until server has fully started")
    load_model()
    app.run()
{% endhighlight %}

