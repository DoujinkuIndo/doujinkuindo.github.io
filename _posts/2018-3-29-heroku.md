---
layout: post
title: Creating a Deep Learning Heroku Python/Flask App on a Static Jekyll Site 
---

Often times, especially with side projects you're really proud of, a simple blog post isn't enough to showcase a model you've spent months developing. I created one [here](trap-generator.zeager.xyz) for a trap rap lyric generation model. This tutorial will take you through the various steps needed to create your own machine learning Heroku app on a static site like this one (a Jekyll site hosted on Github). 

**Step 1: Train Your Model**
Of course, in order to utilize your model in a web app, you'll need to first train your model. In my case, since I had a neural network *and* a word2vec model, and both of them had to be trained prior to creating the web app.

**Step 2: Set up a Heroku Account and download Heroku CLI**
Head on over to [the heroku site](www.heroku.com) and create a free account. Now, you *may* find that you may need more memory than the free tier depending on the model (I certainly did), but you can upgrade your payment information later if find the free tier apps too slow or unreliable for your use case.  After you create an account, download and install the Heroku Command Line Interface (CLI). Then, after you install the CLI, head over to your command line and log in to heroku.

{% highlight shell %}
$ heroku login
  Enter your Heroku credentials.
  Email: python@example.com
  Password:
  ...
{% endhighlight %}

**Step 3: Install Flask and set up your Flask application**

Next, you'll need to download flask using pip or whatever python package manager you prefer.

{% highlight shell %}
pip install flask
{% endhighlight %}

And now you'll have to do several things within your python app `app.py`. First, import the necessary modules and initialize the flask app.

{% highlight python %}
import numpy as np
import flask
from flask import request, render_template, flash
import io
import keras
from gensim.models import Word2Vec
import re

app = flask.Flask(__name__)
app.config.from_object(__name__)
{% endhighlight %}

Now we need to set up some of the necessary functions for my app. Because my app was a text generation application, my full code may be way more complicated than you'll need. At the very least, you'll definitely need a function that loads your model like I have below. You *must* have the models set up as global variables in order for the prediction code to utilize the models in its predictions.

{% highlight python %}
def load_model():
    #load word 2 vec model
    global w2vmodel
    w2vmodel = Word2Vec.load('word2vec_model')
    w2v_weights = w2vmodel.wv.syn0
    global model
    model = lstm_model(num_layers, dropout, layer_size, w2v_weights, max_seq_length)
    model.load_weights('model/model_dropout0.05_num_layers_2_layersize_512_batch_size_64max_seq_length6_weights.h5', by_name=True)
{% endhighlight %}

After you create that function and any other helper functions your model needs to predict with new data, you need to set up the `GET` and `POST` methods.

{% highlight python %}
@app.route("/", methods=["GET"])
def serve_form():
    return render_template("form.html", form=ReusableForm(request.form))

@app.route("/", methods=['POST'])
def generate_text(): # model, w2vmodel, length=75, max_seq_length=20, temp=1, seed="Rain drop drop top"):
    """
    Function to output text trained by the neural network. Starts with a randomly selected capital letter.
    Input:
        model: fit keras model object
        length: int. how long the output text should be. Default is 500 characters.
        seed: the beginning of the generated lyrics. Set to be Migos' viral phrase "rain drop, drop top",
            but will eventually be user input when hosted
    Global variables:
        vocab_size: int. How long the vocab size is
        seq_length: int. Input size for model

        ADD additional loop for lines (basically change seed each time)
    """
    load_model()
    global w2vmodel
    w2v_weights = w2vmodel.wv.syn0

    form = ReusableForm(request.form)
    print(form.errors)
    #initialize data dictionary that will be returned by app
    data = {"success": False}

    if flask.request.method =='POST':
        seed=request.form['seed']

        length=int(request.form['length'])
        temp=float(request.form['temperature'])
        #add some catches for text in those boxes
        print('Starting with seed: ', seed)

        generated = '\n'

        generated += seed

        seed = clean_seed(seed)

        #shorten if longer than max_seq_length
        seed = seed.split(' ')[:max_seq_length]

        word_ix_list = []
        for word in seed:
            try:
                word = word_to_ix(word,w2vmodel)
            except:
                #since we're using -1 as a null word (why we also pad with the not in vocab), we'll use that for words that aren't in the word2vec model
                print('Warning: {0} not contained in training vocabulary. It will be ignored when computing output.'.format(word))
                word = word_to_ix('_UNSEEN_',w2vmodel)
            word_ix_list.append(word)

        #pad word_list with the unseen word2vec if shorter than max_seq_length
        word_ix_list = [word_to_ix('_UNSEEN_',w2vmodel)] * (max_seq_length-len(word_ix_list)) + word_ix_list

        for word in range(length):
            #reshape wordlist
            word_ix_list = np.asarray(word_ix_list).reshape(1,max_seq_length)

            #prediction = model.predict(x=word_ix_list)
            #next_ix = np.argmax(prediction)
            prediction = model.predict(x=word_ix_list,verbose=0)[0]
            next_ix = sample(prediction, temp)
            predicted_word = ix_to_word(next_ix,w2vmodel)

            generated += (' ' + predicted_word) #add predicted word to the generated output

            #remove first word from the word list to reduce the array for the max sequence length for the model
            word_ix_list = np.append(word_ix_list,next_ix)
            word_ix_list.shape
            word_ix_list = np.delete(word_ix_list,0,0)

        return render_template('success.html', generated=generated)
{% endhighlight %}

{% highlight python %}
if __name__ == '__main__':
    print("* Loading Keras model and Flask starting server..."
        "please wait until server has fully started")
    load_model()
    app.run()
{% endhighlight %}
