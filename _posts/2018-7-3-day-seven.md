Today is about trying new methods for getting a running photometry code. After reading [Marta's blog](https://gosnellgroup-marta.blogspot.com/) yesterday, the first thing that I thought was "this will be useful for learning astrometry," but I realized this morning that the process she went through to produce her code is almost exactly what I'm doing. So, I decided to use a few ideas that I got from reading her blog to help my coding today. With these ideas in mind, I spent much of today looking back at [photometry_practice_updated.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20practice/photometry_practice_updated.py) (the first code I was working with) and writing new versions of it that focus only on specific aspects of photometry and whose annotations focus only on explaining how the code does what it does rather than me describing what I went through to make the code work (what I'm calling "clean annotation"). These will be more useful in actually performing photometry on the data relevant to this project.  

## Github 
I decided to create a new [folder](https://github.com/GosnellResearchGroupSummer2018/NGC6819/tree/master/photometry%20codes) called "photometry codes" in the [NGC6819 repo](https://github.com/GosnellResearchGroupSummer2018/NGC6819) that contains the new, cleanly annotated photometry codes that I'm writing. I'm still going to keep [photometry_practice_updated.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20practice/photometry_practice_updated.py) in the photometry practice [folder](https://github.com/GosnellResearchGroupSummer2018/NGC6819/tree/master/photometry%20practice) and continue to work on it as both a way of continuing to learn photometry and a way to keep a record of what I did while learning it, but the codes in [photometry codes](https://github.com/GosnellResearchGroupSummer2018/NGC6819/tree/master/photometry%20codes) will serve a different purpose. They'll be what we actually use on our data to extract information from the measurements and may be more informative. There will be multiple codes because each one will perform a specific task. I may write a master code that does everything at once, but I can't predict right now whether or not that will be useful. 

## Working on Code
One of the things I realized after reading [Marta's blog](https://gosnellgroup-marta.blogspot.com/) is that so far I've been putting too much hope in [photometry_practice_updated.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20practice/photometry_practice_updated.py) to give me finished photometry after it runs properly, but I need to branch out to new resources -- I can use Google to find other codes or websites like astronomy.net to help me write this code then frankenstein whatever I find in with the code I'm writing to make something that actually works and that I understand. This realization is why I decided to create [photometry codes](https://github.com/GosnellResearchGroupSummer2018/NGC6819/tree/master/photometry%20codes). 

Since the first part of [photometry_practice_updated.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20practice/photometry_practice_updated.py) deals with source detection, writing a code that just just detects sources in an image was my first goal. Marta helped me out a lot here; she helped me figure out how to bring .fits files into the [new code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py) and worked with me to try to make the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py) iterative so the code processes all the .fits files in a particular directory at once. 

The first version of [source_detection.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py) was only meant to draw in one .fits file and detect all 5σ sources in it (note: this link will always go to the most modern version of source_detection.py). Using this [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py), I was able to make the first diagram that used data relevant to this project:  
![sources](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/sources.png) ![raw_data](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/rawdata.png)
_2D array showing 5σ sources circled in blue (radius 3 arcseconds) vs raw data from the .fits file_

---
_note: I find it rather odd that towards the edges of the diagram there are these very square 90° corners between regions of high source density and low source density. But, if you look closely, you can see that in the raw data, there does seem to be more stars in those regions, though they're less bright. I think that this must mean that the raw data is a composite of multiple images taken at different times; maybe the patches of sky near the edges of the frames were observed for longer and so detected more photons. That would explain the square corners, but it creates other problems: are the flux readings all messed up around the edges? i.e. all the stars in the edge regions register as brighter than they would if they were nearer to the center of the field of view. That would not be a problem if my background estimation were based on location in the frame, but so far it isn't. I have a few ideas about how to fix it, assuming I'm right about the cause of the strangeness._  

I did get a few errors when I ran this first version of the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py), but that's because I'm very crudely subtracting the background out of this image using sigma clipping. The function `stats.sigma_clipped_stats()` gives outputs "`median`, `mean`, and `std`," whose names are very misleading. From the photutils reference material on [background estimation](https://photutils.readthedocs.io/en/stable/background.html): "one may consider using the image median as the background level and the image standard deviation as the 1-sigma background noise." These outputs are scalar values and are considered constant throughout the [raw image](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/first_attempt_at_HST_source_detection/rawdata.png). Usually, these are overestimates the true value of the background noise or level. Also, I'm not sure what the difference between "background noise" and "background level" is at this point, though according to the resource on [photutils background estimation](https://photutils.readthedocs.io/en/stable/background.html), there is a significant difference between the numerical values of the two (In their example, the `median` and `std` they got were 5.2255295184 and 2.1443728009 respectively), and they're being used differently in the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py).  In this version of the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py), I was merely subtracting the median from each datapoint and finding sources based on the result. Inevitably, some of these values were negative given the fact that the background was overestimated, so when certain mathematics like logarithms and square roots were performed on them, they were considered errors. Reading the error messages, it looks like the math that requires positive values (like all fluxes should be when measured in the direction we are) are located in astropy's `stats.sigma_clipped_stats()`, photutils' `DAOStarFinder("fwhm", "threshold")`, and a few other less important places. This shouldn't be a problem later. 

After this, I looked again at the [background estimation resource](https://photutils.readthedocs.io/en/stable/background.html) and saw another method to perform the same type of background subtraction. To see the difference, I adjusted my [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py) according to the guidelines set out in the [resource](https://photutils.readthedocs.io/en/stable/background.html) and get the same type of errors (values being out of range/negative), but this time the errors are fatal and I get no image because of how photutil's `mad_std(data)` and `biweight_location(data)` commands work. Also, the problematic data points were automatically masked (somehow) before I changed it. At any rate, the way I was doing it before is more accurate according to the [resource](https://photutils.readthedocs.io/en/stable/background.html), so I just put the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py) back to way it was.

As a final remark on this version of the [code](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20codes/source_detection.py), I originally had it save a text file labeled "sources" to the desktop that had all of the fluxes (in counts) of each source and their pixel location, among other things. I decided to remove this feature because the main goal of this program is to detect the sources and show where they are, and I think there's no better way to show that information than a picture. It will matter soon what exactly the fluxes of these sources are in particular bands, but right now I'm only worried about showing where the sources are. Once I am more accurately able to subtract the background flux of the image, I'll add that feature back so we can save the flux values; it's still in [photometry_practice_updated.py](https://github.com/GosnellResearchGroupSummer2018/NGC6819/blob/master/photometry%20practice/photometry_practice_updated.py). 
