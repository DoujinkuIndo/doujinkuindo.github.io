---
layout: post
title: Channels
tags: [golang, concurrency, goroutines, channel]
---


## Channels là gì
Channel có thể hiêu là những đường ống (pipes) để các Goroutines giao tiếp với nhau. Giống như nước chảy từ đầu này qua đầu kia của một đường ống, data co thể được gửi từ đầu này qua đầu kia bằng cách sử dụng `channels`

## Khai báo channels

Mỗi channel định nghĩa một kiểu dữ liệu. Kiểu dữ liệu là kiểu mà data được phép "chảy" qua nó. Không có kiểu dữ liệu nào khác ngoài kiểu dữ liệu của channel thể chuyển qua nó. 

`chan T` là một chanel kiểu `T`. Chúng ta có thể sử dụng hàm `make` để khởi tạo giá trị, giống như `maps` and `slices`. Ví dụ:

```go
a := make(chan, int)
```
Đoạn code trên định nnghiax một channel int tên `a`. 

## Gửi nhận data trong channel


Syntax để gửi và nhận data từ một channel như sau:

```go
data := <- a // read from channel a
a <- data // write to channel a
```

Hướng của mũi tên chỉ hướng data gửi hay nhận.

## Gửi và nhận data block by default

Khi data được gửi tới một channel, the control block cho tới khi Goroutinne khác đọc từ channel đó. Tương tự, khi data được đọc ở một channel, nó sẽ được block cho tới khi một Goroutine nào đó viết data vào channel đó.
Thuộc tính này giúp Goroutine giao tiếp một cách hiệu quả mà không cần khai báo tường minh môt lock hoặc biến điều kiện (conditional variables) khá phổ biến ở những ngôn ngữ khác.
Cùng đọc tiếp để hiểu rõ hơn về channel. 

## Ví dụ về channel

Đây là chương trình lần trước sử dụng `Sleep()` function. 
```go
package main

import (  
    "fmt"
    "time"
)

func hello() {  
    fmt.Println("Hello world goroutine")
}
func main() {  
    go hello()
    time.Sleep(1 * time.Second)
    fmt.Println("main function")
}
```

Viêt lại chương trình bằng cách sử dụng channel.

```go
package main
import (
  "fmt"
)

func hello(done chan bool) {
  fmt.Println("hello world goroutine")
  done <- true
}

func main() {
  done := make(chan, bool)
  go hello(done)
  <- done
  fmt:Println("main function")
}
```
Trong chương trình này, chúng ta tạo `done` là một bool channel và pass nó vào `hello` Goroutine. Trong `main` Goroutine, dòng 14, chúng ta nhận gía trị từ channel `done`. Dòng code này được block cho tới khi một Goroutine nào đó ghi dữ liệu vào, the control sẽ không di chuyển tới dòng code tiếp theo. Do đó, chúng ta không cần sử dụng `time.Sleep` để tránh main Goroutine kết thúc chương trình.

Chú ý, dòng 14, `<- done` đọc data từ channel `done` nhưng không store lại vào bất kì biết nào, điều đó hoàn toàn hợp lệ.

Bây giờ, main Goroutine bị block và đợi cho tới khi `hello` Goroutine nhận channel này là một paramters, in `hello world goroutine` và ghi dữ liệu vào `done` channel. Sau khi ghi xong, main Goroutine nhận data, unblocked and text `main funnction` được in, chương trình kết thúc.

Ouput của chương trình
```shell
Hello world goroutine
main function

Program exited.
```

Chỉnh sửa một chút bằng cách thêm `Sleep` vào `hello` Goroutine.

```go
package main

import (
	"fmt"
	"time"
)

func hello(done chan bool) {
	fmt.Println("hello go routine is going to sleep")
	time.Sleep(4 * time.Second)
	fmt.Println("hello go routine awake and going to write to done")
	done <- true
}
func main() {
	done := make(chan bool)
	fmt.Println("Main going to call hello go goroutine")
	go hello(done)
	<-done
	fmt.Println("Main received data")
}
```

Output của chương trình:
```shell
Main going to call hello go goroutine
hello go routine is going to sleep
hello go routine awake and going to write to done
Main received data

Program exited.
```

