---
layout: post
title: Algorithm
---

* 알고리즘 문제 풀 때, 풀이방법을 정의하고 해결방법을 찾는게 아니라 문제를 명확히 이해하고, 적용할 수 있는 방법을 찾아야 합니다.

## 백준 1039번 문제

0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.
1 ≤ i < j ≤ M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 이때, 바꾼 수가 0으로 시작하면 안 된다.
위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.

16375   ,1     -> 76315
132     ,3     -> 312
432     ,1     -> 423
90      ,4     -> -1
5       ,2     -> -1
436659  ,2     -> 966354

(1) i, j는 서로 다르며 정수입니다.  
(2) i, j는 숫자의 범위안에 있다.    
(3) i, j번 째 숫자를 서로 교체한다. 
    - j가 앞에있는 숫자고 i가 뒤에있는 숫자입니다.  
    - 이때 0이 앞으로 나오지 않습니다.  
(4) 이를 K번 시행한다.  
(5) (4)를 모든 경우에서 시행했을 때 나올 수 있는 최대값을 구합니다. 

a. (1)에 의해서 i와 j는 서로 달라야 합니다.     
자리수가 1자리 수일 때 즉 M이 1일 때 i와 j 존재할 수 없습니다.  

b. (3)에서 큰 숫자가 앞으로 가고 작은 숫자가 뒤로 간다면, 숫자는 더 커집니다.   
변화량은 (I - J) * 10^(j - 1) + (J - I) * 10^(i - 1)입니다.   
I (10^(j-1) - 10^(i-1)) - J(10^(j-1)*10^(i-1))    
(I - J) (10^(j-1) - 10^(i-1))    
로 I > J일 때    
I - J > 0 이고 j - i > 0이므로 0보다 큽니다.        

c. (5)를 다르게 표현하면 모든 경우에서 매 시행마다 교환했을 때 나올 수 있는 변화량 dK들의 합     
dK_1 + dK_2 + ... dK의 합이 제일 큰 경우를 찾아야 합니다.       

d. 현 상태에서의 가능한 최대 변화량 dK_n+1은 이전 dK_n에 의해 변경됩니다.    
119를 예로 들면 911과 191은 다음번에 바뀔 수 있는 최대 변화량이 다릅니다.   

ㄱ. d.로 인해 현시점의 최대변화량을 구하더라도 전체 변화량의 합이 최대인지 알 수 없다고 생각합니다.

ㄴ. dK_1 + dK_2 + ...의 최대값, 즉 변화량 합을 구하는 방법은 d.에 dK_n+1 상태를 알 수 없다고 생각합니다.

ㄷ. ㄱ. ㄴ. 외의 방법은 모르겠습니다.

ㄹ. ㄱ. ㄴ. ㄷ.로 인해 모든 경우의 수를 구하는 방식을 이용해야 합니다.


## 단일 연결리스트 (Singly Linked List)
배열 구조의 단점을 개선하기 위해 등장한 자료구조입니다.
물리적으로 비연속적인 데이터를 논리적으로 연결한 구조입니다.
단방향의 구조입니다. (양방향은 이중 연결 리스트가 됩니다.)
배열로 구현이 가능한 것들은 모두 연결리스트로 구현할 수 있습니다.
에로 Stack, Qeueu, Deque, Tree등 있습니다.

### 엘든링의 인벤토리

# 이중 연결 리스트 (Doubly Linked List)
양방향 탐색을 위한 리스트입니다.
단일 연결리슽트는 next만 있던 반면, 이중 연결리스트는 next, prev가 있습니다.

https://www.youtube.com/watch?v=puyl7MBqPIg