---
layout: post
title: pibドライバを読む (第4.5回)
---

pibドライバを読んでいるところですが、そろそろApplicationからデバイスを「どう操作するのか」の話があった方が、説明が書きやすいため、Application層の話をする4.5回を設けます。ソースコードを読みやすいという理由からLinux Applicationをサンプルにし、著作権や正確性から、InfiniBand の PCI-expressボードを開発元である [Mellanox](http://www.mellanox.com/) の公開しています [RDMA Aware Networks Programming User Manual](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf) を抜粋します。

Linux Applicaionはコンパイル（リンク）する際に `-libverbs` を付与します。すると、Linux Applicationは VPI Verbs API という `ibv_` を接頭句としたAPIを利用することができますので、それらのAPIを利用して、デバイスを操作し、InfiniBandネットワークを利用します。

<!--break-->

さて、ソースコードとしては [RDMA Aware Networks Programming User Manual](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf) の 7.2節を参照してください。コードは対向ノードとのLIDの交換処理なども含まれておりますので、かなり長くなっておりますが、片側だけに着目してInfiniBandデバイスを「VPI Verbs API を行う」という視点では下記が抜粋となります。

- InfiniBandデバイスのリストを取得
- 自身が利用するInfiniBandデバイスをopen
- PD (Protection Domain)を作成
- CQ (Completion Queue)を作成 ... 処理完了通知Queue
- MR (Memory Region)を登録 ... 通信用バッファ
- QP (Queue-Pair)の作成 ... 送信要求/受信要求Queueを作成（処理完了はCQに格納）
- QPの遷移(RESET->INIT)
- QPの遷移(INIT->RTR) ... 対向ノード情報を設定
- QPの遷移(RTR->RTS)
- 準備完了

```c
dev_list = ibv_get_device_list(&num_devices);
...
res->ib_ctx = ibv_open_device(ib_dev);
...
res->pd = ibv_alloc_pd(res->ib_ctx);
...
res->cq = ibv_create_cq(res->ib_ctx, cq_size, NULL, NULL, 0);
...
res->mr = ibv_reg_mr(res->pd, res->buf, size, mr_flags);
...
qp_init_attr.qp_type = IBV_QPT_RC;
qp_init_attr.sq_sig_all = 1;
qp_init_attr.send_cq = res->cq;
qp_init_attr.recv_cq = res->cq;
res->qp = ibv_create_qp(res->pd, &qp_init_attr);
...
attr.qp_state = IBV_QPS_INIT;
rc = ibv_modify_qp(qp, &attr, flags);
...
attr.qp_state = IBV_QPS_RTR;
attr.path_mtu = IBV_MTU_256;
attr.ah_attr.dlid = dlid;
rc = ibv_modify_qp(qp, &attr, flags);
...
attr.qp_state = IBV_QPS_RTS;
rc = ibv_modify_qp(qp, &attr, flags);
...
```

なお、Queue-Pairの状態遷移については [InfiniBand の QP ステートの遷移を理解する](http://www.nminoru.jp/~nminoru/network/infiniband/iba-qp-states.html) が大変詳しく書かれております。RTSまで遷移しますと、対向ノードと通信可能となります。

最後に、メッセージ送信要求を格納して、CQをpollingすることで完了を待ち、通信が完了となります。この際、内部ではメッセージの送信の後、実際に相手にメッセージが到達したことを送信元に伝えるACKパケットが受信元から送信元へ変換され、CQにCompletionが格納されています。

```c
    <Client node>
    rc = post_receive(res);
    ...
    
    <Server node>
    if (post_send(&res, IBV_WR_SEND))
    ...
    
    <Both node>
    if (poll_completion(&res))
    ...
```

最後に補足ですが、InfiniBandのソフトウェアスタックの理念は非常に綺麗です。今回お見せした VPI Verbs API はlibibverbsというライブラリで処理されたのちに `libpib` のライブラリを呼び出し、実際にデバイスを操作しているのは`libpib` の制御が呼び出されます。VPI Verbs APIが直接デバイスを制御しないことで、Applicationには統一的なAPIを見せ、デバイス固有の処理をライブラリ層で一旦吸収した後、完全なデバイスのHardware制御（カーネルの介在が必要な部分）はドライバで行いますので、カーネルに入らずに高速に前準備をしたのちに、共有財産を制御する箇所のみカーネルに入る、という構造です。

参考までに、pibのみをインストールし、libpibをインストールしないと、`ibv_devinfo`を実行しても出力が何も得られません。

以上で、InfiniBandの操作の説明で、Queueの操作の概要が見えたと思います。次回はいよいよpibに戻って、Queue-Entryのお話になれるかもしれません。
