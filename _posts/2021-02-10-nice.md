---
layout: post
title: python-nice
tags: [blog, python]
---

## 1. 잘 하고 있나요?

지금까지 튜토리얼 을 완료했다면

적어도 `오...` 허풍은 아니게 될 겁니다.

그렇다면 잊지 않았는지 문제들로 점검해 봅시다.

### 1번

if 관련 문제 

다음중 알맞은 if의 사용법은?

~~~python
a = 100

b = 200

#1번
if a>B:
    print(a + "is bigger than" + b)
#2번
if a>b:
    print(a + "is bigger than" + b)
#3번
if A>B
	print(a + "is bigger than" + b)
#4번
if a > b:
    print(a + "is bigger than" + b)
~~~

정답은 ... 바로 2번과 4번입니다! 왜 그런지 한번 생각해보고, 아래로 내려가 확인하시면 됩니다!

#### 1번 해석

1번의 경우는 비교할때 변수명을 잘못 입력했네요.

파이썬에서는 대소문자 구별을 하기때문에

~~~python
TestString = 'TestString'
teststring = 'teststring'
~~~

위의 두가지를 다르게 인식합니다.

따라서 `b`가 아닌 `B`를 사용하였기에 오류가 발생합니다.

#### 3번 해석

if문은 `if 조건:print("hello")`처럼 한줄로 사용할수도 있지만 보통은

~~~python
if 조건:
    print("hello")
~~~

처럼 여러줄로 사용합니다.

자! 그러면 이전 코드와 비교했을때, 3번이 잘못된 까닭은

`:`을 빼먹었기 때문입니다. `:`은 코드가 여러줄로 이루어져 있는 경우, 구분하는 역할을 합니다.

앞서 소개한 if문을 한줄로 사용하는 방법이 허용되는 이유도 바로 이것! `:` 덕분이랍니다.

#### 2번과 4번의 공통점

여기, 몇줄 정도의 예시가 있습니다. 모두 똑같이 작동하죠.

~~~python
a = 1
b = 2
a=1
b=2

if a>b:
    print(a+"is bigger than"+b)
    
if a > b:
    print(a+"is bigger than"+b)
~~~

차이점을 눈치채셨나요? 바로 공백의 유무입니다.

기본적으로 파이썬에서는 공백이 있는경우와 없는경우 모두 허용됩니다.

그러나 일반적 ~~개인적~~으로는 변수 지정은 공백 을 사용하고, 조건문은 붙여서 사용합니다.

하지만 파이썬 패키지같은 경우는 파일 크기를 줄이기 위해

공백을 최소화하기도 하는데요, 이럴 경우에는 가독성이 ~~차라리 죽여줘~~.....

그러나 유지보수를 위해 다시 복구하는 경우(지원하는 에디터는 또는 확장은 알아서 해주기도 합니다.)

는.. 보통 최소화 하기전 소스코드를 사용해 개발을 하고, 배포할때만 죽이기에 큰상관 없답니다.

**다시 본론으로 돌아와서**보면 두가지의 큰 차이는 없습니다. 작성할때 편리한 방법을 사용하면 됩니다.

### 2번

try 관련 문제입니다.

다음중 에러가 발생하지 않는것은?

프로그램이 실행되는 폴더에 text.txt 파일이 있다고 가정하고 진행하겠습니다.

**이 문제는 틀려도 좋으니 편하게 풀어보세요.** ~~애초에 try구문 자체와 관련은 크지 않습니다~~

~~~python
#1번
try:
    k = open('text.txt','r')
    print(k.read())
except:
    print("error!")
#2번
try:
    k = open('text.txt','r')
    print(k.read())
except:
    print("error!")
finally:
    k.close()
~~~

#### 2번문제 해설

짜잔! 사실 둘다 각각의 코드만으로는 문제가 발생하지 않습니다.

그러나... 일반적으로 `with~as`를 많이 사용합니다. 지역변수 처리도 되고 

2번처럼 `finally`로 파일을 닫아줄 필요도 없으며 무엇보다 신경쓰지 않아도

**알아서** 닫아준다는 거죠. 하지만 꼭 try 구문을 써야할때라면 try 안에 with~as 를

사용하는것도 좋은 선택입니다. **다시 돌아와서** 1번은 저 자체로는 문제가 없습니다. 하지만

나중에 다시 `k.read`나 다른걸 사용하게 된다면 오류가 발생할 가능성이 **하늘을 찌르게** 됩니다.

따라서 2번을 사용하거나 아래와 같은 형식으로 사용해 보세요.

~~~python
try:
    with open('test.txt') as testtxt:
        #파일을 읽은후의 코드
except:
    print("Err")
~~~

이러한 방식을 사용한다면 text.txt가 없는 경우를 제외하고 에러가 발생하지 않겠죠?

### 3번

while 관련 문제입니다.

다음중 **정상적으로 작동하는**코드는 어느것 일까요?

