---
layout: post
title: "Algorithm & Data Structure - Topological Sort"
---

Topological sort is a way to sort a Directed Acyclic Graph (DAG) in the order based on all edge directions. For example, a graph below could be ordered in a way.

![dag-top](/images/dag-top.PNG)
![top](/images/topological.PNG)

A few properties of topological order:
 1. Only DAG has topological sort, because a cycle is not able decide the sequence of the node;
 2. Given one DAG, there might be many topological order. Uniqueness of topological order has other restrictions. 
 3. The sort always start from a node with 0 incomming edges. 

 The main application of topological order is to schedule/arrange tasks and courses, and to find the critical paths. 

### Uniqueness of topological order
  If every consective elements in a topological order is restricted by an edge in the graph, then the topological is unique, i.e., there is no more topological order for this graph. 

### Number of Topological orders
 The number of topological orders for a graph is dependent on the number of subtrees. Assume root node $$r$$ has $$n+1$$ nodes, then it has $$(n+1)!$$ to sort all the nodes, however the node orders are restricted by the edges or subtrees. Assume node $$r$$ has $$s$$ substrees and each subtree has $$k_i$$ nodes, each subtree has $$top(i)$$ topological sorts. The number of topological sorts of node $$r$$ is 
 $$
    top(r) = \frac{n!}{k_1!\times k_2! \times ....k_s!} \times  \prod_{i=1}^s top(i)
 $$

 The basic idea is: there are total $$n+1$$ nodes with $$(n+1)!$$ orders, but the root node is fixed, so now it reduced to total $$n!$$ orders, each subtree's node has $$k_i!$$ sorts, but it is replaced by the topological sorts. So divided by $$k_i!$$ and multiply by the subtree's topological sorts. 

## Algorithms for Topological sort

### Kahn's algorithm
 If observe the topological sort carefully, topological sort always starts from root element, i.e., an element without incomming edge/parent/root. This gives the basic idea of Kahn's algorithm. 
  1. Put all node with 0 incomming edge to a queue/set $$S$$;
  2. For each of the node in $$S$$, do:
     * Put this node to topological sort set $$T$$;
     * remove all associated (outgoing) edges of the node;
     * remove the edge from the other side of the node;
     * if new node with 0 incomming edge is generated, put it into Set $$S$$;
  3. Stop until all node with 0 incomming edge are visited. 
  4. If the graph still has edges, then there is at least one cycle exist;
  5. Otherwise, output the topological sort.

  This algorithm uses BFS to extract the topological sort from the outmost nodes to the innermost nodes. It is like peeling onions.

### DFS post order algorithm

 Recall post order trasverse is to visit the current node after all its children are visited. This is actually a reverse of topological order. Therefore, it is naturally to use DFS to find topological sort.
    
    for (each node i in graph) 
       do DFS(i, graph, visited, path)
    
    function DFS(i, graph, visited, path, stack)
        if (i is in path) return cycle deteced;
        if ( i is visited) return

        for ( neighbor of i)
            DFS(neighbor, graph, visited, path)
        remove i from path
        push i to stack

 The topological order is the reverse of the stack. 


## Examples

* Leetcode - 207

![Leetcode-207](/images/Leetcode-207.PNG)

This is a straight forward application of topological order algorithm. 
```java
    public boolean canFinish(int n, int[][] prerequisites) {
      
        List<Integer> [] graph = new List[n];
        for (int i = 0; i < n; i++)
            graph[i] = new LinkedList<>();
        
        for(int []  req : prerequisites)
            graph[req[0]].add(req[1]);
        
        boolean[] visited = new boolean[n];
        boolean[] path = new boolean[n];
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                if (dfs(i, graph, visited, path)) return false;                
            }
        }
        return true;        
    }
    
    private boolean dfs(int i, List<Integer>[] graph, boolean[] visited, boolean[] path) {
        if (i == graph.length) return false;        
        if (path[i]) return true;
        if (visited[i]) return false;
        visited[i] = true;
        path[i] = true;
        for (int nei : graph[i]) {
            if (dfs(nei, graph, visited, path)) {
                return true;
            }
        }
        path[i] = false;
        return false;
    }
```

* Leetcode - 210

![Leetcode-210](/images/Leetcode-210.PNG)

Also a straight forward implementation
```java
 public int[] findOrder(int n, int[][] prerequisites) {
        
        List<Integer> [] graph = new List[n];
        for (int i = 0; i < n; i++)
            graph[i] = new LinkedList<>();
        
        for (int [] pre : prerequisites) {
            graph[pre[0]].add(pre[1]);
        }
        
        boolean[] visited = new boolean[n];
        boolean[] path = new boolean[n];
        
        Stack<Integer> courseOrder = new Stack<>();
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                if (dfs(i, courseOrder, graph, visited, path)){
                    return new int[]{};
                }
            }
        }
        
        int[] res = new int[n];
        int i = 0;
        for (int c : courseOrder) {
            res[i++] = c;
        }
        
        return res;
    }
    
    private boolean dfs(int i, Stack<Integer> courseOrder, List<Integer> [] graph, boolean[] visited, boolean[] path) {
        if (i == graph.length) return false;
        if (path[i]) return true;
        if (visited[i]) return false;
        
        visited[i] = true;
        path[i] = true;
        
        for (int nei : graph[i]) {
            if(dfs(nei, courseOrder, graph, visited, path))
                return true;
        }
        courseOrder.push(i);
        path[i] = false;
        return false;        
    }
```