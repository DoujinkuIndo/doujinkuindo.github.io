## Nginx 学习

nginx做本地目录映射

    有时候需要访问服务器上的一些静态资源，比如挂载其他设备上的图片到本地的目录，而本地的目录不在nginx根目录下，这个时候就需要简单的做一下目录映射来解决，比如想通过浏览器http://ip/image/e2/7d/c27df08cdae8ce784a199d8004ef4f81.jpg访问到系统目录/public/uploads/e2/7d/c27df08cdae8ce784a199d8004ef4f81.jpg需要在nginx.conf中添加location规则，配置如下：

```js
location /image/ {
    root /;
    rewrite ^/image/(.*)$ /image_data/$1 break;
}
```

location /image/设置服务器拦截含有/image/的请求，实际上范围根据实际情况确定精确度

root /;设定作用的根目录，rewrite就是真正的跳转规则，设置以uploads为开头的请求跳转到/uploads开头的根目录，后面的参数原封不动的添加过去，这样就实现了目录的映射，

使用上面的规则可以很方便的映射到本地指定的多个用于静态访问的目录

保存之后使用 ./nginx -s reload 重新载入配置文件，访问指定的url就访问到了

#nginx+php升级后错误An error occurred.解决办法
PHP的PHP-FPM服务是启动成功的，nginx也是启动成功的，折腾了几次，看nginx错误日志，发现有权限错误～
查看php-fpm.conf文件中相关配置，得出解决办法：

;listen.user = nobody
;listen.group = nobody
去掉前面的;号，然后将用户和用户组换成你的用户和用户组即可！

# 官网支持PHP的配置
location ~ .php$ {
#root html;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
include fastcgi_params;
}

然而在对nginx添加fastCGI的支持后，然后进行php页面验证，发现页面识别不到
报错信息：[error] 12691#0: *6 FastCGI sent in stderr: "Primary script unknown" while reading response header from upstream, client: 192.168.168.1, server: localhost, request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:9000", host: "192.168.168.133"
错误原因及解决方法：
fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
而Nginx识别不到/scripts路径，所以phpinfo验证信息就无法正常通过，需要修改如下：
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;

Note:
$document_root 代表当前请求在root指令中指定的值。
我们这里为系统默认，
location / {
       root   /usr/local/nginx/html;
       index  index.php index.html index.htm;
        }
所以该语句就是针对/usr/local/nginx/html目录下的php文件进行解析。

# nginx error_log 错误日志配置说明
error_log  /home/wwwlogs/nginx_error.log  crit;
nginx的error_log类型如下（从左到右：debug最详细 crit最少）： 
[ debug | info | notice | warn | error | crit ] 
例如：error_log logs/nginx_error.log  crit; 
解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息； 

注意error_log off并不能关闭日志记录功能，它将日志文件写入一个文件名为off的文件中，如果你想关闭错误日志记录功能，应使用以下配置： 
error_log /dev/null crit; 
把存储位置设置到Linux的黑洞中去 

另外，还可以自定义，例如在nginx.conf中自己定义log_format  main/log_format  proxy/log_format  real等等。例子这里暂且不放出来。

# server
每个server就是一个站，vhost的api配置还可以这样写：
```js
set $version_port '8194';
if ($http_version ~ '^1\.([0-8]\.[0-9]|9\.[0-1])(\.[0-9]*)?$') {
    set $version_port '8191';
}
if ($http_version ~ '^1\.9\.2(\.[0-9]*)?$') {
    set $version_port '8192';
}
if ($http_version ~ '^1\.9\.3(\.[0-9]*)?$') {
    set $version_port '8193';
}
if ($http_version ~ '^1\.9\.4(\.[0-9]*)?$') {
    set $version_port '8194';
}
location / { 
    proxy_pass  http://127.0.0.1:$version_port ;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Real-Port $remote_port;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    #if (!-e $request_filename) {
    #    rewrite  ^(.*)$  /index.php?s=$1  last;
    #    break;
    #}
}

error_log  /home/wwwlogs/zmd-api-error.log;
access_log  /home/wwwlogs/zmd-api-access.log proxy;
```