---
layout: post
title: Python 点滴
---

Python 学习笔记--Class


1. **Python Class 特性点滴**

	支持多重继承
    
    如果没有指定父类，则默认object作为父类
    
    新式类必须继承至少一个父类，直接继承自object的类称为经典类。
    
    创建一个对象： `Myboject = MyNewObject()`。注意没有new操作符。
    
    python支持垃圾回收机制，创建的实列没有被其他变量引用时将被自动回收
    
    最简单的类仅仅作为一个名字空间存在，可以在该类中声明变量，就像在C语言中定义的结构体一样。它仅仅作为容器对象来共享名字空间。
    
    ```
    class MyDate(object):
    	pass
        
    Myobj = MyData()
    Myobj.x = 4
    Myobj.y = 5
    Myobj.x + Myobj.y ## == 9
    Myobj.x * Myobj.y ## == 20
    ## x, y 为实例属性，而非类属性，实例属性是动态的，不需要在构造其构造器中或其他地方为他们事先声明
	```
    
    方法定义在类中（即定义在类中的函数），但只能被实例调用（无有static 方法？有的）。必带一个 *self* 参数。该参数指实例本身，由解释器自动传入。
    
    Pyhon 类没有构造器，但有一个类似构造器的特殊方法 *\_\_init\_\_()* 在创建一个新对象时被调用，即在实例创建后，在实例化过程中被调用来做一些额外的工作，其调用是在实例化调用返回实例之前。可认为，实例化是对*\_\_init\_\_()*方法的隐式调用。**定义 *\_\_init\_\_()* 方法时依然要给出 *self* 参数**。
    
    子类如果没有定义*\_\_init\_\_()* 函数，则父类的*\_\_init\_\_()*函数将被调用；如果子类实现自己的*\_\_init\_\_()*函数——即子类重写（覆盖）了父类的*\_\_init\_\_()*函数，则必须显式调用才会执行父类的*\_\_init\_\_()*函数。
    
    ```
    ***类和函数的相同处：***
    
    	声明类似——头一行一个相应的关键字，接下来是作为它的定义的代码体；
        都允许在其定义中创建函数，闭包或者内部方法，还有类中定义方法；
    
    ***不同处：***
    
    	你运行函数
        而会用类来创建一个对象
        类就像一个Python 容器类型
	```
    
    Python Class不支持纯虚函数或抽象方法，你可以在基类方法中引发 *NotImplementError* 异常来获得类似的效果。
    
2. **Class对象**
	
    类就像一个Python容器类型。
    
    类是一个对象，就如同函数是一个对象一样。**Python 中，一切都是对象。**
    
    **Class的定义和声明**
    	含class关键字的首行为声明
        跟在首行后的类体（代码块）为定义（不包含类文档）
    
    属性包括对象的数据和函数元素。
    
    有趣的是属性也是一个对象，它包含有自己的属性，这样就形成一个属性链。
    
    类属性仅仅与类相绑定，它和任何实例都无关。属于“静态”数据。相当与java或C++程序中被冠以static关键字的变量。
    
    类属性相其他任何普通变量一样，在类被创建后即可被使用。并且可由类方法跟新，也可以在主程序中其他地方被更新。
    
    类属性通常用来跟踪与类相关的值。
    
    类定义中定义的函数称为类的函数属性（方法）；
    
    方法虽然是类的属性，但不能通过类来直接调用，因其没有与类直接bind（绑定）。方法必须绑定到一个实例才能被调用。非绑定的方法可能可以被调用，但一定要给出实例变量作为第一个入参（还记得 ***self*** 形参吗？）。
    
    获取一个类都有那些属性有两种方法： *dir()* 内建函数；及访问类的 *\_\_dict\_\_* 字典属性——所有类具有的特殊属性之一。
    
    内建函数 *vars()* 接受对象作为参数，返回该对象的类的 *\_\_dict\_\_* 属性内容。
    
    文档字符串不能被派生类继承。
    
    访问类属性时，解释器会在类的 *\_\_dict\_\_* 属性中搜索，如果没找到，则从父类的 *\_\_dict\_\_* 属性中搜索，采用深度优先的搜索顺序，基类集合是采用定义时的顺序从左到右的进行搜索。
    
    
    
    
    
    