---
layout: post
title: 프로그래밍 언어론 4장
---

## 이름

- 정적 바인딩(static binding) : 이름과 대상의 연결 작업이 실행시간 이전에 일어나는 바인딩
- 동적 바인딩(dynamic binding) : 이름과 대상의 연결 작업이 실행시간에 일어나는 바인딩

#### 4.1 구문문제

프로그램에서 이름은 변수, 타입, 함수 등과 같은 다양한 대상들을 가리키기 위하여 사용된다.이번 절에서는 이름의 기본적인 형태를 공부한다. 이름은 다른 말로 식별자(identifier)라고도 부른다.

많은 언어들은 하나 또는 다수의 특수 문자를 식별자에 포함시키는 것을 허용한다. 하지만 일부는 그 사용에 있어서 일정한 제한을 둔다.

- **예약어(reserved words) , 키워드(keywords) : 특별한 의미를 가지며 일반적인 식별자로 사용될 수 없는 미리 정의된 이름들의 집합***ex) int, if, while, for ... etc*

<br/>

#### 4.2 변수

변수의 이름을 정하는 작업은 매우 중요하다. 변수는 객체 지향 언어에서 가장 기본이 되는 요소이다. 이런 언어들에서 변수는 메모리의 위치 또는 메모리블록 위치들의 집합을 나타내는 이름으로 사용된다.

- 변수 : **변수(variable)**는 메모리 주소에 이름을 붙인 것이다. 또한 변수는 타입, 값, 수명을 가진다.

모든 프로그램 변수는 다음과 같은 네가지의 기본적인 연결 요소를 가진다.

- 이름
- 주소
- 타입(type)
- 값

```
  x = y + 1;
  (x의 주소에 y의 주소에 있는값에 1을 더해서 할당하라)
```
<br/>

#### 4.3 유효범위

프로그래머들이 같은 이름을 재사용할 수 있도록 하기 위하여 이름의 유효범위의 개념이 사용되었다.

- **한 이름의 유효범위(scope)란** 그 이름을 통해 연결된 대상을 접근할 수 있는 문장들의 집합을 말한다.

- **정적 유효범위 지정(static scoping)**은 이름의 유효범위가 소스 프로그램 내의 이름의 위치에 의하여 정해지는 것을 말한다.

현대의 언어들은 정적 유효범위 지정을 사용한다. 정적 유효범위 지정은 프로그램의 문법적인 구조에 기반하고 있으므로, 구문적인 유효범위 지정(lexical scoping)이라고도 한다.

<br/>

``` c
#include <iostream>

int a; == a의 유효범위 시작

int main() {
  int b; ** b의 유효범위 시작
  if(b == 0) {
    int c; -- c의 유효범위 시작

  } -- c의 유효범위 끝
} ** b의 유효범위 끝
== a의 유효범위 끝
```

모든 프로그램 문장은 **선행 참조(forward reference)**를 포함할 수 없다. C++과 Java같은 경우에도 이름에 대한 선언은 블록 내 임의의 위치에 나올 수 있느나, 선행 참조는 허용되지 않는다.<br/>
*cf) 선행 참조 : 이름이 선언되기 전에 이름에 대한 참조가 나오는 것*

```cs
using System;

class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine(a); //불가능
        int a;
        Console.WriteLine(a); //가능
    }
}
```

<br/>

#### 4.4 Symbol Table

컴파일러의 의미 분석 단계(semantics analyzing)의 임무 중의 하나는 선언된 모든 이름과 그 바인딩 정보를 저장한 Symbol Table을 만드는 것이다.

- Symbol Table은 번역기에 의하여 유지되는 자료 구조로서 모든 선언된 이름들과 그 연결 정보를 관리하는 역할을 한다.

local scope를 위한 자료  구조로는 사전이나 집합 자료구조의 구현을 모두 사용할 수 있고 이 경우 이름이 키 값으로 사용된다. 주어진 이름에 대해 우리는 사전 자료구조에 그 이름과 연결되있는가 질의한다. 이에 대하여 자료구조는 현재 유효범위에서 그 이름이 선언되었을 경우에 이에 대한 바인딩을 반환한다.

<br/>

#### 4.5 주소의 도출
  참조 환경은 주어진 이름의 참조가 가능한 일련의 문장들의 집합을 정하는 중요한 역할을 한다.


```c
1   int h,i;
2   void B(int w) {
3     int j, k;
4     i = 2*w;
5     w = 2+1;
6     ...
7   }
8   void A (int x, int y) {
9     float i,j;
10    B(h);
11    i = 3;
12    ...
13  }
14  void main() {
15    int a,b;
16    h =5; a= 3; b = 2;
17    A(a,b);
18    B(h);
19    ...
20 }
```

<br/>

##### 함수를 위한 기호표의 스택 구조

```
  Function      |                     Symbol Table Structure
 ---------------|------------------------------------------------------------
                |     <w, 2>,   <j, 3>,   <k, 3>    
     B          |     <h, 1>,   <i, 1>,   <B, 2>,   <A, 8>,  <main, 14>
 ---------------|------------------------------------------------------------
                |     <x, 8>,   <y, 8>,   <i, 9>,   <j, 9>   
     A          |     <h, 1>,   <i, 1>,   <B, 2>,   <A, 8>,  <main, 14>
 ---------------|------------------------------------------------------------ 
                |     <a, 15>,  <b, 15>  
    main        |     <h, 1>,   <i, 1>,   <B, 2>,   <A, 8>,  <main, 14>
 ---------------|------------------------------------------------------------
                |
```