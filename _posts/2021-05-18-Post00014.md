---
userMath: true
layout: post
title: "Algorithm & Data Structure - Boyer - Moore Majority Vote Algorithm"
---


## Problem statement
 
   Given a series of data representing the candidates that is voted. Find the candidate with majority votes. Majority means more than 50%. The data could be stream data. 

An inuative appraoach is to count and record the number of candidates and once any candidate exceed 50% of total votes, that's the majority candidate. This approach could be done in linear time, but need O(k) space, where k is number of candidates. 

Another simpler approach that solves this problem is invented by Boyer and Moore and called Boyer-Moore majority vote algorithm. The basic principle behand this algorithm is: if there exists a candiate has votes more than half, then this candidate's vote is more than all other candidates' votes. Mathematically, 

 $$  N_{majority} - \sigma {N_{others}} > 0 $$

This equation telles us that if we assume a majority, we could use a counter to verify whether this is a true majority by performing:

```java
    for (int num : nums) {
        if (num == majority) counter++;
        else counter--;
    }
```
If the counter is more than 0, that means it is a majority, else it is not. Following this rule, when the counter is 0, we haven't find majority, and we could assume the current number is majority, and go to verify it afterwards. If the majority exists afterward, it's vote should still more than half of the remain votes.

```java

    int counter = 0;
    int majority = -1;

    for (int num : nums) {
        if (majority == num) counter++;
        else if (counter == 0) {
            counter++;
            majority = num;
        } else {
            counter--;
        }
    }

```

 * LeetCode - 169

Use the alroghrim above directly.

 * Leetcode - 229





