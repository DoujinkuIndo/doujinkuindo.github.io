---
layout: post
title: My structure for DDD component
categories: [ddd]
tags: [python, ddd, component, code architecture]
---
Draft of a post in answer to a StackOverflow
<a href="https://stackoverflow.com/questions/59776634/ddd-with-python-did-i-get-it-right">
question</a>. You can find code used in this example
<a href="{{ site.github.repository_url }}/tree/master/examples/ddd_component">here</a>.

# Package structure
In component package I use this modules as starting point.
- migrations/
- app.py
- commands.py
- events.py
- exceptions.py
- repository.py
- service.py
- uow.py

# Commands
A command is always DTO and as specific, as it can be from a domain perspective. I aim to create separate classes for commands so I can just dispatch handlers by command class.

{% highlight python %}
@dataclass
class Create(Command):
    command_id: CommandID = field(default_factory=uuid1)
    timestamp: datetime = field(default_factory=datetime.utcnow)
{% endhighlight %}
<a href="{{ site.github.repository_url }}/tree/master/examples/ddd_component/commands.py">commands.py</a>

# Application service
This is a facade for our component. It's a starting point cause all our BDD tests will be base on Facade API and all communication with our component is going through the facade.
 Applications service I implement in two objects. Command Handler is calling our unit of work with command and takes care of persistency and other IO communication (like emits events). Command Handler is only changing state of aggregate and replies with events generated by processed commands.
The second object is the Query Handler. This one is only for a read. If you need some views for this component state you can use it. Depends on implementation it can use different DB if there is a need.
The point of application service is to create stable API for component and protecting boundaries so it can be easily refactored later.
If you know that component should be developed in DDD structure, but it's overkill at begging you can start with application service as stable API and use only DB model directly inside. If you will create stable boundaries for a component then it will be easy for a safe refactor.

{% highlight python %}
class CommandHandler:
    def __init__(self, repository: Repository) -> None:
        self._repository = repository
        self._listeners: List[Listener] = []
        super().__init__()

    def register(self, listener: Listener) -> None:
        if listener not in self._listeners:
            self._listeners.append(listener)

    def unregister(self, listener: Listener) -> None:
        if listener in self._listeners:
            self._listeners.remove(listener)

    @safe
    @singledispatchmethod
    def handle(self, command: Command) -> Optional[Event]:
        uow: UnitOfWork = self._repository.get(command.uow_id)

        event: Event = app_event(self._handle(command, uow), command)
        for listener in self._listeners:
            listener(event)

        self._repository.save(uow)
        return event

    @safe
    @handle.register(Create)
    def create(self, command: Create) -> Event:
        uow = UnitOfWork.create()
        self._repository.save(uow)
        return Created(command.command_id, uow.id)

    @singledispatchmethod
    def _handle(self, c: Command, u: UnitOfWork) -> UnitOfWork.Event:
        raise NotImplementedError

    @_handle.register(UpdateValue)
    def _(self, command: UpdateValue, uow: UnitOfWork) -> UnitOfWork.Event:
        return uow.update(command.value)
{% endhighlight %}
<a href="{{ site.github.repository_url }}/tree/master/examples/ddd_component/service.py">service.py</a>

# Aggregate
{% highlight python %}
UnitOfWorkID = NewType('UnitOfWorkID', UUID)


class UnitOfWorkDTO:
    id: UnitOfWorkID
    value: Optional[Text]


class UnitOfWork:
    id: UnitOfWorkID
    dto: UnitOfWorkDTO

    class Event:
        pass

    class Updated(Event):
        pass

    def __init__(self, dto: UnitOfWorkDTO) -> None:
        self.id = dto.id
        self.dto = dto

    @classmethod
    def create(cls) -> 'UnitOfWork':
        dto = UnitOfWorkDTO()
        dto.id = UnitOfWorkID(uuid1())
        dto.value = None
        return UnitOfWork(dto)

    def update(self, value: Text) -> Updated:
        self.dto.value = value
        return self.Updated()
{% endhighlight %}
<a href="{{ site.github.repository_url }}/tree/master/examples/ddd_component/uow.py">uow.py</a>


# Repository
{% highlight python %}
class ORMRepository(Repository):
    def __init__(self, session: Session):
        self._session = session
        self._query = self._session.query(UnitOfWorkMapper)

    def get(self, uow_id: UnitOfWorkID) -> UnitOfWork:
        dto = self._query.filter_by(uuid=uow_id).one_or_none()
        if not dto:
            raise NotFound(uow_id)
        return UnitOfWork(dto)

    def save(self, uow: UnitOfWork) -> None:
        self._session.add(uow.dto)
        self._session.flush()
{% endhighlight %}

{% highlight python %}
entities_t = Table = Table(
    'entities',
    meta,
    Column('id', Integer, primary_key=True, autoincrement=True),
    Column('uuid', String, unique=True, index=True),
    Column('value', String, nullable=True),
)

UnitOfWorkMapper = mapper(
    UnitOfWorkDTO,
    entities_t,
    properties={
        'id': entities_t.c.uuid,
        'value': entities_t.c.value,
    },
    column_prefix='_db_column_',
)
{% endhighlight %}
<a href="{{ site.github.repository_url }}/tree/master/examples/ddd_component/repository.py">repository.py</a>
