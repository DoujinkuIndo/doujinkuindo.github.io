## 1. 作用
1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务
2. 可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存导致服务器崩溃

## 2. Demo
    ExecutorService executorService = Executors.newFixedThreadPool(5);

## 3. 六个核心参数
1. <b>corePoolSize</b>
    1. 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize
    2. 如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行
    3. 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程
2. <b>maximumPoolSize</b>
    1. 池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量
    2. 当任务数量比corePoolSize大时，任务添加到workQueue
    3. 当workQueue满了，将继续创建线程以处理任务，maximumPoolSize表示的就是wordQueue满了，线程池中最多可以创建的线程数量
3. <b>keepAliveTime</b>
    1. 只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。当线程数大于corePoolSize时，终止前多余的空闲线程等待新任务的最长时间
4. <b>unit</b>
    1. keepAliveTime的单位
5. <b>workQueue</b>
    1. 用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列
        1. ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务
        2. LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene
        3. SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene
        4. priorityBlockingQuene：具有优先级的无界阻塞队列
6. <b>threadFactory</b>
    1. 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名
7. <b>说明</b>
    1. 池中线程数小于corePoolSize，新任务都不排队而是直接添加新线程
    2. 池中线程数大于等于corePoolSize，workQueue未满，首选将新任务加入workQueue而不是添加新线程
    3. 池中线程数大于等于corePoolSize，workQueue已满，但是线程数小于maximumPoolSize，添加新的线程来处理被添加的任务
    4. 池中线程数大于大于corePoolSize，workQueue已满，并且线程数大于等于maximumPoolSize，新任务被拒绝，使用handler处理被拒绝的任务
8. <b>线程池的饱和策略</b>
    1. AbortPolicy：直接抛出异常，默认策略
    2. CallerRunsPolicy：用调用者所在的线程来执行任务
    3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
    4. DiscardPolicy：直接丢弃任务
    5. 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务
