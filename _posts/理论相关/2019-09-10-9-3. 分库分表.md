## 1. 索引表法
- 思路：userId直接定位到库，userName不能直接定位到库，如果通过userName能查询到userId，问题解决
- 解决方案：
    - 建立一个索引表记录userName->userId的映射关系
    - 用userName来访问时，先通过索引表查询到userId，再定位相应的库 
    - 索引表属性较少，可以容纳非常多数据，一般不需要分库
    - 如果数据量过大，可以通过userName来分库
- 潜在不足：多一次数据库查询，性能下降一倍

## 2. 缓存映射法
- 思路：访问索引表性能较低，把映射关系放在缓存里性能更佳
- 解决方案： 
    - userName查询先到cache中查询userId，再根据userId定位数据库 
    - 假设cache miss，采用扫全库法获取userName对应的userId，放入cache 
    - userName到userId的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高 
    - 如果数据量过大，可以通过userName进行cache水平切分
- 潜在不足：多一次cache查询

## 3. userName生成userId
- 思路：不进行远程查询，由userName直接得到userId
- 解决方案： 
    - 在用户注册时，设计函数userName生成userId，userId=f(userName)，按userId分库插入数据 
    - 用userName来访问时，先通过函数计算出userId，即userId=f(userName)再来一遍，由userId路由到对应库
- 潜在不足：该函数设计需要非常讲究技巧，有userId生成冲突风险

## 4. userName基因融入userId
- 思路：不能用userName生成userId，可以从userName抽取“基因”，融入userId中
- 假设分8库，采用userId%8路由，潜台词是，userId的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”。
- 解决方案： 
    - 在用户注册时，设计函数userName生成3bit基因，userName_gene=f(userName) 
    - 同时，生成61bit的全局唯一id，作为用户的标识 
    - 接着把3bit的userName_gene也作为userId的一部分 
    - 生成64bit的userId，由id和userName_gene拼装而成，并按照userId库插入数据 
    - 用userName来访问时，先通过函数由userName再次复原3bit基因，userName_gene=f(userName)，通过userName_gene%8直接定位到库
