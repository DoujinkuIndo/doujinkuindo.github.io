## 1. 栈溢出(StackOverflowError)
- 程序所要求的栈深度过大导致
-       import java.util.*;
        import java.lang.*;    
        public class OOMTest{     
            public void stackOverFlowMethod(){    
                stackOverFlowMethod();    
            }    
            public static void main(String... args){    
                OOMTest oom = new OOMTest();
                oom.stackOverFlowMethod();   
            }    
        }  

## 2. 堆溢出(OutOfMemoryError:java heap space)
- 内存溢出(out of memory):指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory
- 内存泄露(memory leak):指程序在申请内存后，无法释放已申请的内存空间,memory leak会最终会导致out of memory
    + 静态集合类引起内存泄漏
    + 当集合里面的对象属性被修改后，再调用remove()方法时不起作用
    + 在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会
    + 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的
    + 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用
    + 不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏

## 3. 永久代溢出(OutOfMemoryError: PermGen space)
- 持久带溢出有可能是运行时常量池溢出，也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置
    + 使用一些应用服务器的热部署的时候，我们就会遇到热部署几次以后发现内存溢出了，这种情况就是因为每次热部署的后，原来的class没有被卸载掉
    + 如果应用程序本身比较大，涉及的类库比较多，但是我们分配给持久带的内存（通过-XX:PermSize和-XX:MaxPermSize来设置）比较小的时候也可能出现此种问题
    + 一些第三方框架，比如spring,hibernate都通过字节码生成技术（比如CGLib）来实现一些增强的功能，这种情况可能需要更大的方法区来存储动态生成的Class文件
-       import java.util.*;    
        import java.lang.*;    
        public class OOMTest{    
                public static void main(String... args){    
                        List<String> list = new ArrayList<String>();    
                        while(true){    
                                list.add(UUID.randomUUID().toString().intern());    
                        }    
                }        
        }  

## 4. OutOfMemoryError: unable to create new native thread
1. 可能原因
    1. 系统内存耗尽，无法为新线程分配内存
    2. 创建线程数超过了操作系统的限制
2. 解决方案
    1. 排查应用是否创建了过多的线程:通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。
    2. 调整操作系统线程数阈值:操作系统会限制进程允许创建的线程数，使用ulimit -u命令查看限制。某些服务器上此阈值设置的过小，比如1024。一旦应用创建超过1024个线程，就会遇到java.lang.OutOfMemoryError: unable to create new native thread问题。如果是这种情况，可以调大操作系统线程数阈值
    3. 增加机器内存:如果上述两项未能排除问题，可能是正常增长的业务确实需要更多内存来创建更多线程。如果是这种情况，增加机器内存
    4. 减小堆内存:线程不在堆内存上创建，线程在堆内存之外的内存上创建。所以如果分配了堆内存之后只剩下很少的可用内存，依然可能遇到java.lang.OutOfMemoryError: unable to create new native thread。考虑如下场景：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存
    5. 减小线程栈大小:线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）