## 1. wait()、notify()和notifyAll()
1. wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写
2. wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的
3. 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态
4. 只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况
5. notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现

## 2. clone()
1. clone与copy的区别（指向内存中同一个对象）
2. Shallow Clone与Deep Clone
    - Shallow Clone是简单地执行域对域的copy，但是reference变量还是会指向内存中同一个对象
    - Deep Clone 重写clone方法

## 3. finalize()
- 用于释放资源