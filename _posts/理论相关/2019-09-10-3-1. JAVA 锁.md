## 1. 乐观锁
- 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
如果失败则要重复读-比较-写的操作。
- java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作， CAS（V, A, B），V为内存地址、A为预期原值，B为新值。如果内存地址的值与预期原值相匹配，那么将该位置值更新为新值。否则，说明已经被其他线程更新，处理器不做任何操作

## 2. 悲观锁
- 悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人
会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。
- java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，
才会转换为悲观锁，如 RetreenLock

## 3. 自旋锁
- 自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），
等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗
- 线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程
也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间
- 如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

## 4. Synchronized 同步锁
- 他属于独占式的悲观锁，同时属于可重
入锁
- 作用于方法时，锁住的是对象的实例(this)。当该类中有多个普通方法被Synchronized修饰（同步），那么这些方法的锁都是这个类的一个对象this。多个线程访问这些方法时，如果这些线程调用方法时使用的是同一个该类的对象，虽然他们访问不同方法，但是他们使用同一个对象来调用，那么这些方法的锁就是一样的，就是这个对象，那么会造成阻塞。如果多个线程通过不同的对象来调用方法（一般都是通过同一个对象访问），那么他们的锁就是不一样的，不会造成阻塞
- 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen
（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，
会锁所有调用该方法的线程；

## 5. ReentrantLock
- ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁
- Lock 接口的主要方法
    - void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有,就一直等待
    - boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false
    - void unlock()：执行此方法时, 当前线程将释放持有的锁.

## 6. Semaphore 信号量
- Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信
号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来
构建一些对象池，资源池之类的，比如数据库连接池
- 实现互斥锁（计数器为 1）

    