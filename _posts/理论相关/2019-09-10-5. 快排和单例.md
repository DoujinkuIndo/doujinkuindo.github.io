## 1. 快排
    private static void quickSort(int[] array, int left, int right){
        if(left < right){
            int key = array[left];
            int low = left;
            int high = right;
            while(low < high){
                while(low < high && array[high] > key){
                    high--;
                }
                if(low < high){
                    array[low++] = array[high];
                }
                while(low < high && array[low] < key){
                    low++;
                }
                if(low < high)
                    array[high--] = array[low];
            }
            array[low] = key;
            quickSort(array,left,low-1);
            quickSort(array,low+1,right);
        }
    }

## 2. 单例
    // 饿汉模式
    public class Singleton1 {
        // 类加载的初始阶段会分配内存，在类被初始化时就已经在内存中创建了对象
        private static Singleton1 uniqueInstance = new Singleton1();
    
        private Singleton1() {
        }
    
        public static Singleton1 getInstance() {
            
            return uniqueInstance;
        }
    }
    
    // 静态内部类模式
    public class Singleton2 {

        private Singleton2() {
        }
        // 当调用外部类的构造函数是，外部类的静态代码块同时被加载，但是其内部类不会同时被加载；
        // 当且仅当内部类的静态域或其构造方法或其静态方法被调用时，内部内才被加载
        private static class SingletonContainer{
    
            private static Singleton2 instance = new Singleton2();
        }
    
        public static Singleton2 getInstance() {
    
            return SingletonContainer.instance;
        }
    }
    
    // 双重锁懒汉模式(Double Check Lock)
    public class Singleton3 {
        private static volatile Singleton3 instance = null;
    
        // 可以有自己的属性
        private String context;
    
        public String getContext() {
            return context;
        }
    
        public void setContext(String context) {
            this.context = context;
        }
    
        private Singleton3() {
        }
    
        public static Singleton3 getInstance(){
            if(instance == null){
                synchronized(Singleton3.class){
                    if(instance == null){
                        // 非原子这个步骤
                        // 其实在jvm里面的执行分为三步：
                        //  1.在堆内存开辟内存空间。
                        //  2.在堆内存中实例化SingleTon里面的各个参数。
                        //  3.把对象指向堆内存空间。
                        //
                        //由于jvm存在乱序执行功能，所以可能在2还没执行时就先执行了3，如果此时再被切换到线程B上，由于执行了3，
                        // INSTANCE 已经非空了，会被直接拿出来用，
                        //这样的话，就会出现异常。这个就是著名的DCL失效问题
                        instance = new Singleton3();
                    }
                }
            }
            return instance;
        }
    }