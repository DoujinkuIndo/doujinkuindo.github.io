## 1. JMM
1. ![image](http://upload-images.jianshu.io/upload_images/4222138-96ca2a788ec29dc2.png)


## 2. 多线程实现方式
1. 继承Thread
2. 实现Runnable接口
3. 实现Callable接口（future）

## 3. volatile
1. volatile变量自身具有下列特性
    1. 可见性:对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
    2. 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性
2. volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存
3. volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量

## 4. CAS
1. CAS，全称Compare And Swap（比较与交换），解决多线程并行情况下使用锁造成性能损耗的一种机制
2. 实现思想 CAS（V, A, B），V为内存地址、A为预期原值，B为新值。如果内存地址的值与预期原值相匹配，那么将该位置值更新为新值。否则，说明已经被其他线程更新，处理器不做任何操作；无论哪种情况，它都会在 CAS 指令之前返回该位置的值。而我们可以使用自旋锁，循环CAS，重新读取该变量再尝试再次修改该变量，也可以放弃操作
3. CAS 适合简单对象的操作，比如布尔值、整型值等
4. CAS 适合冲突较少的情况，如果太多线程在同时自旋，那么长时间循环会导致 CPU 开销很大

## 5. AQS
- volatile Node 同步队列
- volatile int state

## 6. CountDownLatch
1. 当一个线程需要另外一个或多个线程完成后，再开始执行。比如主线程要等待一个子线程完成环境相关配置的加载工作，主线程才继续执行，就可以利用 CountDownLatch 来实现

## 7. CyclicBarrier
1. CyclicBarrier可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用
2. 可以用于多线程计算数据，最后合并计算结果的场景

## 8. CyclicBarrier 与 CountDownLatch 区别
1. CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的
2. CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的


