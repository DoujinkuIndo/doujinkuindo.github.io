## 1. String的创建
1. new String都是在堆上创建字符串对象
2. 通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串
3. 常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用
4. 对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）
5. 常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象

## 2. String.intern()
- intern方法会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与1.7之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池

## 3. StringBuilder是线程不安全的，而StringBuffer是线程安全的

## 4. 常见面试题
-     String s1 = “abc”; 
      String s2 = “abc”; 
      System.out.println(s1 == s2);true，均指向常量池中对象
-     String s1 = new String(“abc”); 
      String s2 = new String(“abc”); 
      System.out.println(s1 == s2);//false，两个引用指向堆中的不同对象
-     String s1 = “abc”; 
      String s2 = “a”; 
      String s3 = “bc”; 
      String s4 = s2 + s3; 
      System.out.println(s1 == s4);//false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象
-     String s1 = “abc”; 
      final String s2 = “a”; 
      final String s3 = “bc”; 
      String s4 = s2 + s3; 
      System.out.println(s1 == s4);//true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4
-     String s = new String(“abc”); 
      String s1 = “abc”; 
      String s2 = new String(“abc”); 
      System.out.println(s == s1.intern());//false 
      System.out.println(s == s2.intern());//false 
      System.out.println(s1 == s2.intern());//true 
