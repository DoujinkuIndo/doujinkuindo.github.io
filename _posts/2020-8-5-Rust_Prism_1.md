---
layout: post
title: PRISM - My Hobby Path Tracer
---

This will be the first in a series of posts about the path tracer I'm currently working on. In this specific post I will go over the basic design philosophy of PRISM and why I chose to write the renderer in Rust.

When I started reading [*Physically Based Rendering: Theory to Implementation*](http://www.pbr-book.org/), I knew I wanted to do something active along the way so that I may better absorb the information. Now, this could've been me just taking notes in some notebook, but I thought this was too boring. I could've also done the exercises at the end of each chapter, but then I wouldn't be doing anything active while I was reading the chapter. So I decided to write my own renderer alongside. Initially the renderer was written in C++ in Visual Studio. For each section of the book I would add what I had just read into my renderer. I did this for a while (I believe the code for it is still on my [github page](https://github.com/DennisVanEe)) but soon got disillusioned by the project. The first problem was that I wouldn't see the result of my work until much later (you have to get through quite a bit of the book before you are able to render something if you follow it along chronologically). The other problem was that I was essentially rewriting pbrt verbatim. Sure, I could try and do something more contrived to write different code, but this felt like empty work and was akin to plagiarizing an essay by rewording a sentence or two. So, what do I do?

First, I decided to heed a past mentor's advice: write something quick that renders *something*, then build on that. So, my renderer would initially have the bare feature set to get something up and running. I'm not going to add a full path tracing integrator with support for all of pbrt's materials initially. This has a number of advantages:
1. It allows me to debug faster. Instead of hoping everything works after adding most of PRISM's features, I can iteratively check if each component works as I add features.
2. It gives me a clear view of the progress my renderer is making, which helps keep me motivated.

Second, I decided to write the renderer in a different language. Not only would this be the perfect opportunity for me to learn a new programming language, it would prevent me from simply copying pbrt's code (at least, somewhat, I still didn't want to just translate C++ code to whatever language I decided to use. How I overcame this I will explain later). Thus, came the matter of picking a language to use. I wanted a language that ran directly on the metal (no software interpreter), allowed me to interop with C libraries, and that was supported by [Godbolt's Compiler Explorer](https://gcc.godbolt.org/) (it's a convenient tool to use and I think it's just plain cool to see how my code translates to assembly instructions). It ultimately came down to a decision between Go and Rust. All the projects in my distributed systems class were in Go and I loved how fast it was to write and how fast it compiled. I was well aware that Go used a garbage collector, but I was going to use the philosophy of "no memory allocations during rendering" so I thought I could avoid the garbage collector during the actual rendering phase. What ultimately moved me away from Go was the lack of support for generics. I know that they will be added eventually (and when they are I might revisit Go), but I had just gotten so used to programming with templates in C++ that I wanted a language with this feature as well. Thus, I ultimately landed on Rust.

Now, Rust's generics don't support all of the features that C++'s templates do (especially when looking at C++20), but the features that are present are good enough for my use case and the inclusion of traits makes generic programming easier.