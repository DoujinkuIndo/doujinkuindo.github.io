---
layout: post
title: PRISM - My Hobby Path Tracer
---

This will be the first in a series of posts about the path tracer I'm currently working on. The path tracer itself is still in the early stages. I will start by documenting what is already present in the path tracer (not in this post, however) and all further developments on this blog. This post is mostly an introduction to my path tracer: PRISM.

When I started reading [*Physically Based Rendering: Theory to Implementation*](http://www.pbr-book.org/), I knew I wanted to do something active along the way so that I may better absorb the information. Now, this could've been me just taking notes in some notebook, but I thought this was too boring. I could've also done the exercises at the end of each chapter, but then I wouldn't be doing anything active while I was reading the chapter. So I decided to write my own renderer alongside. Initially the renderer was written in C++ in Visual Studio. For each section of the book I would add what I had just read into my renderer. I did this for a while (I believe the code for it is still on my [github page](https://github.com/DennisVanEe)) but soon got disillusioned by the project. The first problem was that I wouldn't see the result of my work until much later (you have to get through quite a bit of the book before you are able to render something if you follow it along chronologically). The other problem was that I was essentially rewriting pbrt verbatim. Sure, I could take pbrt's source code and make it more contrived to write different code, but this felt like empty work and was akin to plagiarizing an essay by rewording a sentence or two. So, what do I do?

First, I decided to heed a past mentor's advice: write something quick that renders *something*, then build on that. So, my renderer would initially have the bare feature set to get something up and running. I'm not going to add a full path tracing integrator with support for all of pbrt's materials initially (actually, the first thing my renderer ever spit out what that ball at the top of my blog. It's just the world normals of some sphere mesh). This has a number of advantages:
1. It allows me to debug faster. Instead of hoping everything works after adding most of PRISM's features, I can iteratively check if each component works as I add features.
2. It gives me a clear view of the progress my renderer is making, which helps keep me motivated.

Second, I decided to write the renderer in a different language. Not only would this be the perfect opportunity for me to learn a new programming language, it would prevent me from simply copying pbrt's code (the latter point could still be seen as plagiarism, like translating a French essay into English and calling it my own). Thus, came the matter of picking a language to use. I wanted a language that ran directly on the metal (no software interpreter), allowed me to interop with C libraries, and that was supported by [Godbolt's Compiler Explorer](https://gcc.godbolt.org/) (it's a convenient tool to use and I think it's just plain cool to see how my code translates to assembly instructions). It ultimately came down to a decision between Go and Rust. All the projects in my distributed systems class were in Go and I loved how fast it was to write and how fast it compiled. I was well aware that Go used a garbage collector, but I was going to use the philosophy of "no memory allocations during rendering" so I thought I could avoid the garbage collector during the actual rendering phase. What ultimately moved me away from Go was the lack of support for generics. I know that they will be added eventually (and when they are I might revisit Go), but I had just gotten so used to programming with templates in C++ that I wanted a language with this feature as well. Thus, I ultimately landed on Rust.

For those of you who aren't familiar with Rust: it's a programming language being developed by Mozilla that tries to be a "safer" and more modern version of C++. Instead of, mostly, relying on runtime checks for this, Rust is designed in such a way that you are "forced" to take into account potential safety issues (mainly to do with resource ownership). The main component of Rust that handles this is the so-called "borrow checker". I won't go into too much detail on the Rust language itself and my experience using it for PRISM (all that will come in a future post); instead, all I'll say is that the restrictions Rust enforces when writing safe code has made me rethink the design and philosophy of PRISM. What I have learned programming in Rust I will carry with me to other projects in other languages.

Third, and lastly, I just didn't copy everything from pbrt. For every component of pbrt I would check if there was a paper discussing a potentially better implementation of that component. I intend this renderer to be the base to which I can add new features from research papers. So far I've added filter importance sampling and a progressive multi-jittered sampler. I would also just not read certain sections of the book until after I implemented what that section covered. This way I can compare and contrast my own implementation with the book's and see which best fits my renderer's philosophy. For instance, I wrote my own threading system for PRISM before reading about pbrt's threading system.

All of the above should, ultimately, allow me to call PRISM my own creation. Though anyone familiar with pbrt will certainly find similarities between it and PRISM. If you want to check out PRISM's code, you can just visit [my github](https://github.com/DennisVanEe). My next post on PRISM will likely dive more into Rust and, specifically, how I interfaced with embree and rply (using embree is another way that I steered away from pbrt!).