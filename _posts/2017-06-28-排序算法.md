---
layout: post
title: 排序算法
date:   2017-06-28 19:28:00 +0800
categories: 面试
tag: 学习笔记 java 算法
---

* content
{:toc}
# 各种排序算法思路及代码实现

## 1. 冒泡排序

- 主要思路：

  通过交换使相邻的两个数编程小数在前大数在后，这样每次遍历活，最大的数就“浮”到了最后，类似于气泡在水中浮到水面的过程。重复n次即可以使数组有序。

- 关键代码

  ```java
  for (i = 0; i < n; i++)
  			{
  				for (j = 1; j < n - i; j++)
  				{
  					if (array[j-1] >= array[j])
  					{
  						int temp = array[j];
  						array[j] = array[j-1];
  						array[j-1] = temp;
  					}
  				}
  			}
  ```

- 完整实现
  <https://github.com/dzqoo/career/blob/master/BubbleSort.java>

## 2. 插入排序

* 主要思路

  每次将一个待排序的数据，插入到前面已经排号序的序列中，直到全部数据插入完成

* 关键代码

  ~~~java
  for(int i=0;i<n;i++){
  	for(int j=i;j>0 && array[j-1]>array[j];j--){
  				int temp = array[j];
  				array[j] = array[j-1];
  				array[j-1] = temp;
  	}
  }
  ~~~

* 完整实现
  <https://github.com/dzqoo/career/blob/master/InsertSort.java>

## 3.选择排序

* 主要思路
  数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变成有序区。

* 关键代码

  ~~~java
  for(i=0;i<n;i++){
  		min = i;
  		for(j=i+1;j<n;j++){
  				if(array[j]<array[min]){
  					min = j;
  				}
  		}
  		int temp = array[i];
  		array[i] = array[min];
  		array[min] = temp; 
  }
  ~~~

* 完整实现
  <https://github.com/dzqoo/career/blob/master/SelectSort.java>

## 4.快速排序

* 基本思想
  挖坑填数+分治法（取自<http://blog.csdn.net/morewindows/article/details/6684558>）

  * 先从数列中取出一个数作为基准数，常常是第一个数
  * 分区过程中，将比这个数大的数全部放到它的右边，小于或者等于它的数全部放在它的左边
  * 再对左右区间重复第二部，直到各区间质疑后一个数

* 关键代码

  ~~~java
  if (l < r)
  		{
  			int i = l, j = r;
  			int mid = array[l];
  			while (i < j)
  			{
  				while (i<j && array[j] >= mid)
  				{
  					j--;
  				}
  				array[i] = array[j];
  				while (i<j && array[i] <= mid)
  				{
  					i++;
  				}
  				array[j] = array[i];
  			}
  			array[i] = mid;
  			quick(array, l, i - 1);
  			quick(array, i + 1, r);
  		}
  ~~~

* 完整实现
  <https://github.com/dzqoo/career/blob/master/QuickSort.java>

## 5.归并排序

* 主要思路
  当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序

* 关键代码

  ~~~java
  ##1.合并数组
  int i = left, j = mid + 1;
  		int m = mid, n = right;
  		int k = 0;
  		while (i <= m && j <= n)
  		{
  			if (array[i] <= array[j])
  			{
  				temp[k++] = array[i++];
  			}
  			else
  			{
  				temp[k++] = array[j++];
  			}
  		}
  		while (i <= m)
  		{
  			temp[k++] = array[i++];
  		}
  		while (j <= n)
  		{
  			temp[k++] = array[j++];
  		}
  		for (i = 0; i < k; i++)
  		{
  			array[left + i] = temp[i];
  		}
  ##2.递归调用
  if (left < right)
  	{
  			int mid = (left + right) / 2;
  			merge(array, left, mid, temp);
  			merge(array, mid + 1, right, temp);
  			mergearray(array, left, mid, right, temp);
  	}
  ~~~

* 完整实现
  <https://github.com/dzqoo/career/blob/master/MergeSort.java>







​