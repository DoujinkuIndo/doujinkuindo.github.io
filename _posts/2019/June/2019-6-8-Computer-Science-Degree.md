---
layout: post
title: Defense of a Computer Science Degree 
date: June 8 2019 
time: 21:17 UTC-4 
---

Note: This was written in vim entirely. I am running on a Raspberry Pi with Raspbian installed. So I will probably make a few extra errors.
So this may be biased, because I currently am in a 4 year program for Computer Science at a public university. However, as much as I believe a four year education is not necessary to modern life, it's a little twisted in the computer field. There is a lot of demand for computer programmers, and not so much for computer scientists. And that leads to the argument that theory is not as important as schools make it out to be. I for one am against that train of thought. The level of theory may not be important, but undergraduate education in computer science, is important to teach the basics of computing. I do think schools do a poor job of executing this, and computer science is plagued by many people only in it for the paycheck. 

But I for one got to use some theory at work this week, and it's never felt so good to be able to take something that runs in $$O(n)$$ and bring it down to $$O(\log n)$$. The way it worked was we had to bring in a table to search against. We tried to just pattern match, but it turned out that pattern matching from ReasonML, when compiled to Javascript does not work in $$O(\log n)$$ or $$O(1)$$ as expected in a functional language. Instead it does a ton of `if ... else if ... else if ... ... else`. So I originally had the idea because all of the data was linear in indexing, as in `1...n`, that I could just put them into a big array and do $$O(1)$$ indexing on it. That costs a good amount of memory, so I scratched that idea. I came up with a hacky binary search tree. We tried putting into a hashmap, but we got a stack overflow error. So I wrote a little Python script that made a recursive binary search tree. This took us from $$O(n)$$ to $$O(\log n)$$, and space complexity was basically free, we had to suffer a bloating of a few thousand lines of code in the code base however. We're still searching for a better solution, but it was very nice to use some theory and come up with a fast and efficient solution to this problem, although hopefully temporary. So it was extremely gratifying to use what I've learned over the years, and the fun I've had at ICPC Algorithmic competitions, to some real world aspect.

So I don't want to say that theory is the end all and be all. Alas, ~90% of regular programming is draining, and soul crushing, and is already mostly automated. And in the case of Perl, could probably be written by monkeys(if not already). But I think this push that everyone needs to program is terrible for everybody. No, only those who have a little passion should get into it. Not everyone needs to be a doctor, and you can make more money as a doctor. For the same reasons, computer science is not something everyone needs to know, like basic maths, science, english, etc. You need to be able to do simple algebra to live in the modern world. You need to be able to write documents and such to live today. You do not need to know the ins and outs of a terminal, or how to write C, to live. The worst thing that can happen, which is already happening is a lot of new programmers are entering the field and writing garbage fire code. This hurts the field, more than it helps society. Same thing if we pushed everyone into being a doctor. You do not want me to be your doctor. I lack the passion, and skills to be so. And unfortunately, without those two things, no level of school can turn you into one.   

![My Raspberry Pi]({{ site.url }}/images/rasp-pi.png) 
