---
layout: post
title: "Algorithm & Data Structure - Extreme Value Problem - Type II"
---

This type of problems require to find the maximum/minimum pair from a list or array of values with some conditions. It certainly could be solved by brutal force, but that is not an optimized solution. Swipe from both end of the list or array could help to speed up the process. The basic idea is to reuse the previous information to obtain the current minimum/maximum results. Similar to dynamic programing approach.  
 1. At current location $$i$$, previous extreme value upto $$i-1$$ is already known;
 2. By adding $$ith$$ element, how to update the extreme value?

Let's start from a simple example similar to Stock buy sell problem:
 Find the maximum pair difference from an array. 

Brutal force would be simple, two loops give the answer, but it takes O(n^2). 
```java
    int maxDiff = 0;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++) {
            maxDiff = Math.max(nums[i]-nums[j], maxDiff);
        }
```
Look at the inner loop, it starts from 0 for every $$i$$. But we already scanned once for all previous elements, can we reuse the previous scan? We can store the minimum value and update it whenever a new element coming. We also need to update the maximum difference.

```java
    int maxDiff = 0;
    int minNum = nums[0];
    for (int i = 1; i < n; i++) {
        maxDiff = Math.max(nums[i]-minNum, maxDiff);
        minNum = Math.min(minNum, nums[i]);
    }
```

* Leetcode - 1014

 ![Leetcode - 1014](/images/Leetcode-1014.png)

This is similar to find the maximum pair sum with an additional condition. Obviously, two loops solve this problem but with O(n^2).
We can use dynamic programming similar above approach to solve it. If we seperate the maximum score into two parts:
 $$v_i + v_j + i - j = v_i + i + v_j - j$$

 We are trying to maximize these two pars with $$i < j$$. So for current $$j$$, we only need to use the maximum previous $$v_i+i$$ to calculate the current maximum score. Then we could update the maximum score for all current $$j$$.

 ```java
    public int maxScoreSightseeingPair(int[] values) {
        
        int maxScore = Integer.MIN_VALUE;
        int maxNum = values[0];
        for (int i = 1; i < values.length; i++) {
            maxScore = Math.max(maxScore, values[i]+maxNum-i);
            maxNum = Math.max(maxNum, values[i]+i);
        }        
        return maxScore;
    }
 ```

* Leetcode - 1937

 ![Leetcode - 1937](/images/Leetcode-1937.png)

 Using dynamic programming, this is relatively easy to find a brutal force solution which takes O(m*n^2).

 ```java
    public long maxPoints(int[][] points) {
  
        int m = points.length, n = points[0].length;
        
        long[][] dp = new long[m+1][n];
        
        for (int i = 1; i < m+1; i++) {
            
            for (int j = 0; j < n; j++) {
                int curMaxScore = Integer.MIN_VALUE;                
                for (int k = 0; k < n; k++) {
                    curMaxScore = Math.max(curMaxScore, dp[i-1][k] + points[i-1][j] - Math.abs(j-k));
                }
                dp[i][j] = curMaxScore;
            }
        }
        
        int maxScore = Integer.MIN_VALUE;
        
        for (int j = 0; j < n; j++) {
            maxScore = Math.max(dp[m][j], maxScore);
        }
        return maxScore; 
    }
 ```

 The inner third loop is to look for the maximum score for each of the column. If we break the absolute value temporary, we could also seperate the equation into two parts. 
 $$dp[i-1][k] + points[i-1][j] - (j-k) = dp[i-1][k] + k + points[i-1][j] - j$$
 
 Now, we are looking to maximumize this two parts, but with $$k <= j$$ because we break the absolute value. If we take the absolute on the other side:
  $$dp[i-1][k] + points[i-1][j] - (k - j) = dp[i-1][k] - k + points[i-1][j] + j$$ 
 with $$j <= k$$

This tells us that we need to scan from both sides. 
```java
    public long maxPoints(int[][] points) {
  
        int m = points.length, n = points[0].length;
        
        long[][] dp = new long[m+1][n];
        
        for (int i = 1; i < m+1; i++) {

            //scan from left to right
            long curMax = dp[i-1][0];
            dp[i][0] = dp[i-1][0]+points[i-1][0];
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + points[i-1][j];
                dp[i][j] = Math.max(dp[i][j], curMax + points[i-1][j]-j);
                curMax = Math.max(curMax, dp[i-1][j] + j);
            }

            //scan from right to left
            curMax = dp[i-1][n-1] - (n-1);
            for (int j = n-2; j >= 0; j--) {
                dp[i][j] = Math.max(dp[i][j], curMax + points[i-1][j]+j);
                curMax = Math.max(curMax, dp[i-1][j] - j);  
                
            }

        }
        
        long maxScore = Integer.MIN_VALUE;
        
        for (int j = 0; j < n; j++) {
            maxScore = Math.max(dp[m][j], maxScore);
        }
        return maxScore;       
        
    }
```



[link to Stock](2021-05-11-Post00007.md)
