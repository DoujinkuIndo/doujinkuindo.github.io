복잡도는 알고리즘과 자료구조를 평가하는 기준입니다. **어떠한 상황에 어떠한 문제해결이 적합한지 표시하기 위해서 사용합니다.**

|복잡도|설명|
|:-:|---|
|공간 복잡도(Space complexity)|알고리즘에 사용되는 메모리 총량|
|시간 복잡도(Time complexity)|알고리즘에 수행되는 연산 횟수 총량|

최선의 경우(Best cast)는 빅 오메가(Ω) 표기법으로 사용합니다. 최선의 시나리오로 최소 이만한 시간이 걸린다는 것을 나타냅니다. 최악의 경우(Worst case)는 빅 오(Big-O)표기법을 사용합니다. 최악의 시나리오로 아무리 오래 걸려도 이 시간보다는 덜 걸린다는 것을 나타냅니다. 평균적인 경우(Average case) 빅 세타(Θ)표기법을 사용합니다.

공간 복잡도(Space complexity)는 알고리즘에서 사용하는 메모리 양을 나타냅니다. 공간 복잡도는 보조공간(Auxiliary space)와 입력크기(input size)를 합친 포괄적인 개념입니다. 보조 공간(Auxiliary space)는 알고리즘이 실행되는 동안 사용하는 임시 공간을 말합니다.

빅오 표기법은 알고리즘의 효율성을 상한성을 기준으로 표기합니다. 일상의 대화에서 친구가 법정이자율을 물었을 때 빅세타 표기법으로는 0% 이상이라고 말하지만 빅오 표기법으로 말하면 30%이하라고 말하는 것과 같습니다.   시간복잡도와 공간복잡도의 최고차항만을 표기하여 간략하게 나타내는 표기법입니다.

**최악의 경우 알고리즘이 항상 제시간 안에 끝나는 것을 보장하기 위하여 얼마의 시간 걸리는지 아는 것은 중요합니다.** 그렇기 때문에 실시간 연산시 최악의 실행 시간은 중요 고려사항이 됩니다.

* **오늘날에는 공간 복잡도가 큰 문제가 되지 않습니다. 하지만 시간 복잡도는 자주 거론됩니다.** 시간복잡도는 큰 데이터를 처리할 때 중요합니다.

시간복잡도를 계산할 때는 중요한 요소와 규칙이 있습니다.

1. 중요한 요소는 반복문(for, while), 조건문(if), 재귀호출 입니다. 
2. 규칙은 시간복잡도에서 상수값은 무시되는 됩니다.
3. 실제 개발자가 짜 놓은 코드를 수행하는 것은 상수 시간으로 간주합니다.

예시 1
```cpp
int get_sub(int arr[], int n)   
{   
    int sum = 0;   
    int i = 0;   
    for (i = 0; i < n; ++i)   
    {   
        sum += arr[i];   
    }   
    return sum;   
}   
```
공간 복잡도 = n + 3 = [] + (n, sum, i)   
시간 복잡도 = n   

<br>

예시 2
```cpp
int get_sum(int n)   
{   
    int sum = 0;   
    int i;   
    for (i = 1; i <= n; i *= 2)   
        sum += i;   
   
    return sum;   
}   
```
시간 복잡도 = log_2(n)

시간복잡도는 시행횟수를 구하는 것으로 알 수 있습니다. 위의 경우 n이 1일때 1회(1) 실행되고, n이 2일때는 2회(1, 2), ... n이 9일때는 4회(1, 2, 4, 8, 16) 실행됩니다.
