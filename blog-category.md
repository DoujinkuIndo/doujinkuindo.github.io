---
layout: page
permalink: /blog/category
heading: Blog
---

<ul class="nav nav-tabs">
  <li class="active dropdown">
    <a class="dropdown-toggle" data-toggle="dropdown" href="#">Java EE&SE<span class="caret"></span></a>
    <ul class="dropdown-menu">
      <li><a data-toggle="tab" href="#java">JAVA</a></li>
      <li><a data-toggle="tab" href="#javatt">JAVA Tips&Trick</a></li>
    </ul>
  </li>
  <li><a data-toggle="tab" href="#spring">Spring</a></li>
  <li><a data-toggle="tab" href="#apache-guys">Apache Guys</a></li>
  <li class="dropdown">
    <a class="dropdown-toggle" data-toggle="dropdown" href="#">Android<span class="caret"></span></a>
      <ul class="dropdown-menu">
        <li><a data-toggle="tab" href="#android-tutorial">Android Tutorial</a></li>
        <li><a data-toggle="tab" href="#android-oneri">Android Öneriler</a></li>
        <li><a data-toggle="tab" href="#android-tt">Android Tips&Trick</a></li>
      </ul>
  </li>
  <li><a data-toggle="tab" href="#view-tech">View Tech.</a></li>
</ul>

<div class="tab-content" style="padding-top: 20px;">

  <div id="java" class="tab-pane fade in active">
    <div class="panel-group">
      <!-- servlet jsp yazıları -->
      <div id="servlet-jsp" class="panel panel-info">
        <div class="panel-heading">Servlet&JSP <span class="label label-info">19</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-giris-ve-temel-kavramlar/">Servlet Giriş ve Temel Kavramlar</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-ve-servlet-contanerin-gorevleri/">Servlet ve Servlet Contaıner'ın görevleri</a></li>
            <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/helloservlet/">Hello Servlet</a></li>
            <li>Chapter 3 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/form-ile-servlete-data-yollamak/">Form ile Servlet'e Data yollamak</a></li>
            <li>Chapter 4 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-lifecycle/">Servlet Lifecycle</a></li>
            <li>Chapter 5 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-lifecycle-2-how-servlet-works/">Servlet Lifecycle 2 &amp; How Servlet works?</a></li>
            <li>Chapter 6 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servletconfig/">ServletConfig</a></li>
            <li>Chapter 7 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servletcontext/">ServletContext</a></li>
            <li>Chapter 8 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-filter/">Servlet Filter</a></li>
            <li>Chapter 9 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/servlet-record-with-jdbc/">Record Servlet with JDBC</a></li>
            <li>Chapter 10 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/session-tracking-in-servlet/">Session Tracking in Servlet</a></li>
            <li>Chapter 11 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/httpsession-urlrewriting/">HttpSession &amp; URLRewriting</a></li>
            <li>Chapter 12 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-introduction/">JSP Introduction</a></li>
            <li>Chapter 13 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-scripting-element/">JSP Scripting Tag element</a></li>
            <li>Chapter 14 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-expression-tag/">JSP Expression Tag element</a></li>
            <li>Chapter 15 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-declaration-tag/">JSP Declaration Tag element</a></li>
            <li>Chapter 16 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-architecture-lifecycle/">Jsp Architecture and Lifecycle</a></li>
            <li>Chapter 17 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-implicit-object/">Jsp Implicit Object</a></li>
            <li>Chapter 18 : <a href="{{site.baseurl}}/blog/java-ee/servlet-jsp/jsp-directive/">Jsp Directive</a></li>
          </ul>
        </div>
      </div>

      <!-- play yazıları -->
      <div id="play" class="panel panel-info">
        <div class="panel-heading">Play Framework <span class="label label-info">5/9</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java-ee/play/play-framework-introduction/">Play Framework Introduction</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java-ee/play/play-framework-architecture/">Play Framework Architecture</a></li>
            <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java-ee/play/sbt-summary/">SBT Summary</a></li>
            <li>Chapter 3 : <a href="{{site.baseurl}}/blog/java-ee/play/play-framework-mvc/">Play Framework MVC</a></li>
            <li>Chapter 4 : <a href="{{site.baseurl}}/blog/java-ee/play/play-cache-api/">Play Cache Api</a></li>
            <li>Chapter 5 : <a href="{{site.baseurl}}/blog/java-ee/play/play-coffescript/">Play Views with CoffeScript</a></li>
            <li>Chapter 6 : <a href="{{site.baseurl}}/blog/java-ee/play/play-java-template/">Play Framework Java Templates</a></li>
            <li>Chapter 7 : <a href="{{site.baseurl}}/blog/java-ee/play/play-implicit-object/">Play İmplicit Object</a></li>
            <li>Chapter 8 : <a href="{{site.baseurl}}/blog/java-ee/play/simple-play-web-app/">Simple Play Web Application</a></li>
            <li>Chapter 9 : <a href="{{site.baseurl}}/blog/java-ee/play/play-tt/">Play Framework Tips&amp;Trick</a></li>
          </ul>
        </div>
      </div>

      <!-- jax rs yazıları -->
      <div id="jax-rs" class="panel panel-info">
        <div class="panel-heading">JAX-RS <span class="label label-info">6</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/jax-rs-introduction/">JAX-RS Introduction</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/hello-restful/">Hello RESTful</a></li>
            <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/restful-annotation/">RESTful Annotation</a></li>
            <li>Chapter 3 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/restful-crud-with-json/">RESTful Crud with Json</a></li>
            <li>Chapter 4 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/restfuljquery/">RESTFul with JQuery</a></li>
            <li>Chapter 5 : <a href="{{site.baseurl}}/blog/java-ee/jax-rs/restful-security/">RESTful Security</a></li>
          </ul>
        </div>
      </div>

      <!-- jax ws yazıları -->
      <div id="jax-ws" class="panel panel-info">
        <div class="panel-heading">JAX-WS <span class="label label-info">2</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java-ee/jax-ws/jax-ws-introduction/">JAX-WS Introduction</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java-ee/jax-ws/wsdl-file/">JAX-WS WSDL File</a></li>
          </ul>
        </div>
      </div>

      <!-- vaadin yazıları -->
      <div id="vaadin" class="panel panel-info">
        <div class="panel-heading">Vaadin <span class="label label-info">2</span></div>
        <div class="panel-body">
          <ul>
            <li>Vaadin 0 : <a href="{{site.baseurl}}/blog/java-ee/vaadin/vaadin-introduction/">Vaadin Introduction</a></li>
            <li>Vaadin 1 : <a href="{{site.baseurl}}/blog/java-ee/vaadin/vaadin-architecture/">Vaadin Architecture</a></li>
          </ul>
        </div>
      </div>

      <!-- core java yazıları -->
      <div id="core-java" class="panel panel-info">
        <div class="panel-heading">Core Java <span class="label label-info">6</span></div>
        <div class="panel-body">
            <h4><strong>6 October 2014</strong></h4>
              Merhaba , Java üzerine yazılarımı yazmaya başlıyorum. Core Java'ı kapsayacaktır yazılarım, umarım faydalı olur.

              Java yazıları boyunca değiniceğim konuların başlıklarını yazarak başlıyayım.

              <strong>Data types and operators, </strong><strong>Type casting, </strong><strong>Control statement, </strong><strong>Arrays, </strong><strong>OOP design, </strong><strong>Classes and object, </strong><strong>Access modifier, </strong><strong>Non Access Modifier, </strong><strong>Constructors and methods, </strong><strong>Method overloading and overriding, </strong><strong>Polymorphism, </strong><strong>Inner Class , </strong><strong>Interfaces and packages, </strong><strong>Inheritance, </strong><strong>Exception handling, </strong><strong>Generics, </strong><strong>Autoboxing, </strong><strong>Enumerations, </strong><strong>Annotations, </strong><strong>The try-with-resources statement, </strong><strong>Varargs, </strong><strong>Multithreading, </strong><strong>The I/O classes, </strong><strong>The Collections Framework, </strong><strong>JavaBeans, </strong><strong>JDBC.</strong>

              Başlamak bitirmenin yarısıdır , diğer yarısını da görürüz insaAllah :)
          <h4><strong>30 November 2014</strong></h4>
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java/core-java/identifiers-javabeans/">Identifiers &amp; JavaBeans</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java/core-java/declare-class-and-declare-interface/">Declare Class and Declare Interface</a></li>
            <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java/core-java/declare-class-members/">Declare Class Members</a></li>
            <li>Chapter 3 : <a href="{{site.baseurl}}/blog/java/core-java/variable-declarations-and-declaring-enums/">Variable Declarations and Declaring Enums</a></li>
            <li>Chapter 4 : <a href="{{site.baseurl}}/blog/java/core-java/object-oriented/">Object Oriented - 1</a></li>
            <li>Chapter 5 : <a href="{{site.baseurl}}/blog/java/core-java/overriding-and-overloading/">Object Oriented - 2 - Overriding and Overloading</a></li>
          </ul>
        </div>
      </div>

    </div>
  </div>

  <div id="javatt" class="tab-pane fade">
    Java ile ilgili sıkça sorulan, karşılaşılan hataların, ufak tüyoların ve önerilerin olacağı, maddeler halinde bir yazı dizisi olucaktır.

    Sık sık eklemeler yapmaya çalışacağım..

    <hr>

    <strong>17 August 2014</strong>

    <p><strong>Soru</strong> : İnterface'lerden neden obje olusturulamaz ?</p>

    <p><strong>Cevab</strong> : İnterface'ler tamamen abstract methodlara yani gövdesiz methodlara sahiptir. İçi boş olan methodun yapacagı hicbir işlevsellik yoktur. İnterface'lerin constructor'u  da yoktur. Bu nedenle new InterfaceAdi() gibi bişey yapılamaz.</p>

    <strong>2 October 2014</strong>
      <ul>
      <li>Java resmi tanıtımında , char bir tamsayı tipi olarak geçer .Bu char'ın ; bir int , short, long ile aynı karekterde oldugunu gosterir.</li>
      <li>Bir koleksiyonu foreach döngüsü içerisinde kullanabilmek için o koleksiyonun Iterable interface'sini implement etmesi gerekir.</li>
      </ul>
    <strong>5 October 2014</strong>

    <p><strong>Soru : </strong>Interface değişkenlerin değeri neden değiştirilmez ?

    <p><strong>Cevab : </strong>Interface variable implicit(kapalı) olarak <strong>public static final</strong> 'dır.Bu nedenle değişkenden çok constant(sabit)'dır.</p>


    <p><strong>public static final int MIN_SIZE = 4;</strong></p>
    <p><strong>int MIN_SIZE = 4;</strong></p>


    İki tanımlamada aynıdır ve geçerlidir.

    Interface variable final olduğu için declare edildiginde değerinin de atanması gerekir.
    <p><strong>int MIN_SIZE;</strong></p>

    Yukardaki kodu çalıştırdığımızda compiler error oluşacak ve bize şu hatayı vericektir; <strong>Java: cannot  assing a value to final variable MIN_SIZE.</strong>

    <strong>13 October 2014</strong>

    <p><strong>Soru : </strong>JSP lifecycle'de bulunan <strong>jspInit()</strong> , <strong>jspDestroy()</strong> ile <strong>_jspService()</strong> methodlarının isimlendirilmesi neden farklıdır?</p>

    <p><strong>Cevap : </strong>Java da method isimlendirmede <strong>camelCase </strong>yapısını kullanıyoruz. Yukarıdaki methodlar java naming conventions'a uymakta. <strong>jspService() </strong>methodunun başındaki underscore(_) bize bu methodun override edilemeyeceğini belirtmektedir. Kısaca bize "don't touch" demekte :) . Aynı şekilde underscore ön eki olmayan methodları da override edebiliriz anlamı vardır.</p>

    <strong>5 November 2014</strong>

    <p><strong>Soru : </strong>Java'da abstract ve final keyword'leri bir arada kullanılabilinir mi?</p>

    <p><strong>Cevap : </strong>Hayır, hiç bir şekilde kullanılamaz. Abstract ve final kelimeleri asla yanyana gelemez.

    Kısaca abstract demek "türet" demektir yani implemente et demektir . Final ise tam tersidir. Örneğin bir methodu abstract tanımlayarak onu alt sınıflarca implemente edilmesini saglayabiliriz. Yine aynı methodu final ile tanımlarsak alt sınıflarca bu methodun yeniden tanımlanmasının önüne geçmiş oluruz.</p>

    <p>Abstract -> Türet</p>

    <p>Final -> Türetme</p>

    <p>Bu iki kelimeninin yanyana gelememesinin dışında abstract ve private ile abstract ve static kelimeleri de yanyana gelemez. Çünkü private methoda alt sınıflar ulaşamayacak ve bizim abstract ile "türetmek" istegimiz boşa çıkmış olucaktır.</p>

    <strong>public abstract final void test();</strong>
    <p>Yukardaki methodu yazmaya kalkıştıgımızda kullandıgımız ide (İntellij İdea)  bize yanlış bir combinasyon kullandığımızı söyleyecektir.</p>

    <img src="/images/java-platform/core-java/javatt-abstract.png"/>


    <p>^ Aynı hata iletisini şu method tanımlamarı içinde alırız;</p>
    <p><strong>
    private abstract void test();
    public static abstract void test();</strong>
    </p>


    <strong>23 January 2015 </strong>

    <p><strong>Soru : </strong>Override edilen methodlarda ne tür kurallara uymak zorundayız?</p>

    <p><strong>Cevap : </strong>Override edilen methodlarda şunlara dikkat edebiliriz;</p>
      <ul>
      <li>Override edilen methodlarda argüman listesi aynı olmak zorundadır.</li>
      <li>Argüman list aynı değilse override değil overloaded etmiş oluruz methodu!</li>
      <li>Return type aynı olmaldır yada subclass tipinde olabilir.</li>
      <li>Access modifiers olarak daha fazla kısıtlayıcı modifiers ile tanımlayamayız. Örneğin süperclass'da public olan bir method subclass içerisinde protected yapılamaz.</li>
      <li>Access modifiers olarak daha az kısıtlayıcı modifiers ile tanımlayabiliriz. Örneğin süperclass'da protected olan bir method subclass'da public tanımlanabilir.</li>
      <li>Method tanımında exception throw edilmemişse override ederken de throw edilemez.</li>
      <li>Süper sınıftaki method tanımında bulunan throw Exception ifadesi daha dar kapsamlı olacak şekilde yeniden declare edilebilir.
    Legal ;
    <pre class="lang:java decode:true">//super sınıftaki method
    public void hello() throws Exception{
      System.out.println("hello-süper");
    }

    //subclassdaki method
    @Override
    public void hello() throws RuntimeException{
      System.out.println("hello-sub");
    }</pre>
    Illegal ;
    <pre class="lang:java decode:true">//super sınıftaki method
    public void hello() throws RuntimeException{
      System.out.println("hello-süper");
    }

    //subclassdaki method
    @Override
    public void hello() throws Exception{
      System.out.println("hello-sub");
    }</pre>
    </li>
    <li>Exception kapsamını daraltabiliriz ama genişletemeyiz.</li>
    <li>final olan methodların override edilemeyeceğini de unutmayalım.</li>
    <li>Kalıtılabilen methodlar sadece override edilebilir. Bu yüzden private olan bir method override edilemez!</li>
    <li>Subclass'da override edilen method içerisinden super.overriddenMethodName() çağrısı yapılabilir.</li>
    </ul>

    <p><strong>27 May 2015</strong></p>

    <p>Jsp, expression içerisine yazılanlar implicit obje olan JspWriter out objesine parametre olarak gönderilir bu yüzden expression bitiminde ; kullanılmaz. Parametre olarak gönderilmesinden dolayı da void return tipte method çağrımı expression içerisinde yapılamaz. </p>
    Örn;
    <pre class="theme:idle lang:java decode:true">
    <%!
      public void print(){
          System.out.println(new Date().toString());
      }
    %>
    </pre>

    <p>Yukarıdaki methodu expression içerisinde çağırdığımızda jsp sayfamız compile olmayacaktır.
    <pre class="theme:eclipse lang:java decode:true ">date  <%= print() %></pre>
    İlgili Jsp sayfası compile olmayacaktır ve hata olarak JspWriter out objesinin void tipte parametre kabul etmediğini bize bildirecektir.</p>

    <strong>20 June 2015</strong>

    <p>Jax-RS ile web servis yazarken kullandığımız methodlar için bazen Mime type bilgisi belirsiz yada birden fazla olabilir. Örn; ../api/books Restful url'i bize books'ları dönecektir. Burada xml, json vs gibi dönebilir. Yada ../api/book/ gibi bir url book alıp serverde save edebilir ve gelen data xml, json gibi değişik tipte datalar olabilir. Bu tip durumlarda Restful methodlar üzerinde konumlandıracağımız @Consumes ve @Produces annotation'ları önem kazanacaktır. Unsupported media type hatası almamak için bu tip durumlarda joker ifade kullanabiliriz;</p>

    <ul>
      <li>Tüm media type için @Consumes içerisinde */* ile her türlü mime type kullanılabilir.</li>
      <li>Return type için tüm text media type için ise @Produces içerisinde text/* yazılabilir.</li>
      <li>Örn; image/* , text/* , application/* gibi.</li>
    </ul>

    <p><strong>27 September 2015</strong></p>

    <p>Java'da iki String ifadeyi karşılaştırmak sıkça karşılaşılan bir durumdur. Bunu birden fazla çeşitle gerçekleştirebiliriz. Bunlar; == kullanmak, equals() methodu yada compareTo() methodunu kullanmak olabilir.  == ve equals() arasındaki farkı çoğu kişi biliyordur sanırım ve interview question'lar içerisinde en sık bulunan konulardandır. == ifadesi reference karşılaştırması yapar yani obje eşitliğini kontrol eder, equals() ise içerik/value karşılaştırması yapar. Bu nedenle farklı sonuçlar üretilir ikisinin kullanımında.</p> Örn;
    <pre class="theme:eclipse lang:java decode:true ">
    String literal = "abc";
    String object = new String(literal);

    if(literal.equals(object)){
      System.out.printf("String %s and %s are equal %n", literal, object); }
    else {
      System.out.printf("String %s and %s are not equal %n", literal, object);
    }

    if(literal == object){
      System.out.printf("String %s and %s are same object %n", literal, object);
    }else {
      System.out.printf("String %s and %s are different object %n", literal, object);
    }
    </pre>
    Çıktı olarak şunu görebiliriz;

    <p><strong>String abc and abc are equal </strong></p>

    <p><strong>String abc and abc are different object</strong></p>

    <p>String/obje compare etmek için best practice olabilecek nitelikte şunları standart hale getirmek, yazılan kodu daha sağlam yapıcaktır.</p>
    <ul>
    <li>equals() methodu obje üzerinden değil, String ifade üzerinden çağrılmalıdır. Bu sayede Null Pointer oluşmasının önüne geçilebilir. Şöyle ki;
    <pre class="theme:eclipse lang:java decode:true">
      String apple = "Apple";
      String fruit = getFruit(); // methoddan fruit null gelebilir, dikkat!

      // Bu kod fruit null ise exception fırlatacaktır
      if(fruit.equals("Apple"){
        System.out.println("Make Apple Shake");
      }
      // Bu kod her zaman çalışacaktır. Fruit null olsa dahi. Bunu tercih etmeliyiz.
      if("Apple".equals(fruit){
        System.out.println("Make Apple Shake");
      }
      </pre>
    </li>
    <li>String yada objenin null ile compare edilmesi yine yukarıdaki gibi NullPointer'a sebep olabilir. Şöyle ki;
      <pre class="theme:eclipse lang:java decode:true ">//fruit null ise exception fırlatır. Null reference üzerinden birşey çağrılamaz!
      if(!fruit.equals(null)){
        System.out.printf("We have got %s today", fruit.name());
      }

      //yukardakine göre bunu tercih etmeliyiz. Null ise dahi calısacaktır.
      if(fruit != null){
        System.out.printf("We have got %s today", fruit.name());
      }
      </pre>
    </li>
    </ul>

    <p><strong>17 December 2015</strong></p>

    Servlet, initalize olmadan önce getServletConfig() methodunun çağrılması Servlet instantiating exception'a neden olur. Container tarafından init() methodu çağrıldıktan sonra Servlet'imiz oluşmuş olur ancak. Bu nedenle Servlet class constructor içerisinde Servlet Config'e erişmek hataya neden olacaktır.  Aşağıdaki code şu hataya örnektir;
    <pre class="theme:eclipse lang:java decode:true">public class MyServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    public MyServlet() {

      final ServletConfig config = getServletConfig();
      final String email = config.getInitParameter("email");//web.xml içerisinde servlet için "email" parametresinin oldugunu varsayalim.
      getServletContext().setAttribute("email", email);

    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

      PrintWriter pw = response.getWriter();
      pw.print("Email : " + getServletContext().getAttribute("email"));

      pw.close();

    }

    }</pre>

    <p>Burada hataya neden olan kod şu kısımdır;</p>
    <pre class="theme:eclipse lang:java decode:true">final ServletConfig config = getServletConfig();</pre>
    <p>Servlete erişmek istediğimizde aşağıdaki sonucu görebiliriz;</p>

    <img class="size-full wp-image-1062 aligncenter" src="http://alicanakkus.com/wp-content/uploads/2014/08/Screenshot-from-2015-12-17-000105.png" alt="Screenshot from 2015-12-17 00:01:05" width="849" height="276" />


    <p><strong>17 December 2015</strong></p>

    <p>Nullable pattern olarak da bilinen beklenilen durum haricinde bir olay gerçekleştiğinde exception fırlatmak yerine geçersiz/invalid değerlere sahip objeler kullanmak exceptionlara takılmamanızı ve ek null, !null kontrolleri yapmamınızı sağlar. Örn; DB'den Employee getirmek istiyen bir methodunuz bulunsun.  Employee bulunmazsa hata fırlatmak yerine boş bir Employee nesnesi göndermeniz kodu global kod standartlarına uymasını ve exceptionlara takılmamanızı sağlar.</p>

    <pre class="lang:default decode:true ">public Employee getEmployee(int id){

      if (is employee found in a db)
        return employee
      else
        return default employee instead of exception

    }</pre>

    <p>Employee db'de bulunursa dönen Employee objesinde name : Alican, surname : Akkus, id : 12345 oldugunu varsayalım. Bulunmadıgı durumlarda ise null object yeribe name : Unknow, surname : Unknow, id : Unknow gibi bir objenin gelmesini beklememiz lazım.</p>

    <p><strong>20 February 2016</strong></p>

    <p>Java'da String nesneleri immutable'dir, yani oluşturulduktan sonra değiştirilemez durumdadırlar. Peki String manipülasyonları nasıl yapılır ona bakalım;</p>

    <p>Elimizde String name="çaysever" adında bir string referansı olduğunu varsayalım. Java heap'de "çaysever" için bir referans oluşturulur ve name değişkenine atanır. Name değişkeninde bir değişiklik yapalım;</p>

    <pre class="theme:eclipse lang:java decode:true ">
      1 - String name = "çaysever";

      2 - System.out.println(name); // çaysever

      3 - name.toUpperCase(); // name = ÇAYSEVER

      4 - System.out.println(name); // çaysever

      5 - name = name.toUpperCase();

      6 - System.out.println(name); // ÇAYSEVER
    </pre>

    <p>3.cü satırda name değişkeninin tuttugu stringi büyük harfe çevirmekteyiz. Bu aşama da var olan string nesnesi üzerinde işlem yapılmaz, yeni bir string nesnesi üretilir ve değeri "ÇAYSEVER" olarak set edilir. Yeni nesne referansı herhangi bir degiskene atanmadıgı için 4.cü satırda tekrar ilk değeri görüyor olacağız. Aynı işlemi 5.ci satırda yapıp name değişkenine referans olarak atadıgımızda değişimi 6.ci satırda görebiliriz.</p>

    <p>Bir de şuna bakalım;</p>
    <pre class="theme:eclipse lang:java decode:true ">
      String name = "ali";
      name += " can"+ " akkus";
    </pre>

    <p>name degiskeni üzerinde yapılan işlemde jvm " can" ve " akkus" için birer string nesnesi oluşturacaktır, eklenen degerlerle birlikte toplam 3 adet string nesnesi oluşmuş olur;</p>

    <p>1 - " can" , 2 - " akkus" , 3 - "ali can akkus". Son olarak name degiskenine olusan string nesnesinin referansı atanmaktadır.</p>


    <p>Bir Java uygulamasında String ve char[] nesneleri memoryi %25-%40 oranında kullanmaktadır. Bilinçsizce string kullanımı  OutOfMemory'e sebep olabilmekte ve uygulamanın sonlanmasına neden olmaktadır. Java kendi içerisinde string pool kullanarak bunu önlemeye yardımcı olur bir nebze. Örneğin kodun farklı yerlerinde "alican" olarak birçok String oluşturulabilir ancak Jvm tarafından heap de String pool içerisinde tek bir "alican" nesnesi bulunur ve her String s = "alican" benzeri string degiskenleri aynı referansa sahip olur.</p>
    <p>Bir diğer yöntem ise String manipülasyonu yapmak için StringBuilder ve StringBuffer nesnelerini kullanmak olacaktır. Bu iki nesne aynı olmakla beraber farkları ise StringBuffer nesnesini thread safe olmasıdır. Bu yüzden biraz yavaştır, hız açısından StringBuilder kullanılmalıdır. Bu nesneler üzerindeki string manipülasyonlarında yeni string nesneleri oluşturulmaz, var olan nesne üzerinden işlemler yapılır.</p>

    <strong>25 Apr 2016</strong>

    <p>String compare ederken sabit/belli olan stringin left side'da olması runtime anındaki exceptionları azaltır. Şöyle ki;</p>
    <pre class="theme:eclipse lang:default decode:true">if("alican".equalsIgnoreCase(user.getName())){
      .....
    }
    </pre>
    "alican" stringi sabit yani belirli bir string ve sağ taraftaki user'dan alınan name degiskenini equals ediyoruz. Burada user'dan alınan name null olabilir, sorun cıkmayacaktır. Ancak kodun şu şekilde oldugunu varsayalım;
    <pre class="theme:eclipse lang:default decode:true">if(user.getName().equalsIgnoreCase("alican")){
      .....
    }</pre>
    Bu durumda user'dan alınan name degiskeni null ise runtime exception olacagız. Dikkat edilesi bir trick ;)

    <p><strong>27 May 2016</strong></p>

    <p>Servlet Contaıner olarak Tomcat kullanııyor iseniz, tomcat'in default olarak session için cookie de oluşturduğu Session Id adını değiştirebilirsiniz;</p>

    <p>JSessionID server side tarafında çalışır, client tarafından erişilemez. JSessionID'nin expired date'i de yoktur, ayrıca WebServer ve/veya Appliaction server uzun süre bir hareketlilik görmezse session cookie'yi silme insiyatifini elinde tutar.</p>

    <p>Default olarak tomcat, sesssion için unique olan string tipinde jsessionid oluşturup set ediyor. Bunu degistirmek için tomcat conf altındaki context.xml dosyasında şu değişikliği yapalım;</p>

    <pre class="theme:eclipse lang:xhtml decode:true ">
      &lt;Context sessionCookieName="JCaysever"&gt;
               Default set of monitored resources
             &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;
      &lt;/Context&gt;
    </pre>

    Örnek olarak default cookine name ile tomcat şöyle bir session id olusturur : https://webapp.com/index.jsp;jsessionid=557206C363F1267A24AB769CA0DE4529.node01

    Değişiklik sonrası şunun gibi olacaktır : https://webapp.com/index.jsp;JCaysever=557206C363F1267A24AB769CA0DE4529.node01

  </div>  
  <!-- spring platform -->
  <div id="spring" class="tab-pane fade">
    <div class="panel-group">

      <!-- spring mvc yazıları -->
      <div id="spring-mvc" class="panel panel-info">
        <div class="panel-heading">Spring MVC <span class="label label-info">5</span></div>
        <div class="panel-body">
          <ul>
            <li>Spring MVC Introduction</li>
            <li>Spring MVC Introduction</li>
            <li>Spring MVC Introduction</li>
          </ul>
        </div>
      </div>

      <!-- spring aop yazıları -->
      <div id="spring-aop" class="panel panel-info">
        <div class="panel-heading">Spring AOP <span class="label label-info">5</span></div>
        <div class="panel-body">
          <ul>
            <li>Spring AOP Introduction</li>
            <li>Spring AOP Introduction</li>
            <li>Spring AOP Introduction</li>
          </ul>
        </div>
      </div>

      <!-- spring data yazıları -->
      <div id="spring-data" class="panel panel-info">
        <div class="panel-heading">Spring DATA <span class="label label-info">5</span></div>
        <div class="panel-body">
          <ul>
            <li>Spring DATA Introduction</li>
            <li>Spring DATA Introduction</li>
            <li>Spring DATA Introduction</li>
          </ul>
        </div>
      </div>

    </div>
  </div>


  <div id="apache-guys" class="tab-pane fade">
    <div class="panel-group">
      <!-- apache-log4j yazıları -->
      <div id="apache-log4j" class="panel panel-info">
        <div class="panel-heading">Apache Log4j <span class="label label-info">1</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java/apache-log4j/log4j-introduction/">Log4j Introduction</a></li>
          </ul>
        </div>
      </div>

      <!-- apache-maven yazıları -->
      <div id="apache-maven" class="panel panel-info">
        <div class="panel-heading">Apache Maven <span class="label label-info">3</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java/apache-maven/maven-introduction/">Maven Introduction</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java/apache-maven/simple-maven-project/">Simple Maven Project</a></li>
            <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java/apache-maven/maven-pom/">Maven POM</a></li>
          </ul>
        </div>
      </div>

      <!-- apache-mina yazıları -->
      <div id="apache-maven" class="panel panel-info">
        <div class="panel-heading">Apache Mina <span class="label label-info">2</span></div>
        <div class="panel-body">
          <ul>
            <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java/apache-mina/apache-mina-introduction/">Apache Mina Introduction</a></li>
            <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java/apache-mina/apache-mina-client/">Mina Client</a></li>
          </ul>
        </div>
      </div>

            <!-- apache-myself -->
            <div id="apache-myself" class="panel panel-info">
              <div class="panel-heading">Log Analys <span class="label label-info">1</span></div>
              <div class="panel-body">
                <p>Üniversite bitirme projesi olarak, cluster ortamda çalışan bir Log Analiz uygulaması yapmıştım. Başlangıçta sadece Log analizi olarak düşünmüşken proje ilerledikçe farklı dosya türlerine destek verecek yapıya büründü proje.</p>

                <p>Log Analiz App, Apache Hadoop üzerinde çalışan ve uygulamaların oluşturmuş olduğu log dosyalarının analizini gerçekleştiren Java’da yazılmış bir araçtır. Specification içerisinde bazı kurallar tanımlıdır, bunlardan en önemlisi analiz edilecek olan datanın başında ASCII STX(Start Of Text) ve sonunda ASCII ETX(End Of Text) karekterlerinin olmasıdır. Template desteği ile istenilen stx ve etx karekteri ayarlanabilmektedir. Detaylara pdf dosyasından erişebilirsiniz.</p>

                Log Analiz uygulamamızın en önemli avantajı tamamen configuration dosyası üzerinden tüm işlemlerin yapılmasıdır. Detaylarına pdf'den erişebileceginiz gibi ufak detaylar da vermek isterim. Uygulama kullanıcısı, configuration dosyası içerisinde hangi verinin nasıl işleneceğini(Template Definition), işlenen veririn nasıl sunulacağını(Monitoring Definition), analiz sonucu oluşan temiz data'nın nereye aktarılacağı(Export Adaptor Definition) gibi işlemleri yapabilmektedir. Örnek olarak kullanıcı; Web Server log dosyası için aynı anda farklı template'ler tanımlayabilir, bu template'ler context initialization ve/veya context destroy işlemleri olabilirken aynı anda method execute time, method invoke count vb olabilir. Template sonucunu file/db export adaptorlerine aktarabilir ve aynı anda http üzerinden(port vs conf. tabanlı) monitoringi yapabilir.

                <h4>Log Analiz v0.3 şuan da aşağıdaki özelliklere sahiptir</h4>
                <ul>
                  <li>Verilen dosyaların nasıl işleneceğini belirten en önemli konfigürasyon tanımıdır. Log satırının neler içerdiği, tiplerinin ne olduğunu ve bu alanlar üzeride tanımlanmış formatları belirtir. Templates içerisidne ve birden fazla template tanımlanabilir. </li>
                  <li> Method bazında : Methodların toplam çalışma zamanı, bir log dosyası içerisinde çağrılan toplam method sayısı. Bu methodların çağrılma zamanları gibi analizleri yapabilmektedir.</li>
                  <li> Log dosyası eğer Java Web Application ise Context initialization ve Context destroyed aksiyonları için uygulamanın server’da ne kadar sürede ayağa kalktığı ve durduğu tespit edilebilmektedir.</li>
                  <li> Bir method içerisinde tanımı gerçekleştirilen değişken tanımları sayısı ve bu değişkenlerin bellekte kapladığı alanın byte cinsinden değeri bulunabilmektedir.</li>
                  <li> Analiz sonucu oluşan dataların HTTP üzerinden monitoringi yapılabilmektedir. Burada herhangi bir external web server gerekli değildir, uygulama çalışmaya başladığında embeded bir tomcat ayağa kaldırak hazır war uygulamasını da deploy etmektedir. Bu sayede analizi edilen dataların sunulabilmesi sağlanmıştır.</li>
                  <li> Log dosyasında boyut sınırlaması bulunmamaktadır. Hadoop ile cluster mimari de çalıştığı için dosya boyutunun büyük olması tercih edilebilir, küçük dosyalar da hız avantajı net görülemeyebiliyor çünkü.</li>
                  <li> Export Destinations : File/DB/Socket seçeneklerinden aynı anda bir veya daha fazlasını seçerek analiz sonucu elde edilen data'yı istediği yere aktarabilir. Her Definition için özel ayarlar mevcuttur. Örneğin file için dosyaya yazma formatı, max dosya boyutu, db için table/column tanımları, socket için port/ip ve mesaj yazma interval gibi degerler conf. bazlıdır.</li>
                  <li>Analiz edilen verilerin kaybedilmemesi için uygulama kendi içerisinde H2 memory database ayağa kaldırmaktadır. Gerekli tablo ve tablo desenleri conf'da ki tanımlamalardan yola çıkılarak oluşturulur.</li>
                </ul>

                Proje dokümanına <a href="{{site.baseurl}}/v2-alican-abdurrahman_bitirme_tez.pdf">buradan</a> , proje sunumuna <a href="{{site.baseurl}}/bitirme_sunum.pdf">buradan</a> kodlara ise <a href="https://github.com/AlicanAkkus/LogAnalys">şuradan</a> erişebilirsiniz.
              </div>
            </div>

    </div>
  </div>

  <div id="android-tutorial" class="tab-pane fade">
      <div class="panel panel-info">
        <div class="panel-heading">Android Tutorial <span class="label label-info">21</span></div>
        <div class="panel-body">
          <ul>
              <li>Chapter 0 : <a href="{{site.baseurl}}/blog/java/android/android-programlama-giris/">Android Programlama Giriş</a></li>
              <li>Chapter 1 : <a href="{{site.baseurl}}/blog/java/android/android-kurulumu/">Android Kurulumu</a></li>
              <li>Chapter 2 : <a href="{{site.baseurl}}/blog/java/android/android-prog-ders-1/">Android Prog. Ders 1</a></li>
              <li>Chapter 3 : <a href="{{site.baseurl}}/blog/java/android/androidde-gorunum-bilesenleri-button-textview-edittext/">Android’de Görünüm Bileşenleri</a></li>
              <li>Chapter 4 : <a href="{{site.baseurl}}/blog/java/android/androidde-toast-mesaji/">Android’de Toast mesajı</a></li>
              <li>Chapter 5 : <a href="{{site.baseurl}}/blog/java/android/android-custom-toast-mesaji/">Android Custom Toast Mesajı</a></li>
              <li>Chapter 6 : <a href="{{site.baseurl}}/blog/java/android/sayfalar-arasi-gecis-ve-intent-kavrami/">Sayfalar Arası Geçiş ve Intent Kavramı</a></li>
              <li>Chapter 7 : <a href="{{site.baseurl}}/blog/java/android/intent-ile-veri-transferi/">Intent ile veri transferi</a></li>
              <li>Chapter 8 : <a href="{{site.baseurl}}/blog/java/android/android-gorunum-bilesenleri-2-togglebutton-checbox/">Android Görünüm Bileşenleri 2</a></li>
              <li>Chapter 9 : <a href="{{site.baseurl}}/blog/java/android/android-listview-kullanimi/">Android ListView Kullanımı</a></li>
              <li>Chapter 10 : <a href="{{site.baseurl}}/blog/java/android/android-spinner-kullanimi/">Android Spinner Kullanımı</a></li>
              <li>Chapter 11 : <a href="{{site.baseurl}}/blog/java/android/android-seekbar-kullanimi/">Android SeekBar Kullanımı</a></li>
              <li>Chapter 12 : <a href="{{site.baseurl}}/blog/java/android/android-webview-kullanimi/">Android WebView Kullanımı</a></li>
              <li>Chapter 13 : <a href="{{site.baseurl}}/blog/java/android/alertdialog-ve-progressdialog-kullanimi/">AlertDialog ve ProgressDialog Kullanımı</a></li>
              <li>Chapter 14 : <a href="{{site.baseurl}}/blog/java/android/context-menu-ve-dinamik-listview/">Context Menu ve Dinamik ListView</a></li>
              <li>Chapter 15 : <a href="{{site.baseurl}}/blog/java/android/activity-lifecycle/">Activity Lifecycle</a></li>
              <li>Chapter 16 : <a href="{{site.baseurl}}/blog/java/android/activityforresult-ile-activityden-geriye-bilgi-gondermek/">ActivityForResult ile Activity'den geriye bilgi göndermek</a></li>
              <li>Chapter 17 : <a href="{{site.baseurl}}/blog/java/android/passing-object-between-activities/">Passing Object Between Activities</a></li>
              <li>Chapter 18 : <a href="{{site.baseurl}}/blog/java/android/intent-type-and-register-intent/">Intent type and Register Intent</a></li>
              <li>Chapter 19 : <a href="{{site.baseurl}}/blog/java/android/broadcast-receiver/">Broadcast Receiver(Static, Dynamic and Custom Broadcast)</a></li>
              <li>Chapter 20 : <a href="{{site.baseurl}}/blog/java/android/android-sqlite-1/">Android-SQLite 1 </a></li>            
          </ul>
        </div>
      </div>
  </div>


  <div id="view-tech" class="tab-pane fade">

  </div>
</div>
